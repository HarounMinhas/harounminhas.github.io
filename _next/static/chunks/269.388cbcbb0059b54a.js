"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[269],{5269:function(e,t,a){a.r(t),a.d(t,{GraphModel:function(){return te},deregisterOp:function(){return k},loadGraphModel:function(){return tt},loadGraphModelSync:function(){return ta},registerOp:function(){return A},version_converter:function(){return tn}});var n,r,s,o,i,p={};a.r(p),a.d(p,{json:function(){return P}});var u={};a.r(u),a.d(u,{json:function(){return B}});var m={};a.r(m),a.d(m,{json:function(){return j}});var l={};a.r(l),a.d(l,{json:function(){return U}});var d={};a.r(d),a.d(d,{json:function(){return q}});var c={};a.r(c),a.d(c,{json:function(){return H}});var y={};a.r(y),a.d(y,{json:function(){return W}});var h={};a.r(h),a.d(h,{json:function(){return G}});var f={};a.r(f),a.d(f,{json:function(){return Q}});var g={};a.r(g),a.d(g,{json:function(){return K}});var N={};a.r(N),a.d(N,{json:function(){return X}});var T={};a.r(T),a.d(T,{json:function(){return J}});var b={};a.r(b),a.d(b,{json:function(){return Y}});var x={};a.r(x),a.d(x,{json:function(){return Z}});var S={};a.r(S),a.d(S,{json:function(){return ee}});var _={};a.r(_),a.d(_,{json:function(){return et}});var O={};a.r(O),a.d(O,{json:function(){return ea}});var w={};a.r(w),a.d(w,{json:function(){return en}});var I={};a.r(I),a.d(I,{json:function(){return er}});var v={};a.r(v),a.d(v,{OP_SCOPE_SUFFIX:function(){return eS.zvA},abs:function(){return eS.WnP},acos:function(){return eS.Khb},acosh:function(){return eS.__u},add:function(){return eS.IHx},addN:function(){return eS.QBD},all:function(){return eS.$6P},any:function(){return eS.YjB},argMax:function(){return eS.NqF},argMin:function(){return eS.vHJ},asin:function(){return eS.ZRM},asinh:function(){return eS.VfV},atan:function(){return eS.z4N},atan2:function(){return eS.fvJ},atanh:function(){return eS.C80},avgPool:function(){return eS.wS1},avgPool3d:function(){return eS.uR5},basicLSTMCell:function(){return eS.zEQ},batchNorm:function(){return eS.tgs},batchNorm2d:function(){return eS.Dxk},batchNorm3d:function(){return eS.JY5},batchNorm4d:function(){return eS.p3b},batchToSpaceND:function(){return eS.E4h},bincount:function(){return eS.yE8},bitwiseAnd:function(){return eS.ycw},booleanMaskAsync:function(){return eS.anm},broadcastArgs:function(){return eS.XsQ},broadcastTo:function(){return eS.UFq},buffer:function(){return eS.f3b},cast:function(){return eS.pju},ceil:function(){return eS.mDi},clipByValue:function(){return eS.iUl},clone:function(){return eS.d9v},complex:function(){return eS.PYB},concat:function(){return eS.zoF},concat1d:function(){return eS.gME},concat2d:function(){return eS.Izb},concat3d:function(){return eS.MNy},concat4d:function(){return eS.ZaL},conv1d:function(){return eS.PAt},conv2d:function(){return eS.Tek},conv2dTranspose:function(){return eS.bc},conv3d:function(){return eS.pdZ},conv3dTranspose:function(){return eS.$QV},cos:function(){return eS.mCk},cosh:function(){return eS.f9Y},cosineWindow:function(){return eS.mew},cumprod:function(){return eS.$Gn},cumsum:function(){return eS.zbp},denseBincount:function(){return eS.ppE},depthToSpace:function(){return eS.nTT},depthwiseConv2d:function(){return eS.B10},diag:function(){return eS.Ka3},dilation2d:function(){return eS.WmZ},div:function(){return eS.hiC},divNoNan:function(){return eS.NTj},dot:function(){return eS.AKD},dropout:function(){return eS.rvX},einsum:function(){return eS.WYO},elu:function(){return eS.pyx},enclosingPowerOfTwo:function(){return eS.GRh},ensureShape:function(){return eS.EDe},equal:function(){return eS.DgJ},erf:function(){return eS.qNN},euclideanNorm:function(){return eS.d2q},exp:function(){return eS.Qqt},expandDims:function(){return eS.dt4},expm1:function(){return eS.t$B},eye:function(){return eS.iyy},fft:function(){return eS.kp_},fill:function(){return eS.hlL},floor:function(){return eS.GWj},floorDiv:function(){return eS.qPi},fused:function(){return eS.imm},gather:function(){return eS.Iqj},gatherND:function(){return eS.dbB},greater:function(){return eS.pjt},greaterEqual:function(){return eS.brS},ifft:function(){return eS.Sxn},imag:function(){return eS.asL},image:function(){return eS.BHj},inTopKAsync:function(){return eS.V3u},irfft:function(){return eS.wx0},isFinite:function(){return eS.xVT},isInf:function(){return eS.UWc},isNaN:function(){return eS.i2d},leakyRelu:function(){return eS.hi7},less:function(){return eS.d9m},lessEqual:function(){return eS.zN1},linalg:function(){return eS.$r2},linspace:function(){return eS.SX3},localResponseNormalization:function(){return eS.G9k},log:function(){return eS.cM7},log1p:function(){return eS.Krr},logSigmoid:function(){return eS.e_t},logSoftmax:function(){return eS.CmS},logSumExp:function(){return eS.l_t},logicalAnd:function(){return eS.HvI},logicalNot:function(){return eS.hJK},logicalOr:function(){return eS.K5V},logicalXor:function(){return eS.egP},losses:function(){return eS.MB5},lowerBound:function(){return eS.eab},matMul:function(){return eS.OI3},max:function(){return eS.Fp7},maxPool:function(){return eS._sB},maxPool3d:function(){return eS.YQQ},maxPoolWithArgmax:function(){return eS.Ip$},maximum:function(){return eS.gWQ},mean:function(){return eS.J69},meshgrid:function(){return eS.ry_},min:function(){return eS.VV$},minimum:function(){return eS.LTh},mirrorPad:function(){return eS.VdP},mod:function(){return eS.wQq},moments:function(){return eS.Gi7},movingAverage:function(){return eS.p_},mul:function(){return eS.dC7},multiRNNCell:function(){return eS.rq4},multinomial:function(){return eS.SJ_},neg:function(){return eS.W76},norm:function(){return eS.KOy},notEqual:function(){return eS.Quu},oneHot:function(){return eS.lfX},ones:function(){return eS.iUs},onesLike:function(){return eS.JpU},op:function(){return eS.op},outerProduct:function(){return eS.N2O},pad:function(){return eS.vku},pad1d:function(){return eS.pNR},pad2d:function(){return eS.koy},pad3d:function(){return eS.t1L},pad4d:function(){return eS.lGY},pool:function(){return eS.d_R},pow:function(){return eS.sQ3},prelu:function(){return eS.AL3},print:function(){return eS.S0v},prod:function(){return eS.WVs},raggedGather:function(){return eS.$gW},raggedRange:function(){return eS.VT$},raggedTensorToTensor:function(){return eS.N89},rand:function(){return eS.TN_},randomGamma:function(){return eS.wzB},randomNormal:function(){return eS.nGf},randomStandardNormal:function(){return eS.ruB},randomUniform:function(){return eS.LGj},randomUniformInt:function(){return eS.pe5},range:function(){return eS.w6H},real:function(){return eS.kwC},reciprocal:function(){return eS.M25},relu:function(){return eS.UYe},relu6:function(){return eS.btT},reshape:function(){return eS.XLQ},reverse:function(){return eS.GYS},reverse1d:function(){return eS.SDf},reverse2d:function(){return eS.diP},reverse3d:function(){return eS.sx7},reverse4d:function(){return eS.mG2},rfft:function(){return eS.QEs},round:function(){return eS.NMM},rsqrt:function(){return eS.bp0},scalar:function(){return eS.iD$},scatterND:function(){return eS.snQ},searchSorted:function(){return eS.zcT},selu:function(){return eS.U8D},separableConv2d:function(){return eS.U_I},setdiff1dAsync:function(){return eS.ODp},sigmoid:function(){return eS.XD2},sign:function(){return eS.Xxe},signal:function(){return eS.tdS},sin:function(){return eS.O$l},sinh:function(){return eS.R_K},slice:function(){return eS.tPi},slice1d:function(){return eS.jZU},slice2d:function(){return eS.SmN},slice3d:function(){return eS.CnO},slice4d:function(){return eS.p0P},softmax:function(){return eS.XAC},softplus:function(){return eS.Wvh},spaceToBatchND:function(){return eS.fBT},sparse:function(){return eS.rVs},sparseToDense:function(){return eS.ers},spectral:function(){return eS.uN7},split:function(){return eS.Vl2},sqrt:function(){return eS._b3},square:function(){return eS.h62},squaredDifference:function(){return eS.$i},squeeze:function(){return eS.L9e},stack:function(){return eS.knu},step:function(){return eS.Nbs},stridedSlice:function(){return eS.NXj},string:function(){return eS.Z_8},sub:function(){return eS.luU},sum:function(){return eS.Smz},tan:function(){return eS.ORZ},tanh:function(){return eS.AEp},tensor:function(){return eS.XeE},tensor1d:function(){return eS.RRF},tensor2d:function(){return eS.odF},tensor3d:function(){return eS.wOQ},tensor4d:function(){return eS.yXz},tensor5d:function(){return eS.Bfx},tensor6d:function(){return eS.xZs},tensorScatterUpdate:function(){return eS.Pg0},tile:function(){return eS.Gg6},topk:function(){return eS.hg7},transpose:function(){return eS.p4s},truncatedNormal:function(){return eS.Xu6},unique:function(){return eS.Two},unsortedSegmentSum:function(){return eS.pUJ},unstack:function(){return eS.HHK},upperBound:function(){return eS.GaM},variable:function(){return eS.VD$},where:function(){return eS.arb},whereAsync:function(){return eS.itS},zeros:function(){return eS.lls},zerosLike:function(){return eS.P84}});var E=a(9094);(0,E.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),(n=o||(o={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",(s=(r=i||(i={})).CheckpointFormatVersion||(r.CheckpointFormatVersion={}))[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2";let D={};function A(e,t){D[e]={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t}}function k(e){delete D[e]}function M(e,t,a,n,r){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,i=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return V(t.inputNames[i],a,n,r);if("tensors"===s.type){let s=t.inputs.slice(e,o);return t.inputNames.slice(e,o).filter((e,t)=>{var a;return(null===(a=s[t])||void 0===a?void 0:a.op)!=="NoOp"}).map(e=>V(e,a,n,r))}let p=V(t.inputNames[i],a,n,r),u=p.dataSync();return"number"===s.type?u[0]:E.util.toNestedArray(p.shape,u)}let o=t.attrParams[e];return o&&o.value}function V(e,t,a,n){let[r,s]=F(e,a);if(null!=n){let e=n.getHashTableHandleByName(r);if(null!=e)return e}let o=a.currentContextIds.find(e=>!!t[z(r,e)]);return void 0!==o?t[z(r,o)][s]:void 0}function L(e,t,a){return t[z(e,a.currentContextId)]}function C(e,t){let[a,n,r]=F(e,t);return[z(a,t&&t.currentContextId),n,r]}function z(e,t){return t?`${e}-${t}`:e}function F(e,t){let a;if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let a=t.parseNodeNameCache.get(e);if(null!=a)return a}let r=e.split(":");if(1===r.length)a=[e,0,void 0];else{let e=r[0],t=3===r.length?r[1]:void 0;a=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,a),a}function R(e,t,a){let n=M("pad",e,t,a);if("explicit"===n){n=M("explicitPaddings",e,t,a);let r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=n[2*e],r[e][1]=n[2*e+1];return r}return n}function $(e){return e.kept?e:(0,E.clone)(e)}let P=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],B=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],j=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],U=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],q=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],H=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],W=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],G=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Q=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],K=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],X=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],J=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Y=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Z=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],ee=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],et=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ea=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],en=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],er=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var es=a(6434).Buffer;class eo{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[p,u,m,l,d,c,y,h,f,g,N,T,b,x,S,_,O,w,I].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){let a=e.node,n=[],r=[],s=[],o=a.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e),{}),i=[],p=[],u={},m={};null!=t&&(u=this.mapSignatureEntries(t.inputs),m=this.mapSignatureEntries(t.outputs));let l=Object.keys(o);l.forEach(e=>{let t=o[e];t.inputNames.forEach((e,a)=>{let[n,,r]=C(e),s=o[n];if(null!=s.outputs){let e=s.outputs.indexOf(r);if(-1!==e){let r=`${n}:${e}`;t.inputNames[a]=r}}t.inputs.push(s),s.children.push(t)})}),0===Object.keys(m).length?l.forEach(e=>{let t=o[e];0===t.children.length&&p.push(t)}):Object.keys(m).forEach(e=>{let[t]=C(e),a=o[t];null!=a&&(a.signatureKey=m[e],p.push(a))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{let[t]=C(e),a=o[t];a&&(a.signatureKey=u[e],i.push(a))}):i=n;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));let c={nodes:o,inputs:i,outputs:p,weights:r,placeholders:n,signature:t,functions:d};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){let t=D[e.op]||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(a.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce((t,a)=>{let n;let r=a.type;switch(a.type){case"string":void 0===(n=ep(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=ep(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":void 0===(n=eN(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=eN(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":void 0===(n=em(e.attr,a.tfName,a.defaultValue||0))&&a.tfDeprecatedName&&(n=em(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":void 0===(n=eg(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=eg(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":void 0===(n=eu(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=eu(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":void 0===(n=eb(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=eb(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":void 0===(n=ef(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=ef(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":void 0===(n=eT(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=eT(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":void 0===(n=ec(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=ec(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":void 0===(n=ey(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=ey(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":void 0===(n=ed(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=ed(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:n,type:r},t},{})),a}mapFunction(e){let t=e.nodeDef,a=[],n={};null!=t&&(n=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e),{}));let r=[],s=[];e.signature.inputArg.forEach(e=>{let[t]=C(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:el(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,r.push(a),n[t]=a}),Object.keys(n).forEach(e=>{let t=n[e];t.inputNames.forEach((e,a)=>{let[r,,s]=C(e),o=n[r];if(null!=o.outputs){let e=o.outputs.indexOf(s);if(-1!==e){let n=`${r}:${e}`;t.inputNames[a]=n}}t.inputs.push(o),o.children.push(t)})});let o=e.ret;e.signature.outputArg.forEach(e=>{let[t,a]=C(o[e.name]),r=n[t];null!=r&&(r.defaultOutput=a,s.push(r))});let i=this.mapArgsToSignature(e);return{nodes:n,inputs:r,outputs:s,weights:a,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function ei(e,t){let a=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=(0,E.env)().global;if(void 0!==t.atob)return t.atob(e);if(void 0!==es)return new es(e,"base64").toString();throw Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?a:a.toLowerCase()}function ep(e,t,a,n=!1){let r=e[t];return null!=r?ei(r.s,n):a}function eu(e,t,a){let n=e[t];return n?n.b:a}function em(e,t,a){let n=e[t]||{},r=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof r?r:parseInt(r,10)}function el(e){switch("string"==typeof e&&(e=o[e]),e){case o.DT_FLOAT:case o.DT_HALF:return"float32";case o.DT_INT32:case o.DT_INT64:case o.DT_INT8:case o.DT_UINT8:return"int32";case o.DT_BOOL:return"bool";case o.DT_DOUBLE:return"float32";case o.DT_STRING:return"string";case o.DT_COMPLEX64:case o.DT_COMPLEX128:return"complex64";default:return null}}function ed(e,t,a){let n=e[t];return n&&n.func?n.func.name:a}function ec(e,t,a){let n=e[t];return n&&n.type?el(n.type):a}function ey(e,t,a){let n=e[t];return n&&n.list&&n.list.type?n.list.type.map(e=>el(e)):a}function eh(e){return e.unknownRank?void 0:null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function ef(e,t,a){let n=e[t];return n&&n.shape?eh(n.shape):a}function eg(e,t,a){let n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):a}function eN(e,t,a,n=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(e=>ei(e,n)):a}function eT(e,t,a){let n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map(e=>eh(e)):a}function eb(e,t,a){let n=e[t];return n&&n.list&&n.list.b?n.list.b:a}class ex{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return V(e,this.tensorMap,this.context)}getAttr(e,t){let a=this.node.rawAttrs[e];if(null!=a.tensor)return V(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return em(this.node.rawAttrs,e,t);if(null!=a.s)return ep(this.node.rawAttrs,e,t);if(null!=a.b)return eu(this.node.rawAttrs,e,t);if(null!=a.shape)return ef(this.node.rawAttrs,e,t);if(null!=a.type)return ec(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return eg(this.node.rawAttrs,e,t);if(null!=a.list.s)return eN(this.node.rawAttrs,e,t);if(null!=a.list.shape)return eT(this.node.rawAttrs,e,t);if(null!=a.list.b)return eb(this.node.rawAttrs,e,t);if(null!=a.list.type)return ey(this.node.rawAttrs,e,t)}return t}}var eS=a(570);let e_=(e,t,a,n=v)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(M("a",e,t,a),M("b",e,t,a))];case"AddN":return[n.addN(M("tensors",e,t,a))];case"FloorMod":case"Mod":return[n.mod(M("a",e,t,a),M("b",e,t,a))];case"Mul":return[n.mul(M("a",e,t,a),M("b",e,t,a))];case"RealDiv":case"Div":return[n.div(M("a",e,t,a),M("b",e,t,a))];case"DivNoNan":return[n.divNoNan(M("a",e,t,a),M("b",e,t,a))];case"FloorDiv":return[n.floorDiv(M("a",e,t,a),M("b",e,t,a))];case"Sub":return[n.sub(M("a",e,t,a),M("b",e,t,a))];case"Minimum":return[n.minimum(M("a",e,t,a),M("b",e,t,a))];case"Maximum":return[n.maximum(M("a",e,t,a),M("b",e,t,a))];case"Pow":return[n.pow(M("a",e,t,a),M("b",e,t,a))];case"SquaredDifference":return[n.squaredDifference(M("a",e,t,a),M("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eO=(e,t,a,n=v)=>{switch(e.op){case"Abs":case"ComplexAbs":return[n.abs(M("x",e,t,a))];case"Acos":return[n.acos(M("x",e,t,a))];case"Acosh":return[n.acosh(M("x",e,t,a))];case"Asin":return[n.asin(M("x",e,t,a))];case"Asinh":return[n.asinh(M("x",e,t,a))];case"Atan":return[n.atan(M("x",e,t,a))];case"Atan2":return[n.atan2(M("x",e,t,a),M("y",e,t,a))];case"Atanh":return[n.atanh(M("x",e,t,a))];case"Ceil":return[n.ceil(M("x",e,t,a))];case"Complex":return[n.complex(M("real",e,t,a),M("imag",e,t,a))];case"Cos":return[n.cos(M("x",e,t,a))];case"Cosh":return[n.cosh(M("x",e,t,a))];case"Elu":return[n.elu(M("x",e,t,a))];case"Erf":return[n.erf(M("x",e,t,a))];case"Exp":return[n.exp(M("x",e,t,a))];case"Expm1":return[n.expm1(M("x",e,t,a))];case"Floor":return[n.floor(M("x",e,t,a))];case"Log":return[n.log(M("x",e,t,a))];case"Log1p":return[n.log1p(M("x",e,t,a))];case"Imag":return[n.imag(M("x",e,t,a))];case"Neg":return[n.neg(M("x",e,t,a))];case"Reciprocal":return[n.reciprocal(M("x",e,t,a))];case"Real":return[n.real(M("x",e,t,a))];case"Relu":return[n.relu(M("x",e,t,a))];case"Round":return[n.round(M("x",e,t,a))];case"Selu":return[n.selu(M("x",e,t,a))];case"Sigmoid":return[n.sigmoid(M("x",e,t,a))];case"Sin":return[n.sin(M("x",e,t,a))];case"Sign":return[n.sign(M("x",e,t,a))];case"Sinh":return[n.sinh(M("x",e,t,a))];case"Softplus":return[n.softplus(M("x",e,t,a))];case"Sqrt":return[n.sqrt(M("x",e,t,a))];case"Square":return[n.square(M("x",e,t,a))];case"Tanh":return[n.tanh(M("x",e,t,a))];case"Tan":return[n.tan(M("x",e,t,a))];case"ClipByValue":return[n.clipByValue(M("x",e,t,a),M("clipValueMin",e,t,a),M("clipValueMax",e,t,a))];case"Relu6":return[n.relu6(M("x",e,t,a))];case"Rsqrt":return[n.rsqrt(V(e.inputNames[0],t,a))];case"LeakyRelu":return[n.leakyRelu(M("x",e,t,a),M("alpha",e,t,a))];case"Prelu":return[n.prelu(M("x",e,t,a),M("alpha",e,t,a))];case"IsNan":return[n.isNaN(V(e.inputNames[0],t,a))];case"IsInf":return[n.isInf(V(e.inputNames[0],t,a))];case"IsFinite":return[n.isFinite(V(e.inputNames[0],t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ew(e,t,a=""){if("number"!=typeof e&&"number"!=typeof t){E.util.assert(e.length===t.length,()=>a+` Shapes ${e} and ${t} must match`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];E.util.assert(r<0||s<0||r===s,()=>a+` Shapes ${e} and ${t} must match`)}}}function eI(e){return!("number"==typeof e||e.some(e=>e<0))}function ev(e,t,a){let n=eE(e,a),r=!eI(n);if(r&&0===t.length)throw Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(r&&t.forEach(e=>{n=eE(e.shape,n)}),!eI(n))throw Error(`Non-fully-defined elementShape: ${n}`);return n}function eE(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let a=[];for(let n=0;n<e.length;++n){let r=e[n],s=t[n];if(r>=0&&s>=0&&r!==s)throw Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=r>=0?r:s}return a}class eD{constructor(e,t,a,n,r,s,o){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=(0,E.scalar)(0),(0,E.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),ew(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,(0,E.keep)(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,a)=>this.write(e,t[a]))}gather(e,t){if(t&&t!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,E.tensor)([],[0].concat(this.elementShape));let a=this.readMany(e);return ew(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),(0,E.stack)(a,0)}concat(e){if(e&&e!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,E.tensor)([],[0].concat(this.elementShape));let t=[];for(let e=0;e<this.size();e++)t.push(e);let a=this.readMany(t);return ew(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),(0,E.concat)(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,(0,E.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0,n=e.map(e=>a+=e);if(a!==t.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=0===a?0:t.size/a,s=[];(0,E.tidy)(()=>{t=(0,E.reshape)(t,[1,a,r]);for(let a=0;a<e.length;++a){let o=[0,0===a?0:n[a-1],0],i=[1,e[a],r];s[a]=(0,E.reshape)((0,E.slice)(t,o,i),this.elementShape)}return s});let o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,s)}}class eA{get id(){return this.idTensor.id}constructor(e,t,a,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,null!=e&&e.forEach(e=>{if(a!==e.dtype)throw Error(`Invalid data types; op elements ${a}, but list elements ${e.dtype}`);ew(t,e.shape,"TensorList shape mismatch: "),(0,E.keep)(e)}),this.idTensor=(0,E.scalar)(0),this.maxNumElements=n,(0,E.keep)(this.idTensor)}copy(){return new eA([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);ew(e,this.elementShape,"TensorList shape mismatch: ");let n=ev(this.elementShape,this.tensors,e);return(0,E.tidy)(()=>{let e=this.tensors.map(e=>(0,E.reshape)(e,n));return(0,E.stack)(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw Error("Trying to pop from an empty list.");let a=ev(this.elementShape,this.tensors,e),n=this.tensors.pop();return n.kept=!1,ew(n.shape,e,"TensorList shape mismatch: "),(0,E.reshape)(n,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ew(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw Error("Trying to push element into a full list.");(0,E.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new eA([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let a=0;a<Math.min(this.tensors.length,e);++a)t.tensors[a]=this.tensors[a];return t}getItem(e,t,a){if(a!==this.elementDtype)throw Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw Error(`element at index ${e} is null.`);ew(this.tensors[e].shape,t,"TensorList shape mismatch: ");let n=ev(this.elementShape,this.tensors,t);return(0,E.reshape)(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ew(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,E.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ew(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());let n=ev(this.elementShape,this.tensors,a);return 0===e.length?(0,E.tensor)([],[0].concat(n)):(0,E.tidy)(()=>{let t=e.map(e=>(0,E.reshape)(this.tensors[e],n));return(0,E.stack)(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ew(this.elementShape,t,"TensorList shape mismatch: ");let a=ev(this.elementShape,this.tensors,t);return 0===this.size()?(0,E.tensor)([],[0].concat(a)):(0,E.tidy)(()=>{let e=this.tensors.map(e=>(0,E.reshape)(e,a));return(0,E.concat)(e,0)})}}let ek=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{let n=M("thenBranch",e,t,a),r=M("elseBranch",e,t,a),s=M("cond",e,t,a),o=M("args",e,t,a);if((await s.data())[0])return a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap);return a.functionMap[r].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{let n=M("body",e,t,a),r=M("cond",e,t,a),s=M("args",e,t,a),o=await a.functionMap[r].executeFunctionAsync(s,a.tensorArrayMap,a.tensorListMap),i=s.map(e=>e.id),p=await o[0].data();o.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()});let u=s;for(;p[0];){let e=u,t=(u=await a.functionMap[n].executeFunctionAsync(u,a.tensorArrayMap,a.tensorListMap)).map(e=>e.id);e.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});let s=await a.functionMap[r].executeFunctionAsync(u,a.tensorArrayMap,a.tensorListMap);p=await s[0].data(),s.forEach(e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":return[$(M("pred",e,t,a))];case"Switch":{let n=M("pred",e,t,a),r=M("data",e,t,a);return r.kept||(r=$(r)),(await n.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let n=e.inputNames.find(e=>void 0!==V(e,t,a));if(n)return[$(V(n,t,a))];return}case"Enter":{let n=M("frameName",e,t,a),r=M("tensor",e,t,a);return a.enterFrame(n),[$(r)]}case"Exit":{let n=M("tensor",e,t,a);return a.exitFrame(),[$(n)]}case"NextIteration":{let n=M("tensor",e,t,a);return a.nextIteration(),[$(n)]}case"TensorArrayV3":{let n=M("size",e,t,a),r=M("dtype",e,t,a),s=M("elementShape",e,t,a),o=M("dynamicSize",e,t,a),i=M("clearAfterRead",e,t,a),p=M("identicalElementShapes",e,t,a),u=new eD(M("name",e,t,a),r,n,s,p,o,i);return a.addTensorArray(u),[u.idTensor,(0,E.scalar)(1)]}case"TensorArrayWriteV3":{let n=M("tensorArrayId",e,t,a),r=M("index",e,t,a),s=M("tensor",e,t,a),o=a.getTensorArray(n.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{let n=M("tensorArrayId",e,t,a),r=M("index",e,t,a);return[a.getTensorArray(n.id).read(r)]}case"TensorArrayGatherV3":{let n=M("tensorArrayId",e,t,a),r=M("indices",e,t,a),s=M("dtype",e,t,a);return[a.getTensorArray(n.id).gather(r,s)]}case"TensorArrayScatterV3":{let n=M("tensorArrayId",e,t,a),r=M("indices",e,t,a),s=M("tensor",e,t,a),o=a.getTensorArray(n.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{let n=M("tensorArrayId",e,t,a),r=a.getTensorArray(n.id),s=M("dtype",e,t,a);return[r.concat(s)]}case"TensorArraySplitV3":{let n=M("tensorArrayId",e,t,a),r=M("tensor",e,t,a),s=M("lengths",e,t,a),o=a.getTensorArray(n.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{let n=M("tensorArrayId",e,t,a),r=a.getTensorArray(n.id);return[(0,E.scalar)(r.size(),"int32")]}case"TensorArrayCloseV3":{let n=M("tensorArrayId",e,t,a),r=a.getTensorArray(n.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let n=M("tensorListId",e,t,a),r=M("index",e,t,a),s=M("tensor",e,t,a),o=a.getTensorList(n.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{let n=M("tensorListId",e,t,a),r=M("index",e,t,a),s=M("elementShape",e,t,a),o=M("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{let n=M("indices",e,t,a),r=function(e,t,a,n){if(t.length!==e.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(null!=n&&-1!==n&&r>=n)throw Error(`Max index must be < array size (${r}  vs. ${n})`);let s=new eA([],a,e.dtype,n),o=(0,E.unstack)(e,0);return t.forEach((e,t)=>{s.setItem(e,o[t])}),s}(M("tensor",e,t,a),n,M("elementShape",e,t,a),M("numElements",e,t,a));return a.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=M("elementShape",e,t,a),r=M("elementDType",e,t,a),s=M("TensorListReserve"===e.op?"numElements":"maxNumElements",e,t,a),o=new eA([],n,r,"TensorListReserve"===e.op?-1:s);return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{let n=M("tensorListId",e,t,a),r=M("indices",e,t,a),s=M("elementShape",e,t,a),o=M("elementDType",e,t,a);return[a.getTensorList(n.id).gather(r,o,s)]}case"TensorListStack":{let n=M("tensorListId",e,t,a),r=M("elementShape",e,t,a),s=M("elementDType",e,t,a),o=M("numElements",e,t,a);return[a.getTensorList(n.id).stack(r,s,o)]}case"TensorListFromTensor":{let n=function(e,t,a){let n=e.dtype;if(e.shape.length<1)throw Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==a)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);return ew(e.shape.slice(1),t,"TensorList shape mismatch: "),new eA((0,E.unstack)(e),t,n)}(M("tensor",e,t,a),M("elementShape",e,t,a),M("elementDType",e,t,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=M("tensorListId",e,t,a),r=a.getTensorList(n.id),s=M("dtype",e,t,a),o=M("elementShape",e,t,a);return[r.concat(s,o)]}case"TensorListPushBack":{let n=M("tensorListId",e,t,a),r=M("tensor",e,t,a),s=a.getTensorList(n.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let n=M("tensorListId",e,t,a),r=M("elementShape",e,t,a),s=M("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(r,s)]}case"TensorListSplit":{let n=M("tensor",e,t,a),r=M("elementShape",e,t,a),s=function(e,t,a){let n=0,r=t.map(e=>n+=e);if(n!==e.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);let s=eE(e.shape.slice(1),a),o=0===n?0:e.size/n,i=(0,E.tidy)(()=>{let a=[];e=(0,E.reshape)(e,[1,n,o]);for(let n=0;n<t.length;++n){let i=[0,0===n?0:r[n-1],0],p=[1,t[n],o];a[n]=(0,E.reshape)((0,E.slice)(e,i,p),s)}return e.dispose(),a}),p=new eA([],a,e.dtype,t.length);for(let e=0;e<i.length;e++)p.setItem(e,i[e]);return p}(n,M("lengths",e,t,a),r);return a.addTensorList(s),[s.idTensor]}case"TensorListLength":{let n=M("tensorListId",e,t,a),r=a.getTensorList(n.id);return[(0,E.scalar)(r.size(),"int32")]}case"TensorListResize":{let n=M("tensorListId",e,t,a),r=M("size",e,t,a),s=a.getTensorList(n.id).resize(r);return a.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function eM(e,t,a){let[n,r]=M("fusedOps",e,t,a),s="biasadd"===n,o="prelu"===r,i=M("numArgs",e,t,a);if(s){if(o&&2!==i)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==i)throw Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if("fusedbatchnorm"===n)throw Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=M("strides",e,t,a),u=R(e,t,a),m=M("dataFormat",e,t,a).toUpperCase(),l=M("dilations",e,t,a),[d,c]=M("args",e,t,a);return s||(c=d,d=void 0),{stride:p,pad:u,dataFormat:m,dilations:l,biasArg:d,preluArg:c,activationFunc:r,leakyreluAlpha:M("leakyreluAlpha",e,t,a)}}let eV=(e,t,a,n=v)=>{switch(e.op){case"Conv1D":{let r=M("stride",e,t,a),s=M("pad",e,t,a),o=M("dataFormat",e,t,a).toUpperCase(),i=M("dilation",e,t,a);return[n.conv1d(M("x",e,t,a),M("filter",e,t,a),r,s,o,i)]}case"Conv2D":{let r=M("strides",e,t,a),s=R(e,t,a),o=M("dataFormat",e,t,a).toUpperCase(),i=M("dilations",e,t,a);return[n.conv2d(M("x",e,t,a),M("filter",e,t,a),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:p,preluArg:u,activationFunc:m,leakyreluAlpha:l}=eM(e,t,a);return[n.fused.conv2d({x:M("x",e,t,a),filter:M("filter",e,t,a),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:p,activation:m,preluActivationWeights:u,leakyreluAlpha:l})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:p,preluArg:u,activationFunc:m,leakyreluAlpha:l}=eM(e,t,a);return[n.fused.depthwiseConv2d({x:M("x",e,t,a),filter:M("filter",e,t,a),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:p,activation:m,preluActivationWeights:u,leakyreluAlpha:l})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=M("outputShape",e,t,a),s=M("strides",e,t,a),o=R(e,t,a);return[n.conv2dTranspose(M("x",e,t,a),M("filter",e,t,a),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=M("strides",e,t,a),s=R(e,t,a),o=M("dilations",e,t,a),i=M("dataFormat",e,t,a).toUpperCase();return[n.depthwiseConv2d(M("input",e,t,a),M("filter",e,t,a),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("dataFormat",e,t,a).toUpperCase(),i=M("dilations",e,t,a);return[n.conv3d(M("x",e,t,a),M("filter",e,t,a),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("kernelSize",e,t,a);return[n.avgPool(M("x",e,t,a),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("kernelSize",e,t,a);return[n.maxPool(M("x",e,t,a),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("kernelSize",e,t,a),i=M("includeBatchInIndex",e,t,a),{result:p,indexes:u}=n.maxPoolWithArgmax(M("x",e,t,a),[o[1],o[2]],[r[1],r[2]],s,i);return[p,u]}case"AvgPool3D":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("kernelSize",e,t,a);return[n.avgPool3d(M("x",e,t,a),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("kernelSize",e,t,a);return[n.maxPool3d(M("x",e,t,a),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=M("strides",e,t,a),s=M("pad",e,t,a),o=M("dilations",e,t,a),i=r[1],p=r[2],u=o[1],m=o[2];return[n.dilation2d(M("x",e,t,a),M("filter",e,t,a),[i,p],s,[u,m],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eL=(e,t,a,n=v)=>{switch(e.op){case"Fill":{let r=M("shape",e,t,a),s=M("dtype",e,t,a),o=M("value",e,t,a);return[n.fill(r,o,s)]}case"LinSpace":{let r=M("start",e,t,a),s=M("stop",e,t,a),o=M("num",e,t,a);return[n.linspace(r,s,o)]}case"Multinomial":{let r=M("logits",e,t,a),s=M("numSamples",e,t,a),o=M("seed",e,t,a);return[n.multinomial(r,s,o)]}case"OneHot":{let r=M("indices",e,t,a),s=M("depth",e,t,a),o=M("onValue",e,t,a),i=M("offValue",e,t,a),p=M("dtype",e,t,a);return[n.oneHot(r,s,o,i,p)]}case"Ones":return[n.ones(M("shape",e,t,a),M("dtype",e,t,a))];case"OnesLike":return[n.onesLike(M("x",e,t,a))];case"RandomStandardNormal":return[n.randomStandardNormal(M("shape",e,t,a),M("dtype",e,t,a),M("seed",e,t,a))];case"RandomUniform":return[n.randomUniform(M("shape",e,t,a),M("minval",e,t,a),M("maxval",e,t,a),M("dtype",e,t,a))];case"RandomUniformInt":return[n.randomUniformInt(M("shape",e,t,a),M("minval",e,t,a),M("maxval",e,t,a),M("seed",e,t,a))];case"Range":{let r=M("start",e,t,a),s=M("stop",e,t,a),o=M("step",e,t,a);return[n.range(r,s,o,M("dtype",e,t,a))]}case"TruncatedNormal":{let r=M("shape",e,t,a),s=M("mean",e,t,a),o=M("stdDev",e,t,a),i=M("seed",e,t,a);return[n.truncatedNormal(r,s,o,M("dtype",e,t,a),i)]}case"Zeros":return[n.zeros(M("shape",e,t,a),M("dtype",e,t,a))];case"ZerosLike":return[n.zerosLike(M("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function eC(e,t,a){let n=M("boxes",e,t,a),r=M("scores",e,t,a),s=M("maxOutputSize",e,t,a);return{boxes:n,scores:r,maxOutputSize:s,iouThreshold:M("iouThreshold",e,t,a),scoreThreshold:M("scoreThreshold",e,t,a),softNmsSigma:M("softNmsSigma",e,t,a)}}let ez=async(e,t,a,n,r=v)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:p,softNmsSigma:u}=eC(e,t,a),m=await r.image.nonMaxSuppressionWithScoreAsync(n,s,o,i,p,u);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:p}=eC(e,t,a),u=M("padToMaxOutputSize",e,t,a),m=await r.image.nonMaxSuppressionPaddedAsync(n,s,o,i,p,u);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:p}=eC(e,t,a);return[await r.image.nonMaxSuppressionAsync(n,s,o,i,p)]}case"Where":{let n=r.cast(M("condition",e,t,a),"bool"),s=[await r.whereAsync(n)];return n.dispose(),s}case"ListDiff":return r.setdiff1dAsync(M("x",e,t,a),M("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}},eF=(e,t,a,n=v)=>{switch(e.op){case"LowerBound":{let r=M("sortedSequence",e,t,a),s=M("values",e,t,a);return[n.lowerBound(r,s)]}case"TopKV2":{let r=M("x",e,t,a),s=M("k",e,t,a),o=M("sorted",e,t,a),i=n.topk(r,s,o);return[i.values,i.indices]}case"UpperBound":{let r=M("sortedSequence",e,t,a),s=M("values",e,t,a);return[n.upperBound(r,s)]}case"Unique":{let r=M("x",e,t,a),s=n.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=M("x",e,t,a),s=M("axis",e,t,a),o=n.unique(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eR=(e,t,a,n=v)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=M("default",e,t,a);return[V(e.name,t,a)||r];case"Placeholder":return[V(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[$(M("x",e,t,a))];case"IdentityN":return M("x",e,t,a).map(e=>$(e));case"Shape":return[n.tensor1d(M("x",e,t,a).shape,"int32")];case"ShapeN":return M("x",e,t,a).map(e=>n.tensor1d(e.shape));case"Size":return[n.scalar(M("x",e,t,a).size,"int32")];case"Rank":return[n.scalar(M("x",e,t,a).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let s=M("x",e,t,a),o=M("data",e,t,a),i=M("message",e,t,a),p=M("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,p));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}};var e$=a(6070);class eP{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,E.scalar)(0),this.tensorMap=new Map,(0,E.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return e$.i(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),(0,E.tidy)(()=>{let e=(0,E.unstack)(t),n=a.length,r=e.length;E.util.assert(n===r,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${r} elements.`);for(let t=0;t<n;t++){let n=a[t],r=e[t];(0,E.keep)(r),this.tensorMap.set(n,r)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return(0,E.tidy)(()=>{let e=[];for(let n=0;n<a.length;n++){let r=a[n],s=this.findWithDefault(r,t);e.push(s)}return(0,E.stack)(e)})}findWithDefault(e,t){let a=this.tensorMap.get(e);return null!=a?a:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}let eB=async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=n.getHashTableHandleByName(e.name);if(null!=r)return[r];{let r=new eP(M("keyDType",e,t,a),M("valueDType",e,t,a));return n.addHashTable(e.name,r),[r.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=M("tableHandle",e,t,a,n),s=M("keys",e,t,a),o=M("values",e,t,a),i=n.getHashTableById(r.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{let r=M("tableHandle",e,t,a,n),s=M("keys",e,t,a),o=M("defaultValue",e,t,a),i=n.getHashTableById(r.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=M("tableHandle",e,t,a,n);return[n.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},ej=(e,t,a,n=v)=>{switch(e.op){case"ResizeBilinear":{let r=M("images",e,t,a),s=M("size",e,t,a),o=M("alignCorners",e,t,a),i=M("halfPixelCenters",e,t,a);return[n.image.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{let r=M("images",e,t,a),s=M("size",e,t,a),o=M("alignCorners",e,t,a),i=M("halfPixelCenters",e,t,a);return[n.image.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{let r=M("image",e,t,a),s=M("boxes",e,t,a),o=M("boxInd",e,t,a),i=M("cropSize",e,t,a),p=M("method",e,t,a),u=M("extrapolationValue",e,t,a);return[n.image.cropAndResize(r,s,o,i,p,u)]}case"ImageProjectiveTransformV3":{let r=M("images",e,t,a),s=M("transforms",e,t,a),o=M("outputShape",e,t,a),i=M("fillValue",e,t,a),p=M("interpolation",e,t,a),u=M("fillMode",e,t,a);return[n.image.transform(r,s,p.toLowerCase(),u.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eU=(e,t,a,n=v)=>{switch(e.op){case"Equal":return[n.equal(M("a",e,t,a),M("b",e,t,a))];case"NotEqual":return[n.notEqual(M("a",e,t,a),M("b",e,t,a))];case"Greater":return[n.greater(M("a",e,t,a),M("b",e,t,a))];case"GreaterEqual":return[n.greaterEqual(M("a",e,t,a),M("b",e,t,a))];case"Less":return[n.less(M("a",e,t,a),M("b",e,t,a))];case"LessEqual":return[n.lessEqual(M("a",e,t,a),M("b",e,t,a))];case"LogicalAnd":return[n.logicalAnd(M("a",e,t,a),M("b",e,t,a))];case"LogicalNot":return[n.logicalNot(M("a",e,t,a))];case"LogicalOr":return[n.logicalOr(M("a",e,t,a),M("b",e,t,a))];case"Select":case"SelectV2":return[n.where(M("condition",e,t,a),M("a",e,t,a),M("b",e,t,a))];case"BitwiseAnd":return[n.bitwiseAnd(M("a",e,t,a),M("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eq=(e,t,a,n=v)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(M("a",e,t,a),M("b",e,t,a),M("transposeA",e,t,a),M("transposeB",e,t,a))];case"Einsum":return[n.einsum(M("equation",e,t,a),...M("tensors",e,t,a))];case"Transpose":return[n.transpose(M("x",e,t,a),M("perm",e,t,a))];case"_FusedMatMul":let[r,s]=M("fusedOps",e,t,a),o="prelu"===s,i=M("numArgs",e,t,a),p=M("leakyreluAlpha",e,t,a);if("biasadd"===r){if(o&&2!==i)throw Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,m]=M("args",e,t,a);return[n.fused.matMul({a:M("a",e,t,a),b:M("b",e,t,a),transposeA:M("transposeA",e,t,a),transposeB:M("transposeB",e,t,a),bias:u,activation:s,preluActivationWeights:m,leakyreluAlpha:p})];case"MatrixBandPart":return[n.linalg.bandPart(M("a",e,t,a),M("numLower",e,t,a),M("numUpper",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eH=(e,t,a,n=v)=>{switch(e.op){case"EuclideanNorm":return[n.euclideanNorm(M("x",e,t,a),M("axis",e,t,a),M("keepDims",e,t,a))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[n.batchNorm(M("x",e,t,a),M("mean",e,t,a),M("variance",e,t,a),M("offset",e,t,a),M("scale",e,t,a),M("epsilon",e,t,a))];case"LRN":return[n.localResponseNormalization(M("x",e,t,a),M("radius",e,t,a),M("bias",e,t,a),M("alpha",e,t,a),M("beta",e,t,a))];case"Softmax":return[n.softmax(M("x",e,t,a))];case"LogSoftmax":return[n.logSoftmax(M("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eW=(e,t,a,n=v)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=n.raggedGather(M("paramsNestedSplits",e,t,a),M("paramsDenseValues",e,t,a),M("indices",e,t,a),M("outputRaggedRank",e,t,a));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=n.raggedRange(M("starts",e,t,a),M("limits",e,t,a),M("splits",e,t,a));return[r,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(M("shape",e,t,a),M("values",e,t,a),M("defaultValue",e,t,a),M("rowPartitionTensors",e,t,a),M("rowPartitionTypes",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eG=(e,t,a,n=v)=>{switch(e.op){case"Max":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.max(M("x",e,t,a),r,s)]}case"Mean":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.mean(M("x",e,t,a),r,s)]}case"Min":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.min(M("x",e,t,a),r,s)]}case"Sum":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.sum(M("x",e,t,a),r,s)]}case"All":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.all(M("x",e,t,a),r,s)]}case"Any":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.any(M("x",e,t,a),r,s)]}case"ArgMax":{let r=M("axis",e,t,a);return[n.argMax(M("x",e,t,a),r)]}case"ArgMin":{let r=M("axis",e,t,a);return[n.argMin(M("x",e,t,a),r)]}case"Prod":{let r=M("axis",e,t,a),s=M("keepDims",e,t,a);return[n.prod(M("x",e,t,a),r,s)]}case"Cumprod":{let r=M("axis",e,t,a),s=M("exclusive",e,t,a),o=M("reverse",e,t,a);return[n.cumprod(M("x",e,t,a),r,s,o)]}case"Cumsum":{let r=M("axis",e,t,a),s=M("exclusive",e,t,a),o=M("reverse",e,t,a);return[n.cumsum(M("x",e,t,a),r,s,o)]}case"Bincount":let r=M("x",e,t,a),s=M("weights",e,t,a),o=M("size",e,t,a);return[n.bincount(r,s,o)];case"DenseBincount":{let r=M("x",e,t,a),s=M("weights",e,t,a),o=M("size",e,t,a),i=M("binaryOutput",e,t,a);return[n.denseBincount(r,s,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eQ=(e,t,a,n=v)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=M("n",e,t,a),s=M("axis",e,t,a),o=M("tensors",e,t,a);return o=o.slice(0,r),[n.concat(o,s)]}case"Gather":{let r=M("x",e,t,a),s=M("indices",e,t,a);return[n.gather(r,n.cast(s,"int32"),0)]}case"GatherV2":{let r=M("axis",e,t,a),s=M("batchDims",e,t,a),o=M("x",e,t,a),i=M("indices",e,t,a);return[n.gather(o,n.cast(i,"int32"),r,s)]}case"Reverse":{let r=M("dims",e,t,a),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);let o=M("x",e,t,a);return[n.reverse(o,s)]}case"ReverseV2":{let r=M("axis",e,t,a),s=M("x",e,t,a);return[n.reverse(s,r)]}case"Slice":{let r=M("begin",e,t,a),s=M("size",e,t,a);return[n.slice(M("x",e,t,a),r,s)]}case"StridedSlice":{let r=M("begin",e,t,a),s=M("end",e,t,a),o=M("strides",e,t,a),i=M("beginMask",e,t,a),p=M("endMask",e,t,a),u=M("ellipsisMask",e,t,a),m=M("newAxisMask",e,t,a),l=M("shrinkAxisMask",e,t,a),d=M("x",e,t,a);return[n.stridedSlice(d,r,s,o,i,p,u,m,l)]}case"Pack":return(0,E.tidy)(()=>{let r=M("axis",e,t,a),s=M("tensors",e,t,a),o=s[0].shape,i=n.squeeze(s[0]).shape,p=s.map(e=>{let t=E.util.arraysEqual(e.shape,o);if(!t&&!E.util.arraysEqual(n.squeeze(e).shape,i))throw Error("the input tensors shape does not match");return t?e:n.reshape(e,o)});return[n.stack(p,r)]});case"Unpack":{let r=M("axis",e,t,a),s=M("tensor",e,t,a);return n.unstack(s,r)}case"Tile":{let r=M("reps",e,t,a);return[n.tile(M("x",e,t,a),r)]}case"Split":case"SplitV":{let r=M("axis",e,t,a),s=M("numOrSizeSplits",e,t,a),o=M("x",e,t,a);return n.split(o,s,r)}case"ScatterNd":{let r=M("indices",e,t,a),s=M("values",e,t,a),o=M("shape",e,t,a);return[n.scatterND(r,s,o)]}case"GatherNd":{let r=M("x",e,t,a),s=M("indices",e,t,a);return[n.gatherND(r,s)]}case"SparseToDense":{let r=M("sparseIndices",e,t,a),s=M("outputShape",e,t,a),o=M("sparseValues",e,t,a),i=M("defaultValue",e,t,a);return[n.sparseToDense(r,o,s,o.dtype===i.dtype?i:n.cast(i,o.dtype))]}case"TensorScatterUpdate":{let r=M("indices",e,t,a),s=M("values",e,t,a),o=M("tensor",e,t,a);return[n.tensorScatterUpdate(o,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eK=(e,t,a,n=v)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=n.sparse.sparseFillEmptyRows(M("indices",e,t,a),M("values",e,t,a),M("denseShape",e,t,a),M("defaultValue",e,t,a));return[r,s,o,i]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=n.sparse.sparseReshape(M("inputIndices",e,t,a),M("inputShape",e,t,a),M("newShape",e,t,a));return[r,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(M("data",e,t,a),M("indices",e,t,a),M("segmentIds",e,t,a))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(M("data",e,t,a),M("indices",e,t,a),M("segmentIds",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eX=(e,t,a,n=v)=>{switch(e.op){case"FFT":return[n.fft(M("x",e,t,a))];case"IFFT":return[n.ifft(M("x",e,t,a))];case"RFFT":return[n.rfft(M("x",e,t,a))];case"IRFFT":return[n.irfft(M("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eJ=(e,t,a,n=v)=>{switch(e.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(M("input",e,t,a),M("pattern",e,t,a),M("rewrite",e,t,a),M("replaceGlobal",e,t,a))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=n.string.stringNGrams(M("data",e,t,a),M("dataSplits",e,t,a),M("separator",e,t,a),M("nGramWidths",e,t,a),M("leftPad",e,t,a),M("rightPad",e,t,a),M("padWidth",e,t,a),M("preserveShortSequences",e,t,a));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:o}=n.string.stringSplit(M("input",e,t,a),M("delimiter",e,t,a),M("skipEmpty",e,t,a));return[r,s,o]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(M("input",e,t,a),M("numBuckets",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eY=(e,t,a,n=v)=>{switch(e.op){case"Cast":return[n.cast(M("x",e,t,a),M("dtype",e,t,a))];case"ExpandDims":{let r=M("axis",e,t,a);return[n.expandDims(M("x",e,t,a),r)]}case"Squeeze":{let r=M("axis",e,t,a);return[n.squeeze(M("x",e,t,a),r)]}case"Reshape":return[n.reshape(M("x",e,t,a),M("shape",e,t,a))];case"EnsureShape":return[n.ensureShape(M("x",e,t,a),M("shape",e,t,a))];case"MirrorPad":return[n.mirrorPad(M("x",e,t,a),M("padding",e,t,a),M("mode",e,t,a))];case"PadV2":case"Pad":return[n.pad(M("x",e,t,a),M("padding",e,t,a),M("constantValue",e,t,a))];case"SpaceToBatchND":{let r=M("blockShape",e,t,a),s=M("paddings",e,t,a);return[n.spaceToBatchND(M("x",e,t,a),r,s)]}case"BatchToSpaceND":{let r=M("blockShape",e,t,a),s=M("crops",e,t,a);return[n.batchToSpaceND(M("x",e,t,a),r,s)]}case"DepthToSpace":{let r=M("blockSize",e,t,a),s=M("dataFormat",e,t,a).toUpperCase();return[n.depthToSpace(M("x",e,t,a),r,s)]}case"BroadcastTo":return[n.broadcastTo(M("x",e,t,a),M("shape",e,t,a))];case"BroadcastArgs":return[n.broadcastArgs(M("s0",e,t,a),M("s1",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function eZ(e,t,a,n,r=E.tidy){let s=((e,t,a)=>{switch(e.category){case"arithmetic":return r(()=>e_(e,t,a));case"basic_math":return r(()=>eO(e,t,a));case"control":return ek(e,t,a);case"convolution":return r(()=>eV(e,t,a));case"creation":return r(()=>eL(e,t,a));case"dynamic":return ez(e,t,a);case"evaluation":return r(()=>eF(e,t,a));case"image":return r(()=>ej(e,t,a));case"graph":return r(()=>eR(e,t,a));case"logical":return r(()=>eU(e,t,a));case"matrices":return r(()=>eq(e,t,a));case"normalization":return r(()=>eH(e,t,a));case"ragged":return r(()=>eW(e,t,a));case"reduction":return r(()=>eG(e,t,a));case"slice_join":return r(()=>eQ(e,t,a));case"sparse":return r(()=>eK(e,t,a));case"spectral":return r(()=>eX(e,t,a));case"string":return r(()=>eJ(e,t,a));case"transformation":return r(()=>eY(e,t,a));case"hash_table":return eB(e,t,a,n);case"custom":let s=D[e.op];if(s&&s.customExecutor)return s.customExecutor(new ex(e,t,a));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,a);return E.util.isPromise(s)?s.then(e=>[].concat(e)):[].concat(s)}class e0{constructor(e={},t={},a={},n={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function e1(e,t,a,n){let r=new Set,s=[],o=null,i=null,p=new Set,u=new Set(Object.keys(e).map(e=>F(e)[0])),m=new Set((n=n||[]).map(e=>F(e.name)[0])),l=[...t];for(;l.length>0;){let e=l.pop();if((e8(e)||e6.has(e.op)||e4.has(e.op))&&null==o&&(i=(o=e).children.map(e=>e.name).filter(e=>r.has(e))),r.add(e.name),!(null!=a[e.name]||u.has(e.name)||m.has(e.name))){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach(e=>{p.has(e.name)||(p.add(e.name),l.push(e))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:i}}class e2 extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}let e3=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),e6=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),e4=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function e8(e){return e3.has(e.op)}class e5{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new e5(e.functions[t],this)})}getCompilationKey(e,t){let a=e.map(e=>e.name).sort(),n=t.map(e=>e.name).sort();return a.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(e,t){let a=e1(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:r,syncInputs:s}=a;if(null!=r)throw Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(n.length>0){let a=t.map(e=>e.name),r=Object.keys(e);throw Error(`Cannot compute the outputs [${a}] from the provided inputs [${r}]. Missing the following inputs: [${n}]`)}let o=function(e,t){let{usedNodes:a,inputs:n}=t,r=Object.keys(n).map(e=>F(e)[0]).map(t=>e.nodes[t]),s=e.initNodes||[],o=e=>a.has("string"==typeof e?e:e.name);function i(e){return[...new Map(e.map(e=>[e.name,e])).values()]}let p=i([...r,...e.weights,...s]).filter(o),u=i([...p,...Object.values(e.nodes)]).filter(o),m=new Map(u.map(e=>[e.name,e])),l={};for(let e of u)for(let t of(l[e.name]=l[e.name]||0,e.children))o(t)||(l[t.name]=Number.POSITIVE_INFINITY),l[t.name]=(l[t.name]||0)+1;let d=Object.entries(l).filter(([,e])=>0===e).map(([e])=>e),c=[...d];for(;d.length>0;){let e=d.pop();for(let t of m.get(e).children.filter(o))0==--l[t.name]&&(c.push(t.name),d.push(t.name))}let y=function(e,t){let a=new Map(e.map(e=>[e.name,e])),n=t.map(e=>e.name),r=new Set(n);for(;n.length>0;){let e=n.pop();for(let t of a.get(e).children)!a.has(t.name)||r.has(t.name)||(r.add(t.name),n.push(t.name))}return e.filter(e=>r.has(e.name))}(c.map(e=>m.get(e)),p);return function(e,t){let a=new Map(e.map((e,t)=>[e.name,t])),n=new Set(t.map(e=>e.name)),r=e=>n.has("string"==typeof e?e:e.name),s=new Set(e.map(e=>e.name)),o=e=>s.has("string"==typeof e?e:e.name);for(let t of e){for(let e of t.children.filter(o)){if(!a.has(e.name))throw new e2(`Child ${e.name} of node ${t.name} is unreachable.`);if(a.get(t.name)>a.get(e.name))throw new e2(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!r(t))for(let e of t.inputs){if(!a.has(e.name))throw new e2(`Input ${e.name} of node ${t.name} is unreachable.`);if(a.get(e.name)>a.get(t.name))throw new e2(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(y,p),y}(this.graph,a),i=function(e){let t=new Map(e.map((e,t)=>[e.name,t])),a=Number.MAX_SAFE_INTEGER,n=e.map((e,t)=>e8(e)?a:t),r=e=>{let a=n[t.get(e.name)];return null==a?-1:a},s=e.map((e,t)=>e.children.map(r).reduce((e,t)=>Math.max(e,t),n[t])),o=new Map;for(let t=0;t<e.length;++t){let n=s[t];if(n===a)continue;let r=e[t],i=e[n];o.has(i.name)||o.set(i.name,[]),o.get(i.name).push(r)}return o}(o);return{orderedNodes:o,nodeLiveUntilMap:i}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return(0,E.keep)(t),t}cloneTensorList(e){return e?e.map(e=>this.cloneAndKeepTensor(e)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors();let a=Object.keys(e=this.mapInputs(e)).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let n=a.map(e=>this.graph.nodes[F(e)[0]]),r=t.map(e=>F(e)[0]),s=new Set(r),o=r.map(e=>this.graph.nodes[e]);0===o.length&&(o=this._outputs);let i=this.getCompilationKey(n,o),p=this.compiledMap.get(i);null==p&&(p=this.compile(e,o),this.compiledMap.set(i,p));try{this.keepIntermediateTensors=(0,E.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let u={},m={};return(0,E.tidy)(()=>{let a=new e0(this.weightMap,u,m,this.functionExecutorMap,this.parseNodeNameCache),n=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{let[r,s]=F(t,a),o=[];o[s]=e[t],n[r]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[r]=this.cloneTensorList(o))});let r=this.getFrozenTensorIds(n),{orderedNodes:o,nodeLiveUntilMap:i}=p;for(let e of o){if(n[e.name])continue;let t=eZ(e,n,a,this._resourceManager);if(E.util.isPromise(t))throw Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);n[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,n,a,r,s,i.get(e.name))}return null==this.parent&&a.dispose(r),t.map(e=>V(e,n,a))})}getFrozenTensorIds(e){return new Set([].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id))))}checkTensorForDisposal(e,t,a,n,r,s,o){if(!(e8(t)||s.has(e))){for(let n of a[e])null!=n&&(o[n.id]=(o[n.id]||0)+t.children.length);for(let e of t.inputs){if(e8(e))continue;let t=L(e.name,a,n);if(null!=t)for(let e of t){if(!e||e.kept||r.has(e.id))continue;let t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,a,n,r,s){if(!e8(e)&&null!=s){for(let e of s)if(!(e8(e)||r.has(e.name)))for(let r of L(e.name,t,a))!r||r.kept||n.has(r.id)||r.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,a=!1,n={},r={}){this.disposeIntermediateTensors(),a||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,E.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let s=new e0(this.weightMap,n,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,s,t,a),i=t.map(e=>V(e,o,s)),p=new Set([...i.map(e=>e.id),...Object.keys(e).map(t=>e[t].id),...this.weightIds]);return Object.values(o).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||p.has(e.id)||e.dispose()})}),null==this.parent&&s.dispose(p),i}async executeFunctionAsync(e,t,a){let n=e.reduce((e,t,a)=>(e[this.inputs[a].name]=t,e),{});return this._executeAsync(n,this.outputNodes,!0,t,a)}async executeWithControlFlow(e,t,a,n){let r=Object.keys(e),s=r.map(e=>this.graph.nodes[F(e)[0]]),o=a.map(e=>F(e)[0]),i=new Set(o),p=o.map(e=>this.graph.nodes[e]);0===p.length&&(p=this._outputs);let{usedNodes:u,missingInputs:m,dynamicNode:l,syncInputs:d}=e1(e,p,this.weightMap,this._initNodes),c=[...s,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),y=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{let[a,n]=F(t),r=[];r[n]=e[t],y[a]=r});let h={},f=this.getFrozenTensorIds(y),g={};for(;c.length>0;){let e=this.processStack(s,c,t,y,g,f,i,h,u);await Promise.all(e)}null!=l||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let N=p.filter(e=>!e8(e)&&!V(e.name,y,t)).map(e=>e.name);if(N.length>0){let e="";throw null!=l&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),Error(`Cannot compute the outputs [${N}] from the provided inputs [${r}]. Consider providing the following inputs: [${m}]. ${e}`)}return y}processStack(e,t,a,n,r,s,o,i,p){let u=[];for(;t.length>0;){let e=t.pop();a.currentContext=e.contexts;let m="";if("Enter"===e.node.op&&M("isConstant",e.node,n,a)&&([m]=C(e.node.name,a)),null==n[e.node.name]){let l=eZ(e.node,n,a,this._resourceManager);m||([m]=C(e.node.name,a));let d=a.currentContext;E.util.isPromise(l)?u.push(l.then(u=>(n[m]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(u)),a.currentContext=d,this.checkTensorForDisposal(m,e.node,n,a,s,o,i),this.processChildNodes(e.node,t,a,n,r,p),u))):(n[m]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(l)),this.checkTensorForDisposal(m,e.node,n,a,s,o,i),this.processChildNodes(e.node,t,a,n,r,p))}else this.processChildNodes(e.node,t,a,n,r,p)}return u}processChildNodes(e,t,a,n,r,s){e.children.forEach(e=>{let[o]=C(e.name,a);!r[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!V(e,n,a))&&(r[o]=!0,t.push({contexts:a.currentContext,node:e})):e.inputNames.every(e=>!!V(e,n,a))&&(r[o]=!0,t.push({contexts:a.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let a=e[t],[n]=F(t),r=this.graph.nodes[n];if(r.attrParams.shape&&r.attrParams.shape.value){let e=r.attrParams.shape.value,t=e.length===a.shape.length&&a.shape.every((t,a)=>-1===e[a]||e[a]===t);E.util.assert(t,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${e}], but was [${a.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&E.util.assert(a.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(e){var t,a;let n={};for(let r in e){let s=null===(a=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===a?void 0:a[r];null!=s?n[s.name]=e[r]:n[r]=e[r]}return n}checkInputs(e){let t=Object.keys(e).filter(e=>{let[t]=F(e);return null==this.graph.nodes[t]});if(t.length>0)throw Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,a;let n=null===(a=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===a?void 0:a[e];return null!=n?n.name:e},{})}checkOutputs(e){e.forEach(e=>{let[t]=F(e);if(!this.graph.nodes[t])throw Error(`The output '${e}' is not found in the graph`)})}}class e7{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var e9=a(3850);class te{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},a=E.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=a,null==t&&(this.loadOptions={}),this.resourceManager=new e7}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return E.util.isPromise(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw Error("Model artifacts missing streamWeights function");let t=await (0,e9.r)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let a=this.artifacts.modelTopology,n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=n,this.version=`${a.versions.producer}.${a.versions.minConsumer}`,this.executor=new e5(eo.Instance.transformGraph(a,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=eo.Instance.transformGraph(e.modelInitializer);this.initializer=new e5(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof E.Tensor?[e]:e,a={};return t.forEach((e,t)=>a[this.structuredOutputKeys[t]]=e),a}return e}predict(e,t){let a=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(a)}async predictAsync(e,t){let a=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(a)}normalizeInputs(e){var t;if(!(e instanceof E.Tensor)&&!Array.isArray(e)){let a=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=a)for(let t in a){let n=a[t];null!=n.resourceId&&(e[t]=this.resourceIdToCapturedInput[n.resourceId])}return e}e=Array.isArray(e)?e:[e];let a=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+a!==this.inputNodes.length)throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-a} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((t,a)=>{var r,s,o;let i=null===(o=null===(s=null===(r=this.signature)||void 0===r?void 0:r.inputs)||void 0===s?void 0:s[a])||void 0===o?void 0:o.resourceId;return null!=i?t[a]=this.resourceIdToCapturedInput[i]:t[a]=e[n++],t},{})}normalizeOutputs(e){return Array.isArray(e=e||this.outputNodes)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,a=Object.keys(t);for(let n=0;n<a.length;n++){let r=t[a[n]];this.resourceIdToCapturedInput[r.resourceId]=e[n]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,a)=>(t[a]=[e[a]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,E.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function tt(e,t={},a=E.io){var n;if(null==e)throw Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&((n=e).endsWith("/")||(n+="/"),e=`${n}model.json?tfjs-format=file`);let r=new te(e,t,a);return await r.load(),r}function ta(e){let t;if(null==e)throw Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");if(e instanceof Array){let[a,n]=e;if(!a)throw Error("modelJSON must be the first element of the array");if(!n||!(n instanceof ArrayBuffer))throw Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw Error("Model JSON is missing 'weightsManifest'");let r=E.io.getWeightSpecs(a.weightsManifest),s=E.io.getModelArtifactsForJSONSync(a,r,n);t=E.io.fromMemorySync(s)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=E.io.fromMemorySync(e);else throw Error("Unknown model format");let a=new te(t);return a.load(),a}let tn="4.22.0"}}]);