(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[94],{2975:function(e,t,n){"use strict";n.d(t,{JL:function(){return r},Zu:function(){return i}});class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class i{refCount(e){return o("refCount")}incRef(e){return o("incRef")}timerAvailable(){return!0}time(e){return o("time")}read(e){return o("read")}readSync(e){return o("readSync")}readToGPU(e,t){return o("readToGPU")}numDataIds(){return o("numDataIds")}disposeData(e,t){return o("disposeData")}write(e,t,n){return o("write")}move(e,t,n,r,i){return o("move")}createTensorFromGPUData(e,t,n){return o("createTensorFromGPUData")}memory(){return o("memory")}floatPrecision(){return o("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return o("dispose")}}function o(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},3021:function(e,t,n){"use strict";function r(e,t){return e>t?1:e<t?-1:0}function i(e,t,n,r,i){return u(e,t,n,r,i,0)}function o(e,t,n,r,i,o){return u(e,t,n,r,i,0,!1,o,!0)}function a(e,t,n,r,i,o){return u(e,t,n,r,i,o,!0)}function u(e,t,n,i,o,a,u=!1,l=!1,c=!1){let h=[];for(let e=0;e<t.length;e++)t[e]>o&&h.push({score:t[e],boxIndex:e,suppressBeginIndex:0});h.sort(s);let f=a>0?-.5/a:0,d=[],p=[];for(;d.length<n&&h.length>0;){let t=h.pop(),{score:n,boxIndex:a,suppressBeginIndex:u}=t;if(n<o)break;let l=!1;for(let n=d.length-1;n>=u;--n){let r=function(e,t,n){let r=e.subarray(4*t,4*t+4),i=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),s=Math.max(r[1],r[3]),l=Math.min(i[0],i[2]),c=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),d=(u-o)*(s-a),p=(h-l)*(f-c);if(d<=0||p<=0)return 0;let g=Math.max(Math.min(u,h)-Math.max(o,l),0)*Math.max(Math.min(s,f)-Math.max(a,c),0);return g/(d+p-g)}(e,a,d[n]);if(r>=i){l=!0;break}if(t.score=t.score*function(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}(i,f,r),t.score<=o)break}t.suppressBeginIndex=d.length,!l&&(t.score===n?(d.push(a),p.push(t.score)):t.score>o&&function(e,t,n){let i=function(e,t,n){let r=0,i=e.length,o=0,a=!1;for(;r<i;){let u=n(t,e[o=r+(i-r>>>1)]);u>0?r=o+1:(i=o,a=!u)}return a?r:-r-1}(e,t,n||r);e.splice(i<0?-(i+1):i,0,t)}(h,t,s))}let g=d.length,m=n-g;l&&m>0&&(d.push(...Array(m).fill(0)),p.push(...Array(m).fill(0)));let b={selectedIndices:d};return u&&(b.selectedScores=p),c&&(b.validOutputs=g),b}function s(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,{GP:function(){return i},qP:function(){return o},pA:function(){return a}})},9846:function(e,t,n){"use strict";n.d(t,{Z:function(){return i}});var r=n(5515);function i(e,t){let n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);let i=(0,r.f)(e,"int32"),o=(0,r.f)([n.length,e.length],"int32");for(let t=0;t<n.length;t++){let r=i.indexToLoc(n[t]),a=t*e.length;o.values.set(r,a)}return o.toTensor()}},9681:function(e,t,n){"use strict";n.d(t,{BV:function(){return w},wv:function(){return y}});var r=n(2975),i=n(6472),o=n(5490),a=n(5047),u=n(9922),s=n(7177),l=n(2904),c=n(2771);class h{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new f)}profileKernel(e,t,n){let r,o;let a=()=>{r=n()},u=l.now();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{for(let e of(a(),r))e.dataSync();o=Promise.resolve({kernelMs:l.now()-u})}if((0,i.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){let n=r[t];n.data().then(t=>{!function(e,t,n){if("float32"===t)for(let t=0;t<e.length;t++){let r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}}(t,n.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(e=>e.kernelMs),extraInfo:o.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:i,extraInfo:o}=e;n.forEach(e=>{Promise.all([e.data(),r,o]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],i,n[2])})})}}class f{logKernelProfile(e,t,n,r,i,o){let a="number"==typeof r?c.oj(`${r}ms`,9):r.error,u=c.oj(e,25),s=t.rank,l=t.size,h=c.oj(t.shape.toString(),14),f="";for(let e in i){let n=i[e];if(null!=n){let r=n.shape||t.shape,i=r.length;f+=`${e}: ${i}D ${i>0?r:""} `}}console.log(`%c${u}	%c${a}	%c${s}D ${h}	%c${l}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var d=n(6150),p=n(5420);function g(e){return null!=e.kernelName}class m{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}}class b{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new m}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(s.Z(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new h(this.backendInstance),!0}setupRegisteredKernels(){(0,u.tr)(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){(0,u.tr)(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof r.Zu||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>!(t<this.pendingBackendInitId)&&(this.pendingBackendInit=null,s.Z(`Initialization of backend ${e} failed`),s.Z(n.stack||n.message),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return s.Z(`Initialization of backend ${e} failed`),s.Z(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,i,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>((n=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return b.nextTensorId++}nextVariableId(){return b.nextVariableId++}clone(e){let t=w.runKernel(a.iJz,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>w.runKernel(a.RFZ,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,!(null!=(0,u.pI)(e,this.backendName)))throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),i=0;n.forEach(e=>{i+="complex64"===e.dtype?3:1});let o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-o;if(a>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r,i;let o=[],a=this.isTapeOn(),s=this.state.numBytes,l=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let h=g(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(e)){let{kernelName:t,inputs:i,attrs:s}=e;null==this.backendName&&this.backend;let l=(0,u.pI)(t,this.backendName);c.hu(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),n=()=>{let e=this.backend.numDataIds(),n=Array.isArray(r=l.kernelFunc({inputs:i,attrs:s,backend:this.backend}))?r:[r];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(a){let e=this.getTensorsForGradient(t,i,u);o=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,i=e=>{a&&(o=e.map(e=>this.keep(this.clone(e))))};n=()=>{let e=this.backend.numDataIds(),n=Array.isArray(r=this.tidy(()=>t(this.backend,i)))?r:[r];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(h,e,n),n}}let{inputs:f,attrs:d}=e,p=g(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(i=this.profiler.profileKernel(h,f,()=>n()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(i),t=i.outputs):t=n()}),a&&this.addTapeNode(h,f,t,p,o,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:h,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-l,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(e=>null!=f[e]?f[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:i.timeMs,extraInfo:i.extraInfo}),Array.isArray(r)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){let r=(0,u.uk)(e);if(null!=r){let e;let i=r.inputsToSave||[],o=r.outputsToSave||[];r.saveAllInputs?(c.hu(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=i.map(e=>t[e]);let a=n.filter((e,t)=>o[t]);return e.concat(a)}return[]}makeTensor(e,t,n,r){if(null==e)throw Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let i=e;"string"===n&&c.HD(e[0])&&(i=e.map(e=>l.encodeString(e)));let o=r.write(i,t,n),a=new d.es(t,n,o,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){let e=this.state.tensorInfo.get(o),t=(0,c.Ub)(i);this.state.numBytes+=t-e.bytes,e.bytes=t}return a}makeTensorFromDataId(e,t,n,r){let i={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:i}=e,o=new d.es(r,i,n,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let i=new d._w(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*c.bT(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof d._w||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*c.bT(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;for(let r of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n,this.state.activeProfile.kernels))r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,i,o){let a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:i},s=(0,u.uk)(e);null!=s&&(r=s.gradFunc),null!=r&&(a.gradient=e=>(e=e.map((e,t)=>{if(null==e){let e=n[t],r=c.wT(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=(0,p.getTensorsInContainer)(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(c.hu(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));c.hu(i instanceof d.es,()=>"The result y returned by f() must be a tensor.");let o=function(e,t,n){let r={},i={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){let o=e[n],a=o.inputs;for(let e in a){let n=a[e],u=!1;for(let e=0;e<t.length;e++)if(r[n.id]){o.outputs.forEach(e=>r[e.id]=!0),u=!0,i[o.id]=!0;break}if(u)break}}let o={};o[n.id]=!0;let a={};for(let t=e.length-1;t>=0;t--){let n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(o[n.outputs[e].id]){for(let e in r)o[r[e].id]=!0,a[n.id]=!0;break}}let u=[];for(let t=0;t<e.length;t++){let n=e[t];if(i[n.id]&&a[n.id]){let e={};for(let t in n.inputs){let i=n.inputs[t];r[i.id]&&(e[t]=i)}let t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,u.push(t)}}return u}(this.state.activeTape,t,i);if(!r&&0===o.length&&t.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let e={};e[i.id]=null==n?function(e){let t=(0,c.p8)((0,c.NA)(e),"float32");return w.makeTensor(t,e,"float32")}(i.shape):n,function(e,t,n,r){for(let i=t.length-1;i>=0;i--){let o=t[i],a=[];if(o.outputs.forEach(t=>{let n=e[t.id];null!=n?a.push(n):a.push(null)}),null==o.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);let u=o.gradient(a);for(let t in o.inputs){if(!(t in u))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(u)}.`);let i=n(()=>u[t]());if("float32"!==i.dtype)throw Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${i.dtype}'`);let a=o.inputs[t];if(!c.cO(i.shape,a.shape))throw Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${t}' has shape '${i.shape}', which does not match the shape of the input '${a.shape}'`);if(null==e[a.id])e[a.id]=i;else{let t=e[a.id];e[a.id]=r(t,i),t.dispose()}}}}(e,o,e=>this.tidy(e),v);let r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:i,grads:r}})}customGrad(e){return c.hu(c.mf(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;c.hu(t.every(e=>e instanceof d.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,i)=>(n=e(...t,i),c.hu(n.value instanceof d.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),c.hu(c.mf(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{let i=n.gradFunc(e,r),o=Array.isArray(i)?i:[i];c.hu(o.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),c.hu(o.every(e=>e instanceof d.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let a={};return o.forEach((e,t)=>{a[t]=()=>e}),a},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=(0,l.now)(),n=await this.backend.time(e);return n.wallMs=(0,l.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new m,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function y(){let e=(0,o.D)();if(null==e._tfengine){let t=new i.qA(e);e._tfengine=new b(t)}return(0,i.iG)(e._tfengine.ENV),(0,d.Vi)(()=>e._tfengine),e._tfengine}b.nextTensorId=0,b.nextVariableId=0;let w=y();function v(e,t){return w.runKernel(a.mm_,{a:e,b:t})}},6472:function(e,t,n){"use strict";n.d(t,{OB:function(){return u},Vi:function(){return s},iG:function(){return l},qA:function(){return o}});var r=n(2771);let i="tfjsflags";class o{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=a,this.populateURLFlags()}setPlatform(e,t){null==this.platform||s.getBool("IS_TEST")||s.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];s.getBool("IS_TEST")||s.getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if((0,r.tI)(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);i in e&&e[i].split(",").forEach(e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:`${+n}`===n?+n:t}(0,n)})}}function a(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>{var r,i;return r=n[0],i=n[1],t[decodeURIComponent(r)]=decodeURIComponent(i||""),n.join("=")}),t}function u(){return s}let s=null;function l(e){s=e}},5490:function(e,t,n){"use strict";let r;n.d(t,{D:function(){return o},R:function(){return a}});var i=n(257);function o(){if(null==r){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if(void 0!==i)e=i;else if("undefined"!=typeof self)e=self;else throw Error("Could not find a global object");r=e}return r}function a(e,t){let n=function(){let e=o();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}},5823:function(e,t,n){"use strict";n.d(t,{B9:function(){return m},CQ:function(){return w},Cd:function(){return v},Cn:function(){return b},G4:function(){return u},MX:function(){return c},N5:function(){return p},N8:function(){return h},N_:function(){return k},R:function(){return s},SR:function(){return f},VY:function(){return B},XV:function(){return y},cF:function(){return l},cj:function(){return _},jq:function(){return S},lu:function(){return g},sq:function(){return d},x3:function(){return x},y3:function(){return $},ze:function(){return E}});var r=n(9681),i=n(6472),o=n(6150),a=n(5420);function u(){(0,i.OB)().set("PROD",!0)}function s(){(0,i.OB)().set("DEBUG",!0)}function l(){(0,i.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function c(e){(0,i.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function h(){r.BV.disposeVariables()}function f(){return r.BV}function d(){return r.BV.memory()}function p(e){return r.BV.profile(e)}function g(e,t){return r.BV.tidy(e,t)}function m(e){(0,a.getTensorsInContainer)(e).forEach(e=>e.dispose())}function b(e){return r.BV.keep(e)}function y(e){return r.BV.time(e)}function w(e){return r.BV.setBackend(e)}function v(){return r.BV.ready()}function k(){return r.BV.backendName}function _(e){r.BV.removeBackend(e)}function x(e){return r.BV.findBackend(e)}function E(e){return r.BV.findBackendFactory(e)}function S(e,t,n=1){return r.BV.registerBackend(e,t,n)}function $(){return r.BV.backend}function B(e,t){(0,i.OB)().setPlatform(e,t)}(0,o.FZ)(c)},4310:function(e,t,n){"use strict";n.d(t,{UQ:function(){return u},cb:function(){return f},fN:function(){return c},h7:function(){return l},pn:function(){return h},ti:function(){return s}});var r=n(9681),i=n(6150),o=n(971),a=n(2771);function u(e){return a.hu(a.mf(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let i=(0,o._1)(t,"x","tf.grad","string_or_numeric"),u=null!=n?(0,o._1)(n,"dy","tf.grad"):null;return r.BV.tidy(()=>{let{value:t,grads:n}=r.BV.gradients(()=>e(i),[i],u);return null!=u&&a.k5(t.shape,u.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),d(n),n[0]})}}function s(e){return a.hu(a.mf(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{a.hu(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let i=(0,o.sI)(t,"args","tf.grads","string_or_numeric"),u=null!=n?(0,o._1)(n,"dy","tf.grads"):null;return r.BV.tidy(()=>{let{value:t,grads:n}=r.BV.gradients(()=>e(...i),i,u);return null!=u&&a.k5(t.shape,u.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),d(n),n})}}function l(e){return a.hu(a.mf(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{a.hu(t instanceof i.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),a.hu(null==n||n instanceof i.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:o,value:u}=r.BV.gradients(()=>e(t),[t],n);return d(o),{grad:o[0],value:u}}}function c(e){return a.hu(a.mf(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{a.hu(Array.isArray(t)&&t.every(e=>e instanceof i.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),a.hu(null==n||n instanceof i.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let o=r.BV.gradients(()=>e(...t),t,n);return null!=n&&a.k5(o.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),d(o.grads),o}}function h(e,t){a.hu(a.mf(e),()=>"The f passed in variableGrads(f) must be a function"),a.hu(null==t||Array.isArray(t)&&t.every(e=>e instanceof i._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=null!=t;if(!n)for(let e in t=[],r.BV.registeredVariables)t.push(r.BV.registeredVariables[e]);let o=n?t.filter(e=>!e.trainable):null,u=t.length;t=t.filter(e=>e.trainable),a.hu(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${u} variables is trainable.`);let{value:s,grads:l}=r.BV.gradients(e,t,null,!0);a.hu(l.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),a.hu(0===s.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);let c={};return t.forEach((e,t)=>{null!=l[t]&&(c[e.name]=l[t])}),null!=o&&o.forEach(e=>c[e.name]=null),{value:s,grads:c}}function f(e){return r.BV.customGrad(e)}function d(e){if(e.filter(e=>null==e).length>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}},9094:function(e,t,n){"use strict";let r,i,o;n.r(t),n.d(t,{Abs:function(){return ta.SYM},Acos:function(){return ta.VGw},Acosh:function(){return ta.SpW},AdadeltaOptimizer:function(){return eI},AdagradOptimizer:function(){return eN},AdamOptimizer:function(){return eR},AdamaxOptimizer:function(){return eC},Add:function(){return ta.mm_},AddN:function(){return ta.Xze},All:function(){return ta.oT6},Any:function(){return ta.IKK},ArgMax:function(){return ta.sJF},ArgMin:function(){return ta.aJk},Asin:function(){return ta.M2y},Asinh:function(){return ta.qw7},Atan:function(){return ta.jMg},Atan2:function(){return ta.QCc},Atanh:function(){return ta.Oyi},AvgPool:function(){return ta.JhU},AvgPool3D:function(){return ta._k9},AvgPool3DGrad:function(){return ta.IMb},AvgPoolGrad:function(){return ta.ROF},BatchMatMul:function(){return ta.XLW},BatchToSpaceND:function(){return ta.zws},Bincount:function(){return ta.zvY},BitwiseAnd:function(){return ta.hCO},BroadcastArgs:function(){return ta.eEB},BroadcastTo:function(){return ta.Ly9},Cast:function(){return ta.RFZ},Ceil:function(){return ta.gJX},ClipByValue:function(){return ta.xnO},Complex:function(){return ta.Zz9},ComplexAbs:function(){return ta.yj2},Concat:function(){return ta.Eh3},Conv2D:function(){return ta.mhS},Conv2DBackpropFilter:function(){return ta.wUP},Conv2DBackpropInput:function(){return ta.wm},Conv3D:function(){return ta.x12},Conv3DBackpropFilterV2:function(){return ta.o2y},Conv3DBackpropInputV2:function(){return ta.ik2},Cos:function(){return ta.mc4},Cosh:function(){return ta.TR1},CropAndResize:function(){return ta.VcC},Cumprod:function(){return ta.Byc},Cumsum:function(){return ta.iHb},DataStorage:function(){return nY.JL},DenseBincount:function(){return ta.QRR},DepthToSpace:function(){return ta.T0n},DepthwiseConv2dNative:function(){return ta.cie},DepthwiseConv2dNativeBackpropFilter:function(){return ta.sL$},DepthwiseConv2dNativeBackpropInput:function(){return ta.y7R},Diag:function(){return ta.$w},Dilation2D:function(){return ta.p4S},Dilation2DBackpropFilter:function(){return ta.Vn9},Dilation2DBackpropInput:function(){return ta.ekb},Draw:function(){return ta.hGc},ENV:function(){return x.Vi},Einsum:function(){return ta.$g6},Elu:function(){return ta.SX0},EluGrad:function(){return ta.HEU},Environment:function(){return x.qA},Equal:function(){return ta.hdR},Erf:function(){return ta.Omj},Exp:function(){return ta.NEP},ExpandDims:function(){return ta.YFo},Expm1:function(){return ta.Y0y},FFT:function(){return ta.vwp},Fill:function(){return ta.deh},FlipLeftRight:function(){return ta.Uyb},Floor:function(){return ta.OR},FloorDiv:function(){return ta.jeX},FromPixels:function(){return ta.eBW},FusedBatchNorm:function(){return ta.sHE},FusedConv2D:function(){return ta._V0},FusedDepthwiseConv2D:function(){return ta.luS},GatherNd:function(){return ta.q1x},GatherV2:function(){return ta.qi_},Greater:function(){return ta.iZT},GreaterEqual:function(){return ta.Acj},IFFT:function(){return ta.Qg5},Identity:function(){return ta.iJz},Imag:function(){return ta.J_u},IsFinite:function(){return ta.avt},IsInf:function(){return ta.iWB},IsNan:function(){return ta.r7n},KernelBackend:function(){return nY.Zu},LRN:function(){return ta.eZ0},LRNGrad:function(){return ta.Hhh},LeakyRelu:function(){return ta.J$2},Less:function(){return ta.vtC},LessEqual:function(){return ta.CAk},LinSpace:function(){return ta.e7N},Log:function(){return ta.ZbH},Log1p:function(){return ta.kU},LogSoftmax:function(){return ta.qCd},LogicalAnd:function(){return ta.PYm},LogicalNot:function(){return ta.VfG},LogicalOr:function(){return ta.MZg},LogicalXor:function(){return ta.w6g},LowerBound:function(){return ta.qIC},MatrixBandPart:function(){return ta.J7O},Max:function(){return ta.YoZ},MaxPool:function(){return ta.mTV},MaxPool3D:function(){return ta.OAf},MaxPool3DGrad:function(){return ta.OU7},MaxPoolGrad:function(){return ta.OV7},MaxPoolWithArgmax:function(){return ta.vFR},Maximum:function(){return ta.BMI},Mean:function(){return ta.q2K},Min:function(){return ta.c17},Minimum:function(){return ta.q8u},MirrorPad:function(){return ta.jQs},Mod:function(){return ta.Vbg},MomentumOptimizer:function(){return eP},Multinomial:function(){return ta.NZg},Multiply:function(){return ta.wYn},Neg:function(){return ta.kuV},NonMaxSuppressionV3:function(){return ta.uv1},NonMaxSuppressionV4:function(){return ta.cye},NonMaxSuppressionV5:function(){return ta.W0H},NotEqual:function(){return ta.yQU},OP_SCOPE_SUFFIX:function(){return tJ.zvA},OneHot:function(){return ta.we_},OnesLike:function(){return ta.qWM},Optimizer:function(){return eA},OptimizerConstructors:function(){return tX},Pack:function(){return ta.QiL},PadV2:function(){return ta.lyA},Pool:function(){return ta.Kgp},Pow:function(){return ta.pe_},Prelu:function(){return ta.o0g},Prod:function(){return ta.DlI},RMSPropOptimizer:function(){return eL},RaggedGather:function(){return ta.dDz},RaggedRange:function(){return ta.CQl},RaggedTensorToTensor:function(){return ta.BiW},Range:function(){return ta.e6w},Rank:function(){return tZ.yw},Real:function(){return ta.xJR},RealDiv:function(){return ta.oHH},Reciprocal:function(){return ta.$HU},Reduction:function(){return tY.I},Relu:function(){return ta.qkr},Relu6:function(){return ta.SbG},Reshape:function(){return ta.HZH},ResizeBilinear:function(){return ta._Yw},ResizeBilinearGrad:function(){return ta.zbQ},ResizeNearestNeighbor:function(){return ta.dpD},ResizeNearestNeighborGrad:function(){return ta.Hmb},Reverse:function(){return ta.mKl},RotateWithOffset:function(){return ta.b9H},Round:function(){return ta.e07},Rsqrt:function(){return ta.bV0},SGDOptimizer:function(){return eF},ScatterNd:function(){return ta.xQA},SearchSorted:function(){return ta.nr8},Select:function(){return ta.PhF},Selu:function(){return ta.oFR},Sigmoid:function(){return ta.a5O},Sign:function(){return ta.i5y},Sin:function(){return ta.RQH},Sinh:function(){return ta.wYB},Slice:function(){return ta.p2w},Softmax:function(){return ta.Gcp},Softplus:function(){return ta.MRv},SpaceToBatchND:function(){return ta.TQc},SparseFillEmptyRows:function(){return ta.O3z},SparseReshape:function(){return ta.nhH},SparseSegmentMean:function(){return ta.w3H},SparseSegmentSum:function(){return ta.ZjV},SparseToDense:function(){return ta.D2d},SplitV:function(){return ta.L8s},Sqrt:function(){return ta.FKq},Square:function(){return ta.bK0},SquaredDifference:function(){return ta._tC},StaticRegexReplace:function(){return ta.e0R},Step:function(){return ta.h8e},StridedSlice:function(){return ta.jQk},StringNGrams:function(){return ta._JP},StringSplit:function(){return ta.s1s},StringToHashBucketFast:function(){return ta.XkS},Sub:function(){return ta.Tr8},Sum:function(){return ta.GBy},Tan:function(){return ta.sEM},Tanh:function(){return ta.MIZ},Tensor:function(){return eh.es},TensorBuffer:function(){return eh.YD},TensorScatterUpdate:function(){return ta.SIB},Tile:function(){return ta.n9L},TopK:function(){return ta.cWu},Transform:function(){return ta.wx7},Transpose:function(){return ta.G3Y},Unique:function(){return ta.kpP},Unpack:function(){return ta.ToN},UnsortedSegmentSum:function(){return ta.Qvg},UpperBound:function(){return ta.XDQ},Variable:function(){return eh._w},ZerosLike:function(){return ta.RuY},_FusedMatMul:function(){return ta.usg},abs:function(){return tJ.WnP},acos:function(){return tJ.Khb},acosh:function(){return tJ.__u},add:function(){return tJ.IHx},addN:function(){return tJ.QBD},all:function(){return tJ.$6P},any:function(){return tJ.YjB},argMax:function(){return tJ.NqF},argMin:function(){return tJ.vHJ},asin:function(){return tJ.ZRM},asinh:function(){return tJ.VfV},atan:function(){return tJ.z4N},atan2:function(){return tJ.fvJ},atanh:function(){return tJ.C80},avgPool:function(){return tJ.wS1},avgPool3d:function(){return tJ.uR5},backend:function(){return ed.y3},backend_util:function(){return b},basicLSTMCell:function(){return tJ.zEQ},batchNorm:function(){return tJ.tgs},batchNorm2d:function(){return tJ.Dxk},batchNorm3d:function(){return tJ.JY5},batchNorm4d:function(){return tJ.p3b},batchToSpaceND:function(){return tJ.E4h},bincount:function(){return tJ.yE8},bitwiseAnd:function(){return tJ.ycw},booleanMaskAsync:function(){return tJ.anm},broadcastArgs:function(){return tJ.XsQ},broadcastTo:function(){return tJ.UFq},broadcast_util:function(){return to},browser:function(){return f},buffer:function(){return tJ.f3b},cast:function(){return tJ.pju},ceil:function(){return tJ.mDi},clipByValue:function(){return tJ.iUl},clone:function(){return tJ.d9v},complex:function(){return tJ.PYB},concat:function(){return tJ.zoF},concat1d:function(){return tJ.gME},concat2d:function(){return tJ.Izb},concat3d:function(){return tJ.MNy},concat4d:function(){return tJ.ZaL},conv1d:function(){return tJ.PAt},conv2d:function(){return tJ.Tek},conv2dTranspose:function(){return tJ.bc},conv3d:function(){return tJ.pdZ},conv3dTranspose:function(){return tJ.$QV},copyRegisteredKernels:function(){return tu.T3},cos:function(){return tJ.mCk},cosh:function(){return tJ.f9Y},cosineWindow:function(){return tJ.mew},cumprod:function(){return tJ.$Gn},cumsum:function(){return tJ.zbp},customGrad:function(){return ev.cb},denseBincount:function(){return tJ.ppE},deprecationWarn:function(){return ed.MX},depthToSpace:function(){return tJ.nTT},depthwiseConv2d:function(){return tJ.B10},device_util:function(){return s},diag:function(){return tJ.Ka3},dilation2d:function(){return tJ.WmZ},disableDeprecationWarnings:function(){return ed.cF},dispose:function(){return ed.B9},disposeVariables:function(){return ed.N8},div:function(){return tJ.hiC},divNoNan:function(){return tJ.NTj},dot:function(){return tJ.AKD},dropout:function(){return tJ.rvX},einsum:function(){return tJ.WYO},elu:function(){return tJ.pyx},enableDebugMode:function(){return ed.R},enableProdMode:function(){return ed.G4},enclosingPowerOfTwo:function(){return tJ.GRh},engine:function(){return ed.SR},ensureShape:function(){return tJ.EDe},env:function(){return x.OB},equal:function(){return tJ.DgJ},erf:function(){return tJ.qNN},euclideanNorm:function(){return tJ.d2q},exp:function(){return tJ.Qqt},expandDims:function(){return tJ.dt4},expm1:function(){return tJ.t$B},eye:function(){return tJ.iyy},fft:function(){return tJ.kp_},fill:function(){return tJ.hlL},findBackend:function(){return ed.x3},findBackendFactory:function(){return ed.ze},floor:function(){return tJ.GWj},floorDiv:function(){return tJ.qPi},fused:function(){return tJ.imm},gather:function(){return tJ.Iqj},gatherND:function(){return tJ.dbB},gather_util:function(){return d},getBackend:function(){return ed.N_},getGradient:function(){return tu.uk},getKernel:function(){return tu.pI},getKernelsForBackend:function(){return tu.tr},grad:function(){return ev.UQ},grads:function(){return ev.ti},greater:function(){return tJ.pjt},greaterEqual:function(){return tJ.brS},ifft:function(){return tJ.Sxn},imag:function(){return tJ.asL},image:function(){return tJ.BHj},inTopKAsync:function(){return tJ.V3u},io:function(){return c},irfft:function(){return tJ.wx0},isFinite:function(){return tJ.xVT},isInf:function(){return tJ.UWc},isNaN:function(){return tJ.i2d},keep:function(){return ed.Cn},kernel_impls:function(){return y},leakyRelu:function(){return tJ.hi7},less:function(){return tJ.d9m},lessEqual:function(){return tJ.zN1},linalg:function(){return tJ.$r2},linspace:function(){return tJ.SX3},localResponseNormalization:function(){return tJ.G9k},log:function(){return tJ.cM7},log1p:function(){return tJ.Krr},logSigmoid:function(){return tJ.e_t},logSoftmax:function(){return tJ.CmS},logSumExp:function(){return tJ.l_t},logicalAnd:function(){return tJ.HvI},logicalNot:function(){return tJ.hJK},logicalOr:function(){return tJ.K5V},logicalXor:function(){return tJ.egP},losses:function(){return tJ.MB5},lowerBound:function(){return tJ.eab},matMul:function(){return tJ.OI3},math:function(){return h},max:function(){return tJ.Fp7},maxPool:function(){return tJ._sB},maxPool3d:function(){return tJ.YQQ},maxPoolWithArgmax:function(){return tJ.Ip$},maximum:function(){return tJ.gWQ},mean:function(){return tJ.J69},memory:function(){return ed.sq},meshgrid:function(){return tJ.ry_},min:function(){return tJ.VV$},minimum:function(){return tJ.LTh},mirrorPad:function(){return tJ.VdP},mod:function(){return tJ.wQq},moments:function(){return tJ.Gi7},movingAverage:function(){return tJ.p_},mul:function(){return tJ.dC7},multiRNNCell:function(){return tJ.rq4},multinomial:function(){return tJ.SJ_},neg:function(){return tJ.W76},nextFrame:function(){return t1},norm:function(){return tJ.KOy},notEqual:function(){return tJ.Quu},oneHot:function(){return tJ.lfX},ones:function(){return tJ.iUs},onesLike:function(){return tJ.JpU},op:function(){return tJ.op},outerProduct:function(){return tJ.N2O},pad:function(){return tJ.vku},pad1d:function(){return tJ.pNR},pad2d:function(){return tJ.koy},pad3d:function(){return tJ.t1L},pad4d:function(){return tJ.lGY},pool:function(){return tJ.d_R},pow:function(){return tJ.sQ3},prelu:function(){return tJ.AL3},print:function(){return tJ.S0v},prod:function(){return tJ.WVs},profile:function(){return ed.N5},raggedGather:function(){return tJ.$gW},raggedRange:function(){return tJ.VT$},raggedTensorToTensor:function(){return tJ.N89},rand:function(){return tJ.TN_},randomGamma:function(){return tJ.wzB},randomNormal:function(){return tJ.nGf},randomStandardNormal:function(){return tJ.ruB},randomUniform:function(){return tJ.LGj},randomUniformInt:function(){return tJ.pe5},range:function(){return tJ.w6H},ready:function(){return ed.Cd},real:function(){return tJ.kwC},reciprocal:function(){return tJ.M25},registerBackend:function(){return ed.jq},registerGradient:function(){return tu.Li},registerKernel:function(){return tu.wC},relu:function(){return tJ.UYe},relu6:function(){return tJ.btT},removeBackend:function(){return ed.cj},reshape:function(){return tJ.XLQ},reverse:function(){return tJ.GYS},reverse1d:function(){return tJ.SDf},reverse2d:function(){return tJ.diP},reverse3d:function(){return tJ.sx7},reverse4d:function(){return tJ.mG2},rfft:function(){return tJ.QEs},round:function(){return tJ.NMM},rsqrt:function(){return tJ.bp0},scalar:function(){return tJ.iD$},scatterND:function(){return tJ.snQ},scatter_util:function(){return tb},searchSorted:function(){return tJ.zcT},selu:function(){return tJ.U8D},separableConv2d:function(){return tJ.U_I},serialization:function(){return l},setBackend:function(){return ed.CQ},setPlatform:function(){return ed.VY},setdiff1dAsync:function(){return tJ.ODp},sigmoid:function(){return tJ.XD2},sign:function(){return tJ.Xxe},signal:function(){return tJ.tdS},sin:function(){return tJ.O$l},sinh:function(){return tJ.R_K},slice:function(){return tJ.tPi},slice1d:function(){return tJ.jZU},slice2d:function(){return tJ.SmN},slice3d:function(){return tJ.CnO},slice4d:function(){return tJ.p0P},slice_util:function(){return p},softmax:function(){return tJ.XAC},softplus:function(){return tJ.Wvh},spaceToBatchND:function(){return tJ.fBT},sparse:function(){return tJ.rVs},sparseToDense:function(){return tJ.ers},spectral:function(){return tJ.uN7},split:function(){return tJ.Vl2},sqrt:function(){return tJ._b3},square:function(){return tJ.h62},squaredDifference:function(){return tJ.$i},squeeze:function(){return tJ.L9e},stack:function(){return tJ.knu},step:function(){return tJ.Nbs},stridedSlice:function(){return tJ.NXj},string:function(){return tJ.Z_8},sub:function(){return tJ.luU},sum:function(){return tJ.Smz},sumOutType:function(){return tZ.z4},tan:function(){return tJ.ORZ},tanh:function(){return tJ.AEp},tensor:function(){return tJ.XeE},tensor1d:function(){return tJ.RRF},tensor2d:function(){return tJ.odF},tensor3d:function(){return tJ.wOQ},tensor4d:function(){return tJ.yXz},tensor5d:function(){return tJ.Bfx},tensor6d:function(){return tJ.xZs},tensorScatterUpdate:function(){return tJ.Pg0},tensor_util:function(){return tR},test_util:function(){return g},tidy:function(){return ed.lu},tile:function(){return tJ.Gg6},time:function(){return ed.XV},topk:function(){return tJ.hg7},train:function(){return tQ},transpose:function(){return tJ.p4s},truncatedNormal:function(){return tJ.Xu6},unique:function(){return tJ.Two},unregisterGradient:function(){return tu.bt},unregisterKernel:function(){return tu.nE},unsortedSegmentSum:function(){return tJ.pUJ},unstack:function(){return tJ.HHK},upcastType:function(){return tZ.x8},upperBound:function(){return tJ.GaM},util:function(){return tV},valueAndGrad:function(){return ev.h7},valueAndGrads:function(){return ev.fN},variable:function(){return tJ.VD$},variableGrads:function(){return ev.pn},version_core:function(){return tj},where:function(){return tJ.arb},whereAsync:function(){return tJ.itS},zeros:function(){return tJ.lls},zerosLike:function(){return tJ.P84}});var a,u,s={};n.r(s),n.d(s,{isBrowser:function(){return _},isMobile:function(){return k},mockIsMobile:function(){return v}});var l={};n.r(l),n.d(l,{Serializable:function(){return eE},SerializationMap:function(){return eS},getRegisteredName:function(){return eB},registerClass:function(){return e$}});var c={};n.r(c),n.d(c,{CompositeArrayBuffer:function(){return M.w},browserFiles:function(){return eq},browserHTTPRequest:function(){return e1},concatenateArrayBuffers:function(){return $.JY},copyModel:function(){return ee},decodeWeights:function(){return $.dI},decodeWeightsStream:function(){return $.r},encodeWeights:function(){return $.yz},fromMemory:function(){return e6},fromMemorySync:function(){return e5},getLoadHandlers:function(){return N},getModelArtifactsForJSON:function(){return $.jN},getModelArtifactsForJSONSync:function(){return $.ji},getModelArtifactsInfoForJSON:function(){return $.Q},getSaveHandlers:function(){return T},getWeightSpecs:function(){return $.hu},http:function(){return e0},isHTTPScheme:function(){return eY},listModels:function(){return Y},loadWeights:function(){return eX},moveModel:function(){return et},registerLoadRouter:function(){return I},registerSaveRouter:function(){return A},removeModel:function(){return Q},weightsLoaderFactory:function(){return eZ},withSaveHandler:function(){return e7},withSaveHandlerSync:function(){return e8}});var h={};n.r(h),n.d(h,{confusionMatrix:function(){return ti}});var f={};n.r(f),n.d(f,{draw:function(){return tp},fromPixels:function(){return tg},fromPixelsAsync:function(){return th},toPixels:function(){return td}});var d={};n.r(d),n.d(d,{prepareAndValidate:function(){return tm}});var p={};n.r(p),n.d(p,{assertParamsValid:function(){return ty},computeFlatOffset:function(){return tT},computeOutShape:function(){return tv},getNormalizedAxes:function(){return tx},isSliceContinous:function(){return tI},maskToAxes:function(){return tw},parseSliceParams:function(){return tN},sliceInfo:function(){return tM},startForAxis:function(){return tB},startIndicesWithElidedDims:function(){return tE},stopForAxis:function(){return tA},stopIndicesWithElidedDims:function(){return tS},stridesForAxis:function(){return t$},stridesWithElidedDims:function(){return tk}});var g={};n.r(g),n.d(g,{TEST_EPSILON_FLOAT16:function(){return tO},createVideoElement:function(){return tK},encodeStrings:function(){return function e(t){for(let n=0;n<t.length;n++){let r=t[n];Array.isArray(r)?e(r):t[n]=(0,tV.encodeString)(r)}return t}},expectArrayBuffersEqual:function(){return tq},expectArraysClose:function(){return tC},expectArraysEqual:function(){return tG},expectNumbersClose:function(){return tU},expectPromiseToFail:function(){return tL},expectValuesInRange:function(){return tW},play:function(){return tH},testEpsilon:function(){return tF}});var m={};n.r(m),n.d(m,{collectGatherOpShapeInfo:function(){return nH},computeOutShape:function(){return nK},segOpComputeOptimalWindowSize:function(){return nq}});var b={};n.r(b),n.d(b,{ERF_A1:function(){return nf},ERF_A2:function(){return nd},ERF_A3:function(){return np},ERF_A4:function(){return ng},ERF_A5:function(){return nm},ERF_P:function(){return nh},PARALLELIZE_THRESHOLD:function(){return nt},RowPartitionType:function(){return u},SELU_SCALE:function(){return nc},SELU_SCALEALPHA:function(){return nl},applyActivation:function(){return t5.QH},assertAndGetBroadcastShape:function(){return to.assertAndGetBroadcastShape},assertAxesAreInnerMostDims:function(){return t2.lB},assertParamsConsistent:function(){return t3},assignToTypedArray:function(){return nx},axesAreInnerMostDims:function(){return t2.YB},calculateShapes:function(){return tb.calculateShapes},checkEinsumDimSizes:function(){return nI},checkPadOnDimRoundingMode:function(){return t6.m},combineLocations:function(){return t2.Vh},combineRaggedTensorToTensorShapes:function(){return t7},complexWithEvenIndex:function(){return nv},complexWithOddIndex:function(){return nk},computeConv2DInfo:function(){return t6.Ix},computeConv3DInfo:function(){return t6.jw},computeDefaultPad:function(){return t6.aO},computeDilation2DInfo:function(){return t6.Rf},computeOptimalWindowSize:function(){return nn},computeOutAndReduceShapes:function(){return t2.kz},computeOutShape:function(){return t4},computePool2DInfo:function(){return t6.Xw},computePool3DInfo:function(){return t6.pl},convertConv2DDataFormat:function(){return t6.sl},decodeEinsumEquation:function(){return nB},eitherStridesOrDilationsAreOne:function(){return t6.jT},expandShapeToKeepDim:function(){return t2.rv},exponent:function(){return nS},exponents:function(){return nE},fromStringArrayToUint8:function(){return nX},fromUint8ToStringArray:function(){return nj},getAxesPermutation:function(){return t2.Q3},getBroadcastDims:function(){return to.getBroadcastDims},getComplexWithIndex:function(){return n_},getEinsumComputePath:function(){return nT},getEinsumPermutation:function(){return nA},getFusedBiasGradient:function(){return t5.pf},getFusedDyActivation:function(){return t5.Fr},getImageCenter:function(){return nr},getInnerMostAxes:function(){return t2.sY},getPermuted:function(){return no},getRaggedRank:function(){return t9},getReductionAxes:function(){return to.getReductionAxes},getReshaped:function(){return ni},getReshapedPermuted:function(){return na},getRowPartitionTypesHelper:function(){return t8},getSliceBeginCoords:function(){return nu},getSliceSize:function(){return ns},getSparseFillEmptyRowsIndicesDenseShapeMismatch:function(){return nD},getSparseFillEmptyRowsNegativeIndexErrorMessage:function(){return nR},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:function(){return nV},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:function(){return nF},getSparseReshapeInputOutputMismatchErrorMessage:function(){return nL},getSparseReshapeInputOutputMultipleErrorMessage:function(){return nP},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:function(){return nO},getSparseReshapeNegativeOutputDimErrorMessage:function(){return nC},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:function(){return nW},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:function(){return nG},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:function(){return nU},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:function(){return nz},getUndoAxesPermutation:function(){return t2.LJ},isIdentityPermutation:function(){return nN},log:function(){return nb.c},mergeRealAndImagArrays:function(){return ny},prepareAndValidate:function(){return tm},prepareSplitSize:function(){return nM},segment_util:function(){return m},shouldFuse:function(){return t5.uy},slice_util:function(){return p},splitRealAndImagArrays:function(){return nw},stridesOrDilationsArePositive:function(){return t6.U3},tupleValuesAreOne:function(){return t6.I0},upcastType:function(){return tZ.x8},validateDefaultValueShape:function(){return ne},validateInput:function(){return tb.validateInput},validateUpdateShape:function(){return tb.validateUpdateShape},warn:function(){return nb.Z}});var y={};n.r(y),n.d(y,{nonMaxSuppressionV3Impl:function(){return nZ.GP},nonMaxSuppressionV4Impl:function(){return nZ.qP},nonMaxSuppressionV5Impl:function(){return nZ.pA},whereImpl:function(){return nJ.Z}});var w=n(9681);function v(e){r=e}function k(e){if(void 0!==r)return r;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function _(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var x=n(6472),E=n(257);let S=(0,x.OB)();S.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),S.registerFlag("IS_BROWSER",()=>_()),S.registerFlag("IS_NODE",()=>void 0!==E&&void 0!==E.versions&&void 0!==E.versions.node),S.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),S.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),S.registerFlag("PROD",()=>!1),S.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>S.getBool("DEBUG")),S.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),S.registerFlag("IS_TEST",()=>!1),S.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>S.getBool("DEBUG")),S.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),S.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),S.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var $=n(3850);class B{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==B.instance&&(B.instance=new B),B.instance}static registerSaveRouter(e){B.getInstance().saveRouters.push(e)}static registerLoadRouter(e){B.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return B.getHandlers(e,"save")}static getLoadHandlers(e,t){return B.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?B.getInstance().loadRouters:B.getInstance().saveRouters).forEach(t=>{let i=t(e,n);null!==i&&r.push(i)}),r}}let A=e=>B.registerSaveRouter(e),I=e=>B.registerLoadRouter(e),T=e=>B.getSaveHandlers(e),N=(e,t)=>B.getLoadHandlers(e,t);var M=n(807);let D="tensorflowjs",R="models_store",V="model_info_store";function O(){if(!(0,x.OB)().getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw Error("The current browser does not appear to support IndexedDB.");return t}function C(e){let t=e.result;t.createObjectStore(R,{keyPath:"modelPath"}),t.createObjectStore(V,{keyPath:"modelPath"})}class F{constructor(e){if(this.indexedDB=O(),null==e||!e)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{let r=this.indexedDB.open(D,1);r.onupgradeneeded=()=>C(r),r.onsuccess=()=>{let i=r.result;if(null==t){let t=i.transaction(R,"readonly"),r=t.objectStore(R).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return i.close(),n(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(i.close(),n(r.error)),t.oncomplete=()=>i.close()}else{let r,o;t.weightData=M.w.join(t.weightData);let a=(0,$.Q)(t),u=i.transaction(V,"readwrite"),s=u.objectStore(V);try{r=s.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(e){return n(e)}r.onsuccess=()=>{let r;let l=(o=i.transaction(R,"readwrite")).objectStore(R);try{r=l.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(e){return n(e)}r.onsuccess=()=>e({modelArtifactsInfo:a}),r.onerror=e=>{let t=(s=u.objectStore(V)).delete(this.modelPath);t.onsuccess=()=>(i.close(),n(r.error)),t.onerror=e=>(i.close(),n(r.error))}},r.onerror=e=>(i.close(),n(r.error)),u.oncomplete=()=>{null==o?i.close():o.oncomplete=()=>i.close()}}},r.onerror=e=>n(r.error)})}}F.URL_SCHEME="indexeddb://";let P=e=>{var t;return(0,x.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(F.URL_SCHEME)?(t=e.slice(F.URL_SCHEME.length),new F(t)):null};B.registerSaveRouter(P),B.registerLoadRouter(P);class L{constructor(){this.indexedDB=O()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(D,1);n.onupgradeneeded=()=>C(n),n.onsuccess=()=>{let r=n.result,i=r.transaction(V,"readonly"),o=i.objectStore(V).getAll();o.onsuccess=()=>{let t={};for(let e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(r.close(),t(o.error)),i.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(F.URL_SCHEME)?t.slice(F.URL_SCHEME.length):t,new Promise((t,n)=>{let r=this.indexedDB.open(D,1);r.onupgradeneeded=()=>C(r),r.onsuccess=()=>{let i;let o=r.result,a=o.transaction(V,"readwrite"),u=a.objectStore(V),s=u.get(e);s.onsuccess=()=>{if(null==s.result)return o.close(),n(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=u.delete(e),a=()=>{let r=(i=o.transaction(R,"readwrite")).objectStore(R).delete(e);r.onsuccess=()=>t(s.result.modelArtifactsInfo),r.onerror=e=>n(s.error)};r.onsuccess=a,r.onerror=e=>(a(),o.close(),n(s.error))}},s.onerror=e=>(o.close(),n(s.error)),a.oncomplete=()=>{null==i?o.close():i.oncomplete=()=>o.close()}},r.onerror=e=>n(r.error)})}}var G=n(2771);let U="tensorflowjs_models",z="info";function W(e){return{info:[U,e,z].join("/"),topology:[U,e,"model_topology"].join("/"),weightSpecs:[U,e,"weight_specs"].join("/"),weightData:[U,e,"weight_data"].join("/"),modelMetadata:[U,e,"model_metadata"].join("/")}}function q(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}class K{constructor(e){if(!(0,x.OB)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=W(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=(0,$.Q)(e),i=M.w.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(0,$._n)(i));let o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch(e){throw q(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let i=this.LS.getItem(this.keys.modelMetadata);if(null!=i){let e=JSON.parse(i);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let o=this.LS.getItem(this.keys.weightData);if(null==o)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=(0,$.n7)(o),t}}K.URL_SCHEME="localstorage://";let H=e=>{var t;return(0,x.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(K.URL_SCHEME)?(t=e.slice(K.URL_SCHEME.length),new K(t)):null};B.registerSaveRouter(H),B.registerLoadRouter(H);class j{constructor(){(0,G.hu)((0,x.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,G.hu)("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=U+"/",n="/"+z;for(let r=0;r<this.LS.length;++r){let i=this.LS.key(r);i.startsWith(t)&&i.endsWith(n)&&(e[function(e){let t=e.split("/");if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join("/")}(i)]=JSON.parse(this.LS.getItem(i)))}return e}async removeModel(e){var t;let n=W(e=(t=e).startsWith(K.URL_SCHEME)?t.slice(K.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw Error(`Cannot find model at path '${e}'`);let r=JSON.parse(this.LS.getItem(n.info));return q(n),r}}class X{constructor(){this.managers={}}static getInstance(){return null==X.instance&&(X.instance=new X),X.instance}static registerManager(e,t){(0,G.hu)(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),(0,G.hu)(e.length>0,()=>"scheme must not be an empty string.");let n=X.getInstance();(0,G.hu)(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=X.getInstance().managers[e];if(null==t)throw Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(X.getInstance().managers)}}function Z(e){if(-1===e.indexOf("://"))throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${X.getSchemes().join(",")}`);return{scheme:e.split("://")[0],path:e.split("://")[1]}}async function J(e,t,n=!1){(0,G.hu)(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=B.getLoadHandlers(e);(0,G.hu)(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),(0,G.hu)(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let i=r[0],o=B.getSaveHandlers(t);(0,G.hu)(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),(0,G.hu)(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let a=o[0],u=Z(e).scheme,s=Z(e).path,l=u===Z(e).scheme,c=await i.load();n&&l&&await X.getManager(u).removeModel(s);let h=await a.save(c);return n&&!l&&await X.getManager(u).removeModel(s),h.modelArtifactsInfo}async function Y(){let e=X.getSchemes(),t={};for(let n of e){let e=await X.getManager(n).listModels();for(let r in e)t[n+"://"+r]=e[r]}return t}async function Q(e){let t=Z(e);return X.getManager(t.scheme).removeModel(t.path)}async function ee(e,t){return J(e,t,!1)}async function et(e,t){return J(e,t,!0)}var en=n(8719);class er{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if("undefined"==typeof window||!(0,x.OB)().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))}isTypedArray(e){return(0,en.j)(e)}}if((0,x.OB)().get("IS_BROWSER")){(0,x.OB)().setPlatform("browser",new er);try{X.registerManager(K.URL_SCHEME,new j)}catch(e){}try{X.registerManager(F.URL_SCHEME,new L)}catch(e){}}var ei=n(257);let eo={importFetch:()=>n(4319)};class ea{constructor(){this.util=n(8628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,x.OB)().global.fetch?(0,x.OB)().global.fetch(e,t):(null==i&&(i=eo.importFetch()),i(e,t))}now(){let e=ei.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}(0,x.OB)().get("IS_NODE")&&!(0,x.OB)().get("IS_BROWSER")&&(0,x.OB)().setPlatform("node",new ea);var eu=n(5515),es=n(8893),el=n(699),ec=n(7290),eh=n(6150);(0,w.wv)();let ef={buffer:eu.f,cast:es.p,clone:el.d,print:ec.S};(0,eh.Vp)(ef);var ed=n(5823),ep=n(3266),eg=n(3511),em=n(5314),eb=n(9467),ey=n(7941),ew=n(2898),ev=n(4310),ek=n(6070);let e_=new Map,ex=new Map;class eE{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class eS{constructor(){this.classNameMap={}}static getMap(){return null==eS.instance&&(eS.instance=new eS),eS.instance}static register(e){eS.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function e$(e,t,n){(0,G.hu)(null!=e.className,()=>"Class being registered does not have the static className property defined."),(0,G.hu)("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),(0,G.hu)(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);let r=t+">"+n;return eS.register(e),e_.set(r,e),ex.set(e,r),e}function eB(e){return ex.has(e)?ex.get(e):e.className}class eA extends eE{minimize(e,t=!1,n){let{value:r,grads:i}=this.computeGradients(e,n);if(null!=n){let e=n.map(e=>({name:e.name,tensor:i[e.name]}));this.applyGradients(e)}else this.applyGradients(i);return((0,ed.B9)(i),t)?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,ev.pn)(e,t)}dispose(){null!=this.iterations_&&(0,ed.B9)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,ek.i)(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(eA,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class eI extends eA{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=w.BV.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=w.BV.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;(0,ed.lu)(()=>{let e=(0,ep.I)((0,em.d)(o,this.rho),(0,em.d)((0,ey.h)(i),1-this.rho)),t=(0,em.d)((0,eg.h)((0,eb._)((0,ep.I)(a,this.epsilon)),(0,eb._)((0,ep.I)(o,this.epsilon))),i),n=(0,ep.I)((0,em.d)(a,this.rho),(0,em.d)((0,ey.h)(t),1-this.rho));o.assign(e),a.assign(n);let u=(0,ep.I)((0,em.d)(t,-this.learningRate),r);r.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,ed.B9)(this.accumulatedGrads.map(e=>e.variable)),(0,ed.B9)(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}var eT=n(180);class eN extends eA{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=w.BV.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,ed.lu)(()=>(0,eT.h)(r.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedGrads[n].variable;(0,ed.lu)(()=>{let e=(0,ep.I)(o,(0,ey.h)(i));o.assign(e);let t=(0,ep.I)((0,em.d)((0,eg.h)(i,(0,eb._)((0,ep.I)(e,w.BV.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,ed.B9)(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}var eM=n(2611),eD=n(5799);class eR extends eA{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,ed.lu)(()=>{this.accBeta1=(0,ek.i)(t).variable(),this.accBeta2=(0,ek.i)(n).variable()}),null==r&&(this.epsilon=w.BV.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);(0,ed.lu)(()=>{let n=(0,eD.l)(1,this.accBeta1),r=(0,eD.l)(1,this.accBeta2);t.forEach((t,i)=>{let o=w.BV.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,ed.lu)(()=>(0,ew.P)(o).variable(!1))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:(0,ed.lu)(()=>(0,ew.P)(o).variable(!1))});let a=Array.isArray(e)?e[i].tensor:e[t];if(null==a)return;let u=this.accumulatedFirstMoment[i].variable,s=this.accumulatedSecondMoment[i].variable,l=(0,ep.I)((0,em.d)(u,this.beta1),(0,em.d)(a,1-this.beta1)),c=(0,ep.I)((0,em.d)(s,this.beta2),(0,em.d)((0,ey.h)(a),1-this.beta2)),h=(0,eg.h)(l,n),f=(0,eg.h)(c,r);u.assign(l),s.assign(c);let d=(0,ep.I)((0,em.d)((0,eg.h)(h,(0,ep.I)((0,eb._)(f),this.epsilon)),-this.learningRate),o);o.assign(d)}),this.accBeta1.assign((0,em.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,em.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,ed.B9)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&(0,ed.B9)(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),(0,ed.lu)(()=>{this.accBeta1.assign((0,eM.s)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,eM.s)(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}var eV=n(9044),eO=n(2673);class eC extends eA{static get className(){return"Adamax"}constructor(e,t,n,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,ed.lu)(()=>{this.iteration=(0,ek.i)(0).variable(),this.accBeta1=(0,ek.i)(t).variable()}),null==r&&(this.epsilon=w.BV.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);(0,ed.lu)(()=>{let n=(0,eD.l)(1,this.accBeta1),r=(0,eg.h)(-this.learningRate,(0,ep.I)((0,em.d)(this.iteration,this.decay),1));t.forEach((t,i)=>{let o=w.BV.registeredVariables[t];null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:(0,ew.P)(o).variable(!1)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:(0,ew.P)(o).variable(!1)});let a=Array.isArray(e)?e[i].tensor:e[t];if(null==a)return;let u=this.accumulatedFirstMoment[i].variable,s=this.accumulatedWeightedInfNorm[i].variable,l=(0,ep.I)((0,em.d)(u,this.beta1),(0,em.d)(a,1-this.beta1)),c=(0,em.d)(s,this.beta2),h=(0,eV.W)(a),f=(0,eO.g)(c,h);u.assign(l),s.assign(f);let d=(0,ep.I)((0,em.d)((0,eg.h)(r,n),(0,eg.h)(l,(0,ep.I)(f,this.epsilon))),o);o.assign(d)}),this.iteration.assign((0,ep.I)(this.iteration,1)),this.accBeta1.assign((0,em.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,ed.B9)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&(0,ed.B9)(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class eF extends eA{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let i=w.BV.registeredVariables[t];(0,ed.lu)(()=>{let e=(0,ep.I)((0,em.d)(this.c,r),i);i.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,ed.Cn)((0,ek.i)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class eP extends eF{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,ek.i)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=w.BV.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))});let i=this.accumulations[n].variable,o=Array.isArray(e)?e[n].tensor:e[t];null!=o&&(0,ed.lu)(()=>{let e;let t=(0,ep.I)((0,em.d)(this.m,i),o);e=this.useNesterov?(0,ep.I)((0,em.d)(this.c,(0,ep.I)(o,(0,em.d)(t,this.m))),r):(0,ep.I)((0,em.d)(this.c,t),r),i.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,ed.B9)(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class eL extends eA{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==r&&(this.epsilon=w.BV.backend.epsilon()),null==e)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=w.BV.registeredVariables[t];null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,ed.lu)(()=>(0,ew.P)(r).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedMeanSquares[n].variable,a=this.accumulatedMoments[n].variable;(0,ed.lu)(()=>{let e=(0,ep.I)((0,em.d)(o,this.decay),(0,em.d)((0,ey.h)(i),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,u=(0,ep.I)((0,em.d)(t,this.decay),(0,em.d)(i,1-this.decay)),s=(0,eg.h)((0,em.d)(i,this.learningRate),(0,eb._)((0,eD.l)(e,(0,ep.I)((0,ey.h)(u),this.epsilon)))),l=(0,ep.I)((0,em.d)(a,this.momentum),s);o.assign(e),t.assign(u),a.assign(l);let c=(0,eD.l)(r,l);r.assign(c)}else{let e=(0,ep.I)((0,em.d)(o,this.decay),(0,em.d)((0,ey.h)(i),1-this.decay)),t=(0,ep.I)((0,em.d)(a,this.momentum),(0,eg.h)((0,em.d)(i,this.learningRate),(0,eb._)((0,ep.I)(e,this.epsilon))));o.assign(e),a.assign(t);let n=(0,eD.l)(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,ed.B9)(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,ed.B9)(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&(0,ed.B9)(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}let eG=[eI,eN,eR,eC,eP,eL,eF];function eU(e){return new Promise(e=>setTimeout(e)).then(e)}class ez{constructor(e){if(!(0,x.OB)().getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ez.URL_SCHEME)&&(e=e.slice(ez.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=M.w.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=(0,$.Yd)(e,t),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await eU(()=>o.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await eU(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,$.Q)(e)}}}}ez.URL_SCHEME="downloads://";class eW{constructor(e){if(null==e||e.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),i=r.modelTopology;if(null==i){t(Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(null==r.weightsManifest){t(Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(0===this.weightsFiles.length){e({modelTopology:i});return}e((0,$.jN)(r,e=>this.loadWeights(e)))},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let r of e)t.push(...r.weights),n.push(...r.paths);let r=this.checkManifestAndWeightFiles(e);return Promise.all(n.map(e=>this.loadWeightsFile(e,r[e]))).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,r)=>{let i=new FileReader;i.onload=e=>{n(e.target.result)},i.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(e=>(0,$.EZ)(e.name)),r={};for(let i of e)i.paths.forEach(e=>{let i=(0,$.EZ)(e);if(-1!==t.indexOf(i))throw Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),-1===n.indexOf(i))throw Error(`Weight file with basename '${i}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function eq(e){return new eW(e)}function eK(e,t,n,r){var i,o;(0,G.hu)(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array"),i=n=null==n?0:n,o=r=null==r?1:r,(0,G.hu)(i>=0&&i<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${i}`),(0,G.hu)(o>=0&&o<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${o}`),(0,G.hu)(o>=i,()=>`startFraction must be no more than endFraction, but got startFraction ${i} and endFraction ${o}`);let a=0;return Promise.all(e.map(i=>(i.then(i=>(t(n+ ++a/e.length*(r-n)),i)),i)))}B.registerSaveRouter(e=>(0,x.OB)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ez.URL_SCHEME)?function(e="model"){return new ez(e)}(e.slice(ez.URL_SCHEME.length)):null);var eH=n(8123);async function ej(e,t){null==t&&(t={});let n=null==t.fetchFunc?(0,x.OB)().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),i=(null==t.onProgress?await Promise.all(r):await eK(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(i):await eK(i,t.onProgress,.5,1)}async function eX(e,t="",n,r){return eZ(e=>ej(e,{requestInit:r}))(e,t,n)}function eZ(e){return async(t,n="",r)=>{let i=t.map(()=>!1),o={},a=null!=r?r.map(()=>!1):[],u=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{let s="quantization"in e?e.quantization.dtype:e.dtype,l=eH.J[s]*G.NA(e.shape),c=()=>{i[t]=!0,null==o[t]&&(o[t]=[]),o[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach((t,n)=>{t===e.name&&(c(),a[n]=!0)}):c(),u.push(e.name),n+=l})}),!a.every(e=>e)){let e=r.filter((e,t)=>!a[t]);throw Error(`Could not find weights in manifest with names: ${e.join(", ")}. 
Manifest JSON has weights with names: ${u.join(", ")}.`)}let s=i.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];s.forEach(e=>{t[e].paths.forEach(e=>{let t=n+(n.endsWith("/")?"":"/")+e;l.push(t)})});let c=await e(l),h={},f=0;return s.forEach(e=>{let n=t[e].paths.length,r=new M.w(c.slice(f,f+n));o[e].forEach(e=>{let t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=(0,$.dI)(t,[e.manifestEntry]);for(let e in n)h[e]=n[e]}),f+=n}),h}}class eJ{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,G.hu)("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=(0,x.OB)().platform.fetch,(0,G.hu)(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&(0,G.hu)(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=(0,$.Yd)(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=M.w.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:(0,$.Q)(e),responses:[i]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let e;let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",Error(e)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return(0,$.jN)(e,e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=(0,$.hu)(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>(function(e,t){var n;let r;let i=null==t.fetchFunc?(0,x.OB)().platform.fetch:t.fetchFunc,o=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var a;o<e.length;){r||(r=(await i(e[o],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:s}=await r.read();if(u){o++,r=void 0,null===(a=t.onProgress)||void 0===a||a.call(t,o/e.length);continue}n.enqueue(s);return}n.close()}})})(t,this.loadOptions)})}async getWeightUrls(e){let[t,n]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(Array.isArray(this.path)?this.path[1]:this.path),r=this.weightPathPrefix||t,i=[],o=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(r+e+n);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){let t=await this.getWeightUrls(e);return[(0,$.hu)(e),await ej(t,this.loadOptions)]}}function eY(e){return null!=e.match(eJ.URL_SCHEME_REGEX)}eJ.URL_SCHEME_REGEX=/^https?:\/\//;let eQ=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc));else if(Array.isArray(e)?e.every(e=>eY(e)):eY(e))return e0(e,t);return null};function e0(e,t){return new eJ(e,t)}function e1(e,t){return e0(e,t)}B.registerSaveRouter(eQ),B.registerLoadRouter(eQ);class e2{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class e3{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class e4{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function e6(e,t,n,r){let i=arguments;return new e4(e5(...i))}function e5(e,t,n,r){return 1!=arguments.length?(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e2({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})):null!=e.modelTopology||null!=e.weightSpecs?new e2(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e2({modelTopology:e}))}function e7(e){return new e3(e)}function e8(e){return new e3(e)}var e9=n(971),te=n(5193),tt=n(8713),tn=n(2888),tr=n(5250);let ti=(0,tn.op)({confusionMatrix_:function(e,t,n){let r=(0,e9._1)(e,"labels","confusionMatrix"),i=(0,e9._1)(t,"predictions","confusionMatrix");G.hu(null==n||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),G.hu(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),G.hu(1===i.rank,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),G.hu(r.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),G.hu(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let o=(0,tt.l)((0,es.p)(r,"int32"),n),a=(0,tt.l)((0,es.p)(i,"int32"),n),u=(0,tr.p)(o),s=(0,te.O)(u,a);return(0,es.p)(s,"int32")}});var to=n(5221),ta=n(5047),tu=n(9922),ts=n(1051);let tl=!1;function tc(e,t=3){let n,r;if(t>4)throw Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let i=!1,a=!1,u=!1,s=!1,l=!1,c=!1;if(e.data instanceof Uint8Array)i=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)u=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)l=!0;else if("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)c=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(null!=(0,tu.pI)(ta.eBW,w.BV.backendName))return w.BV.runKernel(ta.eBW,{pixels:e},{numChannels:t});let[h,f]=u?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(l)n=e.getContext("2d").getImageData(0,0,h,f).data;else if(a||i)n=e.data;else if(s||u||c){if(null==o){if("undefined"==typeof document){if("undefined"!=typeof OffscreenCanvas&&"undefined"!=typeof OffscreenCanvasRenderingContext2D)o=new OffscreenCanvas(1,1).getContext("2d");else throw Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.")}else o=document.createElement("canvas").getContext("2d",{willReadFrequently:!0})}o.canvas.width=h,o.canvas.height=f,o.drawImage(e,0,0,h,f),n=o.getImageData(0,0,h,f).data}if(4===t)r=new Int32Array(n);else{let e=h*f;r=new Int32Array(e*t);for(let i=0;i<e;i++)for(let e=0;e<t;++e)r[i*t+e]=n[4*i+e]}let d=[f,h,t];return(0,ts.w)(r,d,"int32")}async function th(e,t=3){var n;let r=null;if((0,x.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&null!=(n=e)&&0!==n.width&&0!==n.height&&!(null!=e&&e.data instanceof Uint8Array)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}r=null!=t&&t.width===e.width&&t.height===e.height?t:e}else r=e;return tc(r,t)}function tf(e){if(2!==e.rank&&3!==e.rank)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function td(e,t){let n=(0,e9._1)(e,"img","toPixels");if(!(e instanceof eh.es)){let e=n;n=(0,es.p)(e,"int32"),e.dispose()}tf(n);let[r,i]=n.shape.slice(0,2),o=2===n.rank?1:n.shape[2],a=await n.data(),u="float32"===n.dtype?255:1,s=new Uint8ClampedArray(i*r*4);for(let e=0;e<r*i;++e){let t=[0,0,0,255];for(let r=0;r<o;r++){let i=a[e*o+r];if("float32"===n.dtype){if(i<0||i>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${i}.`)}else if("int32"===n.dtype&&(i<0||i>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${i}.`);1===o?(t[0]=i*u,t[1]=i*u,t[2]=i*u):t[r]=i*u}let r=4*e;s[r+0]=Math.round(t[0]),s[r+1]=Math.round(t[1]),s[r+2]=Math.round(t[2]),s[r+3]=Math.round(t[3])}if(null!=t){tl||null==(0,tu.pI)(ta.hGc,w.BV.backendName)||(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),tl=!0),t.width=i,t.height=r;let e=t.getContext("2d"),n=new ImageData(s,i,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),s}function tp(e,t,n){let r=(0,e9._1)(e,"img","draw");if(!(e instanceof eh.es)){let e=r;r=(0,es.p)(e,"int32"),e.dispose()}tf(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let i={image:r};w.BV.runKernel(ta.hGc,i,{canvas:t,options:n})}let tg=(0,tn.op)({fromPixels_:tc});function tm(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===(0,G.NA)(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let i=t.shape,o=i[i.length-1],a=1;for(let e=0;e<i.length-1;++e)a*=i[e];let u=e.shape,s=i.slice();s.pop();let l=1;for(let e=o;e<n;++e)l*=u[e],s.push(u[e]);let c=[...(0,G.e3)(e.shape).map(e=>e/l),1].slice(0,o);return[s,a,l,c]}var tb=n(8604);function ty(e,t,n){let r=e.shape.length;G.hu(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),G.hu(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)G.hu(t[i]+n[i]<=e.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${e.shape[i]})`)}function tw(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function tv(e,t,n){let r=[];for(let i=0;i<e.length;i++)r[i]=Math.ceil((t[i]-e[i])/n[i]);return r}function tk(e,t,n,r){let i=[...e];for(let e=i.length;e<r.length;e++)i.push(1);for(let e=0;e<n;e++)0===e?i[t]=1:(i.splice(t,0,1),i.pop());return i}function t_(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function tx(e,t,n,r,i,o,a,u,s){let l=e.length,c=Array(l),h=Array(l),f=Array(l);if(t.length&&n>0){let s=t[0],l=n+1;c=tE(a,s,l,r,e),h=tS(u,s,l,i,e),f=tk(o,s,l,e)}else for(let t=0;t<l;t++)c[t]=tB(a,r,o,e,t,s),h[t]=tA(u,i,o,e,t,s),f[t]=t$(o,t,s);return{begin:c,end:h,strides:f}}function tE(e,t,n,r,i){let o=[...i],a=t_(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=0;else{var u;let a=(u=i)<=t?u:u-(n-1),s=r[a];e&1<<a&&(s=0),o[i]=s}return o}function tS(e,t,n,r,i){let o=[...i],a=t_(n,t);for(let i=0;i<o.length;i++)if(a.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{var u;let a=(u=i)<=t?u:u-(n-1),s=r[a];e&1<<a&&(s=Number.MAX_SAFE_INTEGER),o[i]=s}for(let e=0;e<o.length;e++){let t=i[e];o[e]<0&&(o[e]+=t),o[e]=G.uZ(0,o[e],i[e])}return o}function t$(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function tB(e,t,n,r,i,o){let a=t[i],u=n[i]||1;(e&1<<i||o&1<<i||null==a)&&(a=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let s=r[i];return a<0&&(a+=s),a=G.uZ(0,a,s-1)}function tA(e,t,n,r,i,o){let a=t[i],u=n[i]||1;(e&1<<i||o&1<<i||null==a)&&(a=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let s=r[i];return a<0&&(a+=s),a=u>0?G.uZ(0,a,s):G.uZ(-1,a,s-1)}function tI(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function tT(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function tN(e,t,n){let r,i;let o=e.shape.length;return(r="number"==typeof t?[t,...Array(o-1).fill(0)]:t.length<o?t.concat(Array(o-t.length).fill(0)):t.slice()).forEach(e=>{G.hu(-1!==e,()=>"slice() does not support negative begin indexing.")}),i=(i=null==n?Array(o).fill(-1):"number"==typeof n?[n,...Array(o-1).fill(-1)]:n.length<o?n.concat(Array(o-n.length).fill(-1)):n).map((t,n)=>t>=0?t:(G.hu(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,i]}function tM(e,t,n,r,i,o,a,u,s){let l;if(null==r?(l=Array(t.length)).fill(1):l=r,null!=a&&(a&a-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let c=!1,h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:i,endMask:o,ellipsisMask:a,newAxisMask:u,shrinkAxisMask:s};for(let e=0;e<h.dims;e++)c&&(1<<e&u)!=0&&h.numAddAxisAfterEllipsis++,1<<e&a&&(c=!0);!c&&(h.ellipsisMask|=1<<h.dims,h.dims++);let f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=Array(t.dims),t.end=Array(t.dims),t.strides=Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let i=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,f);let d=!0,p=!0,g=!0,m=[],b=[];for(let t=0;t<e.length;++t){let n;if(0===f.strides[t])throw Error(`strides[${t}] must be non-zero`);let r=!!(f.shrinkAxisMask&1<<t),i=e[t];if(-1===i){m.push(r?1:-1);continue}let o=[f.beginMask&1<<t,f.endMask&1<<t],a=[f.strides[t]>0?0:-1,f.strides[t]>0?i:i-1];if(r&&f.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===f.strides[t];let u=!!(f.beginMask&1<<t&&f.endMask&1<<t);if(f.beginValid&&f.endValid){if(r){let e=f.begin[t]<0?i+f.begin[t]:f.begin[t];if(f.begin[t]=e,f.end[t]=f.begin[t]+1,e<0||e>=i)throw Error(`slice index ${f.begin[t]} of dimension ${t} out of bounds.`)}else f.begin[t]=tD(f.begin[t],0,f.strides[t],i,o,a),f.end[t]=tD(f.end[t],1,f.strides[t],i,o,a);let e=1===f.strides[t]&&0===f.begin[t]&&f.end[t]===i;d=d&&e,p=p&&(0===t&&1===f.strides[t]||e)}else d=d&&1===f.strides[t]&&u,p=p&&(0===t&&1===f.strides[t]||u);let s=!1;if(f.beginValid&&f.endValid?(n=f.end[t]-f.begin[t],s=!0):r?(n=1,s=!0):u&&i>=0&&(n=f.strides[t]<0?-i:i,s=!0),s){let e;e=0===n||n<0!=f.strides[t]<0?0:Math.trunc(n/f.strides[t])+(n%f.strides[t]!=0?1:0),m.push(e)}else m.push(-1)}for(let e=0;e<f.finalShapeGatherIndices.length;++e){let t=f.finalShapeGatherIndices[e];t>=0?b.push(m[t]):-2===t&&b.push(1)}return{finalShapeSparse:b.filter((e,t)=>-2!==f.finalShapeGatherIndices[t]),finalShape:b,isIdentity:d,sliceDim0:p,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function tD(e,t,n,r,i,o){if(i[t])return n>0?o[t]:o[t+1&1];{let t=e<0?r+e:e;return t<o[0]?o[0]:t>o[1]?o[1]:t}}var tR=n(5420),tV=n(2904);let tO=.1;function tC(e,t,n){return null==n&&(n=tF()),tP(e,t,(e,t)=>tz(e,t,n))}function tF(){return 32===w.BV.backend.floatPrecision()?.001:tO}function tP(e,t,n){let r=!0;if(((0,tV.isTypedArray)(e)||(0,tV.isTypedArray)(t))&&(r=!1),(0,tV.isTypedArray)(e)&&(0,tV.isTypedArray)(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=(0,e9.C)(e),r=(0,e9.C)(t);if(!(0,G.cO)(n,r))throw Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let i=(0,tV.isTypedArray)(e)?e:(0,tV.flatten)(e),o=(0,tV.isTypedArray)(t)?t:(0,tV.flatten)(t);if(i.length!==o.length)throw Error(`Arrays have different lengths actual: ${i.length} vs expected: ${o.length}.
Actual:   ${i}.
Expected: ${o}.`);for(let e=0;e<o.length;++e){let t=i[e],r=o[e];if(!n(t,r))throw Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.
Actual:   ${i}.
Expected: ${o}.`)}"undefined"!=typeof expect&&expect().nothing()}function tL(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function tG(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,G.HD)(e)||(0,G.HD)(e[0])||(0,G.HD)(t)||(0,G.HD)(t[0])?tP(e,n,(e,t)=>e==t):tP(e,t,(e,t)=>tz(e,t,0))}function tU(e,t,n){if(null==n&&(n=tF()),!tz(e,t,n))throw Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function tz(e,t,n){return!(isFinite(e)||isFinite(t))||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function tW(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function tq(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function tK(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function tH(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}let tj="4.22.0";class tX{static sgd(e){return new eF(e)}static momentum(e,t,n=!1){return new eP(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,i=!1){return new eL(e,t,n,r,i)}static adam(e=.001,t=.9,n=.999,r=null){return new eR(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new eI(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,i=0){return new eC(e,t,n,r,i)}static adagrad(e,t=.1){return new eN(e,t)}}var tZ=n(8638),tJ=n(570),tY=n(6405);let tQ=tX,t0="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function t1(){return new Promise(e=>t0(()=>e()))}var t2=n(7050);function t3(e,t){let n=e[0].length;e.forEach((e,t)=>{G.hu(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),G.hu(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((e,i)=>{for(let o=0;o<n;o++)G.hu(o===t||e[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function t4(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var t6=n(9011),t5=n(1575);function t7(e,t,n){let r=[];if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){let o=n[i],a=r[r.length-n.length+i],u=r[a];if(o>=0){if(u>=0){if(u!==o)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+e}] = ${o} but shape[${i+e}] = ${u}`)}else r[a]=o}}return r}function t8(e){let t={FIRST_DIM_SIZE:u.FIRST_DIM_SIZE,VALUE_ROWIDS:u.VALUE_ROWIDS,ROW_LENGTHS:u.ROW_LENGTHS,ROW_SPLITS:u.ROW_SPLITS,ROW_LIMITS:u.ROW_LIMITS,ROW_STARTS:u.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function t9(e){return 0===e.length?0:e[0]===u.FIRST_DIM_SIZE?e.length-1:e.length}function ne(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){let n=e[i],r=t[i+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-e.length}] = ${n} but ragged tensor input.flatValues.shape[${i-e.length}] = ${r}`)}}(a=u||(u={}))[a.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",a[a.VALUE_ROWIDS=1]="VALUE_ROWIDS",a[a.ROW_LENGTHS=2]="ROW_LENGTHS",a[a.ROW_SPLITS=3]="ROW_SPLITS",a[a.ROW_LIMITS=4]="ROW_LIMITS",a[a.ROW_STARTS=5]="ROW_STARTS";let nt=30;function nn(e){return e<=nt?e:(0,G.jP)(e,Math.floor(Math.sqrt(e)))}function nr(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function ni(e,t,n,r=!0){let i=[];if(r)(i=i.concat(t.slice(0))).push(e[0]/n),i=i.concat(e.slice(1));else{i=i.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)i=i.concat([e[r+1]/t[r],t[r]]);i=i.concat(e.slice(n+1))}return i}function no(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],i=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function na(e,t,n,r=!0){let i=[];r?i.push(e[0]/n):i.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?i.push(t[n-1]*e[n]):i.push(e[n]/t[n-1]):i.push(e[n]);return i}function nu(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function ns(e,t,n){let r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}let nl=1.7580993408473768,nc=1.0507009873554805,nh=.3275911,nf=.254829592,nd=-.284496736,np=1.421413741,ng=-1.453152027,nm=1.061405429;var nb=n(7177);function ny(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function nw(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function nv(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function nk(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function n_(e,t){return{real:e[2*t],imag:e[2*t+1]}}function nx(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function nE(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){let o=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:n,imag:r}}function nS(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}let n$=/->/g;function nB(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(n$,"").length)/2;if(n<1)throw Error("Equations without an arrow are not supported.");if(n>1)throw Error('Equation must contain exactly one arrow ("->").');let[r,i]=e.split("->");(0,G.hu)(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let o=r.split(","),a=o.length;if(t!==a)throw Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let u=[];for(let e=0;e<i.length;++e){let t=i[e];if(!o.some(e=>-1!==e.indexOf(t)))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===u.indexOf(t)&&u.push(t)}for(let e=0;e<r.length;++e){let t=r[e];-1===u.indexOf(t)&&","!==t&&u.push(t)}let s=Array(o.length);for(let e=0;e<a;++e){if(new Set(o[e].split("")).size!==o[e].length)throw Error(`Found duplicate axes in input component ${o[e]}. Support for duplicate axes in input is not implemented yet.`);s[e]=[];for(let t=0;t<o[e].length;++t)s[e].push(u.indexOf(o[e][t]))}let l=u.length,c=i.length,h=[];for(let e=c;e<l;++e)h.push(e);return{allDims:u,summedDims:h,idDims:s}}function nA(e,t){let n=Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;let r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return{permutationIndices:n=n.filter(e=>-1!==e),expandDims:r}}function nI(e,t,n){let r=Array(e);for(let e=0;e<n.length;++e){let i=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=i[n]:(0,G.hu)(r[t[e][n]]===i[n],()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(i)}, but got dimension ${i[n]}`)}}function nT(e,t){let n=[],r=0;0===e.length&&e.push(-1),r=e.length+1;for(let e=0;e<r;++e)n.push([]);let i=[];for(let r=0;r<e.length;++r)for(let o of function(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}(t,e[r]))-1===i.indexOf(o)&&(n[r].push(o),i.push(o));return{path:e,steps:n}}function nN(e){return e.every((e,t)=>e===t)}function nM(e,t,n=0){let r=[];if("number"==typeof t)(0,G.hu)(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=Array(t).fill(e.shape[n]/t);else{let i=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);(0,G.hu)(i<=1,()=>"There should be only one negative value in split array.");let o=t.indexOf(-1);if(-1!==o){let r=t.reduce((e,t)=>t>0?e+t:e);t[o]=e.shape[n]-r}(0,G.hu)(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function nD(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function nR(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function nV(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function nO(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function nC(e,t){return`size ${e} must be non-negative, not ${t}`}function nF(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function nP(e,t){let n=(0,G.NA)(e),r=(0,G.NA)(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function nL(e,t){let n=(0,G.NA)(e),r=(0,G.NA)(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function nG(){return"segment ids must be >= 0"}function nU(){return"segment ids are not increasing"}function nz(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function nW(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function nq(e,t){let n,r=!1;for(e<=nt?(n=e,r=!0):n=(0,G.jP)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=(0,G.jP)(e,n+1);return n}function nK(e,t,n){let r=[],i=e.length;for(let o=0;o<i;o++)o!==t?r.push(e[o]):r.push(n);return r}function nH(e,t,n,r){let i=t.shape.length,o=e.shape.length;if(0!==r&&(r<-i||r>i))throw Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>o)throw Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(n<r)throw Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);let a=e.shape[n],u=[],s=1,l=1,c=1;for(let t=0;t<r;++t)u.push(e.shape[t]),s*=e.shape[t];for(let t=r;t<n;t++)u.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<i;e++)u.push(t.shape[e]);for(let t=n+1;t<o;t++)u.push(e.shape[t]),c*=e.shape[t];return{batchSize:s,sliceSize:c,outerSize:l,dimSize:a,outputShape:u}}function nj(e){try{return e.map(e=>(0,tV.decodeString)(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function nX(e){return e.map(e=>(0,tV.encodeString)(e))}var nZ=n(3021),nJ=n(9846),nY=n(2975);!function(){for(let e of eG)e$(e)}()},807:function(e,t,n){"use strict";n.d(t,{w:function(){return i}});var r=n(2904);class i{static join(e){return new i(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>r.isTypedArray(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e))return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),i=new Uint8Array(r),o=0;for(let r=n;r<this.shards.length;r++){let n=this.shards[r],a=e+o-n.start,u=o,s=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,s-a);if(i.set(l,u),o+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let i=Math.floor((r-n)/2)+n,o=t(e[i]);if(0===o)return i;o<0?r=i:n=i+1}return -1}(this.shards,t);return -1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}},3850:function(e,t,n){"use strict";n.d(t,{EZ:function(){return _},JY:function(){return k},Q:function(){return $},Yd:function(){return x},_n:function(){return w},dI:function(){return f},hu:function(){return B},jN:function(){return S},ji:function(){return E},n7:function(){return v},r:function(){return m},yz:function(){return h}});var r=n(7977),i=n(1802),o=n(2771),a=n(8123),u=n(807),s=n(5823),l=n(6472),c=n(6434).Buffer;async function h(e,t){let n=[],r=[],i=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let o=0;o<i.length;++o){let a=i[o],u=Array.isArray(e)?e[o].tensor:e[a];if("float32"!==u.dtype&&"int32"!==u.dtype&&"bool"!==u.dtype&&"string"!==u.dtype&&"complex64"!==u.dtype)throw Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let s={name:a,shape:u.shape,dtype:u.dtype};if("string"===u.dtype){let e=new Promise(async e=>{let t=await u.bytes(),n=new Uint8Array(t.reduce((e,t)=>e+t.length,0)+4*t.length),r=0;for(let e=0;e<t.length;e++){let i=t[e],o=new Uint8Array(new Uint32Array([i.length]).buffer);n.set(o,r),r+=4,n.set(i,r),r+=i.length}e(n)});r.push(e)}else r.push(u.data());null!=t&&(s.group=t),n.push(s)}return{data:function(e){if(null===e)throw Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});let r=new Uint8Array(t),i=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),i),i+=e.byteLength}),r.buffer}(await Promise.all(r)),specs:n}}function f(e,t){let n=new u.w(e),r={},i=0;for(let e of t){let t=function(e,t){let n;let r=(0,o.NA)(e.shape);if("quantization"in e){let t=e.quantization;n=a.J[t.dtype]}else if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(t(e,e+4))[0];return e}else n=a.J[e.dtype];return r*n}(e,(e,t)=>n.slice(i+e,i+t));r[e.name]=p(e,n.slice(i,i+t)),i+=t}return r}async function d(e,t){let n;let r=(0,o.NA)(e.shape);if("quantization"in e){let t=e.quantization;n=a.J[t.dtype]}else if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=4+new Uint32Array(await t(e,e+4))[0];return e}else n=a.J[e.dtype];return r*n}function p(e,t){let n;let u=e.name,s=e.dtype,l=e.shape,c=(0,o.NA)(l),h=0;if("quantization"in e){let r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r&&"scale"in r))throw Error(`Weight ${e.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else if("float16"===r.dtype){if("float32"!==s)throw Error(`Weight ${e.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${s}.`)}else throw Error(`Weight ${e.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let i=a.J[r.dtype],o="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===s){if("uint8"===r.dtype||"uint16"===r.dtype){n=new Float32Array(o.length);for(let e=0;e<o.length;e++){let t=o[e];n[e]=t*r.scale+r.min}}else if("float16"===r.dtype)n=(function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;(8388608&t)==0;)n-=8388608,t<<=1;return(t&=-8388609)|(n+=947912704)},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let i=new ArrayBuffer(4*r.length),o=new Uint32Array(i);for(let i=0;i<r.length;i++){let a=r[i],u=e[n[a>>10]+(1023&a)]+t[a>>10];o[i]=u}return new Float32Array(i)}})()(o);else throw Error(`Unsupported quantization type ${r.dtype} for weight type float32.`)}else if("int32"===s){if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);n=new Int32Array(o.length);for(let e=0;e<o.length;e++){let t=o[e];n[e]=Math.round(t*r.scale+r.min)}}else throw Error(`Unsupported dtype in weight '${u}': ${s}`);h+=c*i}else if("string"===s){let r=(0,o.NA)(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(h,h+4))[0];h+=4;let r=new Uint8Array(t.slice(h,h+e));n.push(r),h+=e}}else{let e=a.J[s];if("float32"===s)n=new Float32Array(t);else if("int32"===s)n=new Int32Array(t);else if("bool"===s)n=new Uint8Array(t);else if("complex64"===s){n=new Float32Array(t);let e=new Float32Array(n.length/2),o=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],o[t]=n[2*t+1];let a=(0,i.X)(e,l,"float32"),u=(0,i.X)(o,l,"float32"),s=(0,r.P)(a,u);return a.dispose(),u.dispose(),s}else throw Error(`Unsupported dtype in weight '${u}': ${s}`);h+=c*e}return(0,i.X)(n,l,s)}async function g(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:i}=await e.read();if(t&&null==i){let e=n-r.byteLength;throw Error(`Reader is done but ${e} bytes are still expected`)}let o=new Uint8Array(r.length+i.byteLength);o.set(r,0),o.set(new Uint8Array(i),r.length),r=o}return r.buffer}async function m(e,t){let n={},r=e.getReader(),i=new ArrayBuffer(0);for(let e of t){let t=await d(e,async(e,t)=>(i=await g(r,i,t)).slice(e,t)),a=(i=await g(r,i,t)).slice(0,t);i=i.slice(t);let u=p(e,a);if(n[e.name]=u,"webgpu"===(0,s.N_)()){let e=(0,s.y3)();"uploadToGPU"in e&&(0,o.NA)(u.shape)>=(0,l.OB)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(u.dataId)}}return n}let b=void 0!==c&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function y(e){return b?c.byteLength(e,"utf8"):new Blob([e]).size}function w(e){if(b)return c.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}function v(e){if(b){let t=c.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}function k(e){return u.w.join(e)}function _(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function x(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function E(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function S(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),E(e,n,r)}function $(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:y(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:y(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new u.w(e.weightData).byteLength}}function B(e){let t=[];for(let n of e)t.push(...n.weights);return t}},8123:function(e,t,n){"use strict";n.d(t,{J:function(){return r}});let r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},5047:function(e,t,n){"use strict";n.d(t,{$HU:function(){return ts},$g6:function(){return et},$w:function(){return X},Acj:function(){return ey},BMI:function(){return eG},BiW:function(){return to},Byc:function(){return G},CAk:function(){return eB},CQl:function(){return ti},D2d:function(){return tP},DlI:function(){return tn},Eh3:function(){return M},FKq:function(){return tT},G3Y:function(){return tQ},GBy:function(){return tN},Gcp:function(){return tR},HEU:function(){return er},HZH:function(){return tc},Hhh:function(){return eF},Hmb:function(){return tf},IKK:function(){return l},IMb:function(){return v},J$2:function(){return eS},J7O:function(){return eP},J_u:function(){return ek},JhU:function(){return b},Kgp:function(){return e9},L8s:function(){return tD},Ly9:function(){return S},M2y:function(){return f},MIZ:function(){return tX},MRv:function(){return tI},MZg:function(){return eD},NEP:function(){return ea},NZg:function(){return eY},O3z:function(){return tV},OAf:function(){return eW},OR:function(){return ef},OU7:function(){return eq},OV7:function(){return ez},Omj:function(){return ei},Oyi:function(){return g},PYm:function(){return eN},PhF:function(){return t_},QCc:function(){return m},QRR:function(){return W},Qg5:function(){return ev},QiL:function(){return e7},Qvg:function(){return t2},RFZ:function(){return B},ROF:function(){return y},RQH:function(){return tS},RuY:function(){return t4},SIB:function(){return tv},SX0:function(){return en},SYM:function(){return r},SbG:function(){return tg},SpW:function(){return o},T0n:function(){return q},TQc:function(){return tM},TR1:function(){return L},ToN:function(){return t1},Tr8:function(){return tH},Uyb:function(){return eh},VGw:function(){return i},Vbg:function(){return eJ},VcC:function(){return z},VfG:function(){return eM},Vn9:function(){return Y},W0H:function(){return e4},XDQ:function(){return t3},XLW:function(){return k},XkS:function(){return tK},Xze:function(){return u},Y0y:function(){return es},YFo:function(){return eu},YoZ:function(){return eL},ZbH:function(){return eI},ZjV:function(){return tF},Zz9:function(){return T},_JP:function(){return tW},_V0:function(){return t9},_Yw:function(){return td},_k9:function(){return w},_tC:function(){return tL},a5O:function(){return tA},aJk:function(){return h},avt:function(){return e_},b9H:function(){return t7},bK0:function(){return tG},bV0:function(){return ty},c17:function(){return ej},cWu:function(){return tJ},cie:function(){return K},cye:function(){return e3},dDz:function(){return tr},deh:function(){return ec},dpD:function(){return th},e07:function(){return tb},e0R:function(){return tU},e6w:function(){return ta},e7N:function(){return eA},eBW:function(){return t5},eEB:function(){return $},eZ0:function(){return eC},ekb:function(){return J},gJX:function(){return A},h8e:function(){return t6},hCO:function(){return E},hGc:function(){return Q},hdR:function(){return eo},i5y:function(){return tB},iHb:function(){return U},iJz:function(){return ew},iWB:function(){return ex},iZT:function(){return eb},ik2:function(){return F},jMg:function(){return p},jQk:function(){return tz},jQs:function(){return eZ},jeX:function(){return ed},kU:function(){return eT},kpP:function(){return t0},kuV:function(){return e0},luS:function(){return ne},lyA:function(){return e8},mKl:function(){return tm},mTV:function(){return eU},mc4:function(){return P},mhS:function(){return D},mm_:function(){return a},n9L:function(){return tZ},nhH:function(){return tO},nr8:function(){return tk},o0g:function(){return tt},o2y:function(){return C},oFR:function(){return tx},oHH:function(){return ee},oT6:function(){return s},p2w:function(){return tE},p4S:function(){return Z},pe_:function(){return te},q1x:function(){return em},q2K:function(){return eH},q8u:function(){return eX},qCd:function(){return eV},qIC:function(){return eO},qWM:function(){return e6},qi_:function(){return eg},qkr:function(){return tl},qw7:function(){return d},r7n:function(){return eE},s1s:function(){return tq},sEM:function(){return tj},sHE:function(){return ep},sJF:function(){return c},sL$:function(){return H},usg:function(){return t8},uv1:function(){return e2},vFR:function(){return eK},vtC:function(){return e$},vwp:function(){return el},w3H:function(){return tC},w6g:function(){return eR},wUP:function(){return R},wYB:function(){return t$},wYn:function(){return eQ},we_:function(){return e5},wm:function(){return V},wx7:function(){return tY},x12:function(){return O},xJR:function(){return tu},xQA:function(){return tw},xnO:function(){return I},y7R:function(){return j},yQU:function(){return e1},yj2:function(){return N},zbQ:function(){return tp},zvY:function(){return x},zws:function(){return _}});let r="Abs",i="Acos",o="Acosh",a="Add",u="AddN",s="All",l="Any",c="ArgMax",h="ArgMin",f="Asin",d="Asinh",p="Atan",g="Atanh",m="Atan2",b="AvgPool",y="AvgPoolGrad",w="AvgPool3D",v="AvgPool3DGrad",k="BatchMatMul",_="BatchToSpaceND",x="Bincount",E="BitwiseAnd",S="BroadcastTo",$="BroadcastArgs",B="Cast",A="Ceil",I="ClipByValue",T="Complex",N="ComplexAbs",M="Concat",D="Conv2D",R="Conv2DBackpropFilter",V="Conv2DBackpropInput",O="Conv3D",C="Conv3DBackpropFilterV2",F="Conv3DBackpropInputV2",P="Cos",L="Cosh",G="Cumprod",U="Cumsum",z="CropAndResize",W="DenseBincount",q="DepthToSpace",K="DepthwiseConv2dNative",H="DepthwiseConv2dNativeBackpropFilter",j="DepthwiseConv2dNativeBackpropInput",X="Diag",Z="Dilation2D",J="Dilation2DBackpropInput",Y="Dilation2DBackpropFilter",Q="Draw",ee="RealDiv",et="Einsum",en="Elu",er="EluGrad",ei="Erf",eo="Equal",ea="Exp",eu="ExpandDims",es="Expm1",el="FFT",ec="Fill",eh="FlipLeftRight",ef="Floor",ed="FloorDiv",ep="FusedBatchNorm",eg="GatherV2",em="GatherNd",eb="Greater",ey="GreaterEqual",ew="Identity",ev="IFFT",ek="Imag",e_="IsFinite",ex="IsInf",eE="IsNan",eS="LeakyRelu",e$="Less",eB="LessEqual",eA="LinSpace",eI="Log",eT="Log1p",eN="LogicalAnd",eM="LogicalNot",eD="LogicalOr",eR="LogicalXor",eV="LogSoftmax",eO="LowerBound",eC="LRN",eF="LRNGrad",eP="MatrixBandPart",eL="Max",eG="Maximum",eU="MaxPool",ez="MaxPoolGrad",eW="MaxPool3D",eq="MaxPool3DGrad",eK="MaxPoolWithArgmax",eH="Mean",ej="Min",eX="Minimum",eZ="MirrorPad",eJ="Mod",eY="Multinomial",eQ="Multiply",e0="Neg",e1="NotEqual",e2="NonMaxSuppressionV3",e3="NonMaxSuppressionV4",e4="NonMaxSuppressionV5",e6="OnesLike",e5="OneHot",e7="Pack",e8="PadV2",e9="Pool",te="Pow",tt="Prelu",tn="Prod",tr="RaggedGather",ti="RaggedRange",to="RaggedTensorToTensor",ta="Range",tu="Real",ts="Reciprocal",tl="Relu",tc="Reshape",th="ResizeNearestNeighbor",tf="ResizeNearestNeighborGrad",td="ResizeBilinear",tp="ResizeBilinearGrad",tg="Relu6",tm="Reverse",tb="Round",ty="Rsqrt",tw="ScatterNd",tv="TensorScatterUpdate",tk="SearchSorted",t_="Select",tx="Selu",tE="Slice",tS="Sin",t$="Sinh",tB="Sign",tA="Sigmoid",tI="Softplus",tT="Sqrt",tN="Sum",tM="SpaceToBatchND",tD="SplitV",tR="Softmax",tV="SparseFillEmptyRows",tO="SparseReshape",tC="SparseSegmentMean",tF="SparseSegmentSum",tP="SparseToDense",tL="SquaredDifference",tG="Square",tU="StaticRegexReplace",tz="StridedSlice",tW="StringNGrams",tq="StringSplit",tK="StringToHashBucketFast",tH="Sub",tj="Tan",tX="Tanh",tZ="Tile",tJ="TopK",tY="Transform",tQ="Transpose",t0="Unique",t1="Unpack",t2="UnsortedSegmentSum",t3="UpperBound",t4="ZerosLike",t6="Step",t5="FromPixels",t7="RotateWithOffset",t8="_FusedMatMul",t9="FusedConv2D",ne="FusedDepthwiseConv2D"},9922:function(e,t,n){"use strict";n.d(t,{Li:function(){return f},T3:function(){return g},bt:function(){return p},nE:function(){return d},pI:function(){return s},tr:function(){return c},uk:function(){return l},wC:function(){return h}});var r=n(6472),i=n(5490),o=n(7177);let a=(0,i.R)("kernelRegistry",()=>new Map),u=(0,i.R)("gradRegistry",()=>new Map);function s(e,t){let n=m(e,t);return a.get(n)}function l(e){return u.get(e)}function c(e){let t=a.entries(),n=[];for(;;){let{done:r,value:i}=t.next();if(r)break;let[o,a]=i,[u]=o.split("_");u===e&&n.push(a)}return n}function h(e){let{kernelName:t,backendName:n}=e,r=m(t,n);a.has(r)&&o.Z(`The kernel '${t}' for backend '${n}' is already registered`),a.set(r,e)}function f(e){let{kernelName:t}=e;u.has(t)&&(0,r.OB)().getBool("DEBUG")&&o.Z(`Overriding the gradient for '${t}'`),u.set(t,e)}function d(e,t){let n=m(e,t);if(!a.has(n))throw Error(`The kernel '${e}' for backend '${t}' is not registered`);a.delete(n)}function p(e){if(!u.has(e))throw Error(`The gradient '${e}' for backend is not registered`);u.delete(e)}function g(e,t){c(e).forEach(e=>{h(Object.assign({},e,{backendName:t}))})}function m(e,t){return`${t}_${e}`}},7177:function(e,t,n){"use strict";n.d(t,{Z:function(){return i},c:function(){return o}});var r=n(6472);function i(...e){(0,r.OB)().getBool("IS_TEST")||(0,r.OB)().getBool("PROD")||console.warn(...e)}function o(...e){(0,r.OB)().getBool("IS_TEST")||(0,r.OB)().getBool("PROD")||console.log(...e)}},9044:function(e,t,n){"use strict";n.d(t,{W:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({abs_:function(e){let t=(0,o._1)(e,"x","abs");return"complex64"===t.dtype?r.BV.runKernel(i.yj2,{x:t}):r.BV.runKernel(i.SYM,{x:t})}})},3266:function(e,t,n){"use strict";n.d(t,{I:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({add_:function(e,t){let n=(0,a._1)(e,"a","add"),u=(0,a._1)(t,"b","add");[n,u]=(0,o.makeTypesMatch)(n,u);let s={a:n,b:u};return r.BV.runKernel(i.mm_,s)}})},7050:function(e,t,n){"use strict";n.d(t,{LJ:function(){return c},Q3:function(){return l},Vh:function(){return o},YB:function(){return i},kz:function(){return a},lB:function(){return s},rv:function(){return u},sY:function(){return h}});var r=n(2771);function i(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function o(e,t,n){let r=e.length+t.length,i=[],o=0,a=0;for(let u=0;u<r;u++)-1===n.indexOf(u)?i.push(e[o++]):i.push(t[a++]);return i}function a(e,t){let n=[],r=e.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&n.push(e[i]);return[n,t.map(t=>e[t])]}function u(e,t){return o(e,t.map(e=>1),t)}function s(e,t,n){r.hu(i(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function l(e,t){if(i(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function c(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function h(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},5221:function(e,t,n){"use strict";function r(e,t){let n=e.length,r=[];for(let i=0;i<n;i++){let o=n-1-i,a=e[o]||1;(t[t.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}function i(e,t){let n=[];for(let r=0;r<t.length;r++){let i=e[e.length-r-1],o=t.length-r-1,a=t[o];(null==i||1===i&&a>1)&&n.unshift(o)}return n}function o(e,t){let n=Math.max(e.length,t.length),r=Array(n);for(let i=0;i<n;i++){let o=e[e.length-i-1];null==o&&(o=1);let a=t[t.length-i-1];if(null==a&&(a=1),1===o)r[n-i-1]=a;else if(1===a)r[n-i-1]=o;else if(o!==a)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);else r[n-i-1]=o}return r}n.r(t),n.d(t,{assertAndGetBroadcastShape:function(){return o},getBroadcastDims:function(){return r},getReductionAxes:function(){return i}})},5515:function(e,t,n){"use strict";n.d(t,{f:function(){return o}});var r=n(6150),i=n(2771);function o(e,t="float32",n){return t=t||"float32",i.Mu(e),new r.YD(e,t,n)}},8893:function(e,t,n){"use strict";n.d(t,{p:function(){return u}});var r=n(9681),i=n(5047),o=n(971),a=n(2771);let u=(0,n(2888).op)({cast_:function(e,t){let n=(0,o._1)(e,"x","cast");if(!a.LP(t))throw Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw Error("Only strings can be casted to strings");return r.BV.runKernel(i.RFZ,{x:n},{dtype:t})}})},699:function(e,t,n){"use strict";n.d(t,{d:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({clone_:function(e){let t=(0,o._1)(e,"x","clone","string_or_numeric");return r.BV.runKernel(i.iJz,{x:t})}})},7977:function(e,t,n){"use strict";n.d(t,{P:function(){return u}});var r=n(9681),i=n(5047),o=n(971),a=n(2771);let u=(0,n(2888).op)({complex_:function(e,t){let n=(0,o._1)(e,"real","complex"),u=(0,o._1)(t,"imag","complex");return a.k5(n.shape,u.shape,`real and imag shapes, ${n.shape} and ${u.shape}, must match in call to tf.complex().`),r.BV.runKernel(i.Zz9,{real:n,imag:u})}})},9011:function(e,t,n){"use strict";n.d(t,{I0:function(){return p},Ix:function(){return u},Rf:function(){return i},U3:function(){return m},Xw:function(){return o},aO:function(){return l},jT:function(){return g},jw:function(){return s},m:function(){return y},pl:function(){return a},sl:function(){return b}});var r=n(2771);function i(e,t,n,r,i="NHWC",o){let a=[...t,e[3]];return u(e,a,n,o,r,null,null,b(i))}function o(e,t,n,r,i,o,a="channelsLast"){let s;let[l,h]=c(t);if("channelsLast"===a)s=[l,h,e[3],e[3]];else if("channelsFirst"===a)s=[l,h,e[1],e[1]];else throw Error(`Unknown dataFormat ${a}`);return u(e,s,n,r,i,o,!1,a)}function a(e,t,n,r,i,o,a="NDHWC"){let u,l;let[c,f,d]=h(t);if("NDHWC"===a)l="channelsLast",u=[c,f,d,e[4],e[4]];else if("NCDHW"===a)l="channelsFirst",u=[c,f,d,e[1],e[1]];else throw Error(`Unknown dataFormat ${a}`);return s(e,u,n,r,i,!1,l,o)}function u(e,t,n,r,i,o,a=!1,u="channelsLast"){let s,[h,p,g,m]=[-1,-1,-1,-1];if("channelsLast"===u)[h,p,g,m]=e;else if("channelsFirst"===u)[h,m,p,g]=e;else throw Error(`Unknown dataFormat ${u}`);let[b,y,,w]=t,[v,k]=c(n),[_,x]=c(r),E=f(b,_),S=f(y,x),{padInfo:$,outHeight:B,outWidth:A}=function(e,t,n,r,i,o,a,u,s){let c,h,f;if("number"==typeof e){let i=0===e?"VALID":"NUMBER";c={top:e,bottom:e,left:e,right:e,type:i};let a=function(e,t,n,r,i){null==r&&(r=l(e,t,n));let o=e[0],a=e[1];return[d((o-t+2*r)/n+1,i),d((a-t+2*r)/n+1,i)]}([t,n],o,r,e,u);h=a[0],f=a[1]}else if("same"===e){let e=Math.max(0,((h=Math.ceil(t/r))-1)*r+o-t),u=Math.max(0,((f=Math.ceil(n/i))-1)*i+a-n),s=Math.floor(e/2),l=Math.floor(u/2);c={top:s,bottom:e-s,left:l,right:u-l,type:"SAME"}}else if("valid"===e)c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-o+1)/r),f=Math.ceil((n-a+1)/i);else if("object"==typeof e){let l="channelsLast"===s?e[1][0]:e[2][0],p="channelsLast"===s?e[1][1]:e[2][1],g="channelsLast"===s?e[2][0]:e[3][0],m="channelsLast"===s?e[2][1]:e[3][1];c={top:l,bottom:p,left:g,right:m,type:0===l&&0===p&&0===g&&0===m?"VALID":"EXPLICIT"},h=d((t-o+l+p)/r+1,u),f=d((n-a+g+m)/i+1,u)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:c,outHeight:h,outWidth:f}}(i,p,g,v,k,E,S,o,u),I=a?w*m:w;return"channelsFirst"===u?s=[h,I,B,A]:"channelsLast"===u&&(s=[h,B,A,I]),{batchSize:h,dataFormat:u,inHeight:p,inWidth:g,inChannels:m,outHeight:B,outWidth:A,outChannels:I,padInfo:$,strideHeight:v,strideWidth:k,filterHeight:b,filterWidth:y,effectiveFilterHeight:E,effectiveFilterWidth:S,dilationHeight:_,dilationWidth:x,inShape:e,outShape:s,filterShape:t}}function s(e,t,n,r,i,o=!1,a="channelsLast",u){let s,[c,p,g,m,b]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[c,p,g,m,b]=e;else if("channelsFirst"===a)[c,b,p,g,m]=e;else throw Error(`Unknown dataFormat ${a}`);let[y,w,v,,k]=t,[_,x,E]=h(n),[S,$,B]=h(r),A=f(y,S),I=f(w,$),T=f(v,B),{padInfo:N,outDepth:M,outHeight:D,outWidth:R}=function(e,t,n,r,i,o,a,u,s,c,h){let f,p,g,m;if("valid"===e&&(e=0),"number"==typeof e){let b=0===e?"VALID":"NUMBER";f={top:e,bottom:e,left:e,right:e,front:e,back:e,type:b};let y=function(e,t,n,r,i,o){null==i&&(i=l(e,t[0],r[0]));let a=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*i>=t[n]&&(a[n]=d((e[n]-t[n]+2*i)/r[n]+1,o));return a}([t,n,r,1],[u,s,c],0,[i,o,a],e,h);p=y[0],g=y[1],m=y[2]}else if("same"===e){let e=((p=Math.ceil(t/i))-1)*i+u-t,l=((g=Math.ceil(n/o))-1)*o+s-n,h=((m=Math.ceil(r/a))-1)*a+c-r,d=Math.floor(e/2),b=Math.floor(l/2),y=Math.floor(h/2);f={top:b,bottom:l-b,left:y,right:h-y,front:d,back:e-d,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:p,outHeight:g,outWidth:m}}(i,p,g,m,_,x,E,A,I,T,u),V=o?k*b:k;return"channelsFirst"===a?s=[c,V,M,D,R]:"channelsLast"===a&&(s=[c,M,D,R,V]),{batchSize:c,dataFormat:a,inDepth:p,inHeight:g,inWidth:m,inChannels:b,outDepth:M,outHeight:D,outWidth:R,outChannels:V,padInfo:N,strideDepth:_,strideHeight:x,strideWidth:E,filterDepth:y,filterHeight:w,filterWidth:v,effectiveFilterDepth:A,effectiveFilterHeight:I,effectiveFilterWidth:T,dilationDepth:S,dilationHeight:$,dilationWidth:B,inShape:e,outShape:s,filterShape:t}}function l(e,t,n,r=1){let i=f(t,r);return Math.floor((e[0]*(n-1)-n+i)/2)}function c(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function h(e){return"number"==typeof e?[e,e,e]:e}function f(e,t){return t<=1?e:e+(e-1)*(t-1)}function d(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function p(e){let[t,n,r]=c(e);return 1===t&&1===n&&1===r}function g(e,t){return p(e)||p(t)}function m(e){return c(e).every(e=>e>0)}function b(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw Error(`Unknown dataFormat ${e}`)}function y(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)r.hu(r.GN(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if("object"==typeof t)t.forEach(t=>{t.forEach(t=>{r.hu(r.GN(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}},3511:function(e,t,n){"use strict";n.d(t,{h:function(){return s}});var r=n(9681),i=n(5047),o=n(5420),a=n(971),u=n(7576);let s=(0,n(2888).op)({div_:function(e,t){let n=(0,a._1)(e,"a","div"),s=(0,a._1)(t,"b","div");if([n,s]=(0,o.makeTypesMatch)(n,s),"int32"===n.dtype&&"int32"===s.dtype)return(0,u.q)(n,s);let l={a:n,b:s};return r.BV.runKernel(i.oHH,l,{})}})},4077:function(e,t,n){"use strict";n.d(t,{p:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({elu_:function(e){let t=(0,o._1)(e,"x","elu","float32");return r.BV.runKernel(i.SX0,{x:t})}})},180:function(e,t,n){"use strict";n.d(t,{h:function(){return a}});var r=n(9681),i=n(5047),o=n(2771);function a(e,t,n){(0,o.Mu)(e),n=n||(0,o.D2)(t);let a={shape:e,value:t,dtype:n};return r.BV.runKernel(i.deh,{},a)}},7576:function(e,t,n){"use strict";n.d(t,{q:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({floorDiv_:function(e,t){let n=(0,a._1)(e,"a","floorDiv"),u=(0,a._1)(t,"b","floorDiv");[n,u]=(0,o.makeTypesMatch)(n,u);let s={a:n,b:u};return r.BV.runKernel(i.jeX,s)}})},1575:function(e,t,n){"use strict";n.d(t,{Fr:function(){return p},QH:function(){return m},pf:function(){return g},uy:function(){return b}});var r=n(5221),i=n(4077),o=n(6437),a=n(5314),u=n(9427),s=n(114),l=n(6762),c=n(6439),h=n(5986),f=n(9794),d=n(1101);function p(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,a.d)(e,(0,f.N)(t));throw Error(`Cannot compute gradient for fused activation ${n}.`)}function g(e,t){let n=t,i=r.getReductionAxes(e.shape,t.shape);return i.length>0&&(n=(0,d.S)(n,i)),(0,c.X)(n,e.shape)}function m(e,t,n,r){if("linear"===t)return e;if("relu"===t)return(0,s.U)(e);if("elu"===t)return(0,i.p)(e);if("relu6"===t)return(0,l.b)(e);if("prelu"===t)return(0,u.A)(e,n);if("leakyrelu"===t)return(0,o.h)(e,r);if("sigmoid"===t)return(0,h.X)(e);throw Error(`Unknown fused activation ${t}.`)}let b=(e,t)=>!(e>0)||"linear"===t},8587:function(e,t,n){"use strict";n.d(t,{a:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({imag_:function(e){let t=(0,o._1)(e,"input","imag");return r.BV.runKernel(i.J_u,{input:t})}})},6437:function(e,t,n){"use strict";n.d(t,{h:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({leakyRelu_:function(e,t=.2){let n=(0,o._1)(e,"x","leakyRelu");return r.BV.runKernel(i.J$2,{x:n},{alpha:t})}})},6405:function(e,t,n){"use strict";var r,i;n.d(t,{I:function(){return r}}),(i=r||(r={}))[i.NONE=0]="NONE",i[i.MEAN=1]="MEAN",i[i.SUM=2]="SUM",i[i.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"},5193:function(e,t,n){"use strict";n.d(t,{O:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({matMul_:function(e,t,n=!1,u=!1){let s=(0,a._1)(e,"a","matMul"),l=(0,a._1)(t,"b","matMul");[s,l]=(0,o.makeTypesMatch)(s,l);let c={a:s,b:l};return r.BV.runKernel(i.XLW,c,{transposeA:n,transposeB:u})}})},2673:function(e,t,n){"use strict";n.d(t,{g:function(){return l}});var r=n(9681),i=n(5047),o=n(5420),a=n(971),u=n(5221),s=n(8893);let l=(0,n(2888).op)({maximum_:function(e,t){let n=(0,a._1)(e,"a","maximum"),l=(0,a._1)(t,"b","maximum");[n,l]=(0,o.makeTypesMatch)(n,l),"bool"===n.dtype&&(n=(0,s.p)(n,"int32"),l=(0,s.p)(l,"int32")),(0,u.assertAndGetBroadcastShape)(n.shape,l.shape);let c={a:n,b:l};return r.BV.runKernel(i.BMI,c)}})},5314:function(e,t,n){"use strict";n.d(t,{d:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({mul_:function(e,t){let n=(0,a._1)(e,"a","mul"),u=(0,a._1)(t,"b","mul");[n,u]=(0,o.makeTypesMatch)(n,u);let s={a:n,b:u};return r.BV.runKernel(i.wYn,s)}})},2666:function(e,t,n){"use strict";n.d(t,{W:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({neg_:function(e){let t=(0,o._1)(e,"x","neg");return r.BV.runKernel(i.kuV,{x:t})}})},8713:function(e,t,n){"use strict";n.d(t,{l:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({oneHot_:function(e,t,n=1,a=0,u="int32"){if(t<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s=(0,o._1)(e,"indices","oneHot","int32");return r.BV.runKernel(i.we_,{indices:s},{dtype:u,depth:t,onValue:n,offValue:a})}})},2888:function(e,t,n){"use strict";n.d(t,{op:function(){return a},z:function(){return o}});var r=n(9681),i=n(2771);let o="__op";function a(e){let t=Object.keys(e);if(1!==t.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1));let u=(...e)=>{r.BV.startScope(n);try{let t=a(...e);return(0,i.tI)(t)&&console.error("Cannot return a Promise inside of tidy."),r.BV.endScope(t),t}catch(e){throw r.BV.endScope(null),e}};return Object.defineProperty(u,"name",{value:n+=o,configurable:!0}),u}},570:function(e,t,n){"use strict";n.d(t,{zvA:function(){return s.z},WnP:function(){return i.W},Khb:function(){return l},__u:function(){return c},IHx:function(){return h.I},QBD:function(){return d},$6P:function(){return p},YjB:function(){return g},NqF:function(){return m},vHJ:function(){return b},ZRM:function(){return y},VfV:function(){return w},z4N:function(){return v},fvJ:function(){return _},C80:function(){return x},wS1:function(){return B},uR5:function(){return A},zEQ:function(){return O},tgs:function(){return F},Dxk:function(){return P},JY5:function(){return L},p3b:function(){return G},E4h:function(){return C},yE8:function(){return U},ycw:function(){return z},anm:function(){return nP},XsQ:function(){return W},UFq:function(){return q},f3b:function(){return K.f},pju:function(){return E.p},mDi:function(){return H},iUl:function(){return X},d9v:function(){return I.d},PYB:function(){return Z.P},zoF:function(){return T},gME:function(){return J},Izb:function(){return Y},MNy:function(){return Q},ZaL:function(){return ee},PAt:function(){return en},Tek:function(){return et},bc:function(){return ei},pdZ:function(){return eo},$QV:function(){return eu},mCk:function(){return es},f9Y:function(){return el},mew:function(){return nH},$Gn:function(){return ec},zbp:function(){return eh},ppE:function(){return ef},nTT:function(){return ed},B10:function(){return ep},Ka3:function(){return eg},WmZ:function(){return em},hiC:function(){return eb.h},NTj:function(){return e_},AKD:function(){return ex},rvX:function(){return nq},WYO:function(){return eE},pyx:function(){return eS.p},GRh:function(){return nK},EDe:function(){return e$},DgJ:function(){return ew},qNN:function(){return eB},d2q:function(){return eC},Qqt:function(){return eF},dt4:function(){return eP},t$B:function(){return eL},iyy:function(){return eU},kp_:function(){return nl},hlL:function(){return j.h},GWj:function(){return ez},qPi:function(){return eW.q},imm:function(){return r},Iqj:function(){return eq},dbB:function(){return nW},pjt:function(){return eK},brS:function(){return eH},Sxn:function(){return nc},asL:function(){return ej.a},BHj:function(){return rF},V3u:function(){return nj},wx0:function(){return nh},xVT:function(){return eX},UWc:function(){return eZ},i2d:function(){return eJ},hi7:function(){return eY.h},d9m:function(){return eQ},zN1:function(){return e0},$r2:function(){return rP},SX3:function(){return e1},G9k:function(){return e2},cM7:function(){return e3},Krr:function(){return e4},e_t:function(){return e8},CmS:function(){return te},l_t:function(){return tt},HvI:function(){return tn},hJK:function(){return tr},K5V:function(){return ti},egP:function(){return to},MB5:function(){return rL},eab:function(){return tu},OI3:function(){return N.O},Fp7:function(){return eI},_sB:function(){return ts},YQQ:function(){return tl},Ip$:function(){return tc},gWQ:function(){return th.g},J69:function(){return tf},ry_:function(){return tm},VV$:function(){return eT},LTh:function(){return tb},VdP:function(){return ty},wQq:function(){return tw},Gi7:function(){return tv},p_:function(){return nG},dC7:function(){return M.d},rq4:function(){return tk},SJ_:function(){return t_},W76:function(){return e5.W},KOy:function(){return eO},Quu:function(){return tx},lfX:function(){return tE.l},iUs:function(){return tp},JpU:function(){return tS},op:function(){return s.op},N2O:function(){return t$},vku:function(){return tB},pNR:function(){return tA},koy:function(){return tI},t1L:function(){return tT},lGY:function(){return tN},d_R:function(){return tD},sQ3:function(){return eN.s},AL3:function(){return tR.A},S0v:function(){return tV.S},WVs:function(){return tO},$gW:function(){return tC},VT$:function(){return tF},N89:function(){return tP},TN_:function(){return tL},wzB:function(){return tq},nGf:function(){return tK},ruB:function(){return tH},LGj:function(){return tj},pe5:function(){return tX},w6H:function(){return tZ},kwC:function(){return tJ.k},M25:function(){return tY},UYe:function(){return tQ.U},btT:function(){return t0.b},XLQ:function(){return $.X},GYS:function(){return t1},SDf:function(){return t2},diP:function(){return t3},sx7:function(){return t4},mG2:function(){return t6},QEs:function(){return nd},NMM:function(){return t5},bp0:function(){return t7},iD$:function(){return eM.i},snQ:function(){return nU},zcT:function(){return ta},U8D:function(){return t8},U_I:function(){return t9},ODp:function(){return ne},XD2:function(){return D.X},Xxe:function(){return nt},tdS:function(){return rC},O$l:function(){return nn},R_K:function(){return nr},tPi:function(){return R},jZU:function(){return ni},SmN:function(){return no},CnO:function(){return na},p0P:function(){return nu},XAC:function(){return ns},Wvh:function(){return e7},fBT:function(){return tM},rVs:function(){return rG},ers:function(){return nz},uN7:function(){return rO},Vl2:function(){return nf},_b3:function(){return eD._},h62:function(){return eR.h},$i:function(){return np},L9e:function(){return ng},knu:function(){return nm},Nbs:function(){return nb.N},NXj:function(){return ny},Z_8:function(){return rU},luU:function(){return e9.l},Smz:function(){return eV.S},ORZ:function(){return nw},AEp:function(){return V},XeE:function(){return nv.X},RRF:function(){return n_},odF:function(){return nx},wOQ:function(){return nE.w},yXz:function(){return nS},Bfx:function(){return n$},xZs:function(){return nB},Pg0:function(){return nI},Gg6:function(){return eG},hg7:function(){return nT},p4s:function(){return nL.p},Xu6:function(){return nN},Two:function(){return nM},pUJ:function(){return nD},HHK:function(){return nR},GaM:function(){return nV},VD$:function(){return nO},arb:function(){return ev},itS:function(){return nF},lls:function(){return td},P84:function(){return ek.P}});var r={};n.r(r),n.d(r,{conv2d:function(){return nJ},depthwiseConv2d:function(){return n0},matMul:function(){return n1}});var i=n(9044),o=n(9681),a=n(5047),u=n(971),s=n(2888);let l=(0,s.op)({acos_:function(e){let t=(0,u._1)(e,"x","acos");return o.BV.runKernel(a.VGw,{x:t})}}),c=(0,s.op)({acosh_:function(e){let t=(0,u._1)(e,"x","acosh");return o.BV.runKernel(a.SpW,{x:t})}});var h=n(3266),f=n(2771);let d=(0,s.op)({addN_:function(e){f.hu(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),f.hu(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((e,t)=>(0,u._1)(e,`tensors${t}`,"addN")),n=t[0];return t.forEach(e=>{if(e.dtype!==n.dtype)throw Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!f.cO(e.shape,n.shape))throw Error("All tensors passed to tf.addN() must have the same shape")}),o.BV.runKernel(a.Xze,t)}}),p=(0,s.op)({all_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","all","bool");return o.BV.runKernel(a.oT6,{x:r},{axis:t,keepDims:n})}}),g=(0,s.op)({any_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","any","bool");return o.BV.runKernel(a.IKK,{x:r},{axis:t,keepDims:n})}}),m=(0,s.op)({argMax_:function(e,t=0){let n=(0,u._1)(e,"x","argMax");return o.BV.runKernel(a.sJF,{x:n},{axis:t})}}),b=(0,s.op)({argMin_:function(e,t=0){let n=(0,u._1)(e,"x","argMin");return o.BV.runKernel(a.aJk,{x:n},{axis:t})}}),y=(0,s.op)({asin_:function(e){let t=(0,u._1)(e,"x","asin");return o.BV.runKernel(a.M2y,{x:t})}}),w=(0,s.op)({asinh_:function(e){let t=(0,u._1)(e,"x","asinh");return o.BV.runKernel(a.qw7,{x:t})}}),v=(0,s.op)({atan_:function(e){let t=(0,u._1)(e,"x","atan");return o.BV.runKernel(a.jMg,{x:t})}});var k=n(5420);let _=(0,s.op)({atan2_:function(e,t){let n=(0,u._1)(e,"a","atan2"),r=(0,u._1)(t,"b","atan2");[n,r]=(0,k.makeTypesMatch)(n,r);let i={a:n,b:r};return o.BV.runKernel(a.QCc,i)}}),x=(0,s.op)({atanh_:function(e){let t=(0,u._1)(e,"x","atanh");return o.BV.runKernel(a.Oyi,{x:t})}});var E=n(8893),S=n(9011),$=n(6439);let B=(0,s.op)({avgPool_:function(e,t,n,r,i){let s=(0,u._1)(e,"x","avgPool","float32");f.hu(S.jT(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let l=s,c=!1;3===s.rank&&(c=!0,l=(0,$.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),f.hu(4===l.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),S.m("avgPool",r,i);let h={x:l},d=o.BV.runKernel(a.JhU,h,{filterSize:t,strides:n,pad:r,dimRoundingMode:i});return(d=(0,E.p)(d,s.dtype),c)?(0,$.X)(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),A=(0,s.op)({avgPool3d_:function(e,t,n,r,i,s="NDHWC"){let l=(0,u._1)(e,"x","avgPool3d","float32"),c=l,h=!1;4===l.rank&&(h=!0,c=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),f.hu(5===c.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${c.rank}.`),f.hu("NDHWC"===s,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),f.hu("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),(0,S.m)("avgPool3d",r,i);let d={x:c},p=o.BV.runKernel(a._k9,d,{filterSize:t,strides:n,pad:r,dimRoundingMode:i,dataFormat:s});return(p=(0,E.p)(p,c.dtype),h)?(0,$.X)(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}});var I=n(699);let T=(0,s.op)({concat_:function(e,t=0){(0,f.hu)(e.length>=1,()=>"Pass at least one tensor to concat");let n=(0,u.sI)(e,"tensors","concat","string_or_numeric");return("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),1===n.length)?(0,I.d)(n[0]):o.BV.runKernel(a.Eh3,n,{axis:t})}});var N=n(5193),M=n(5314),D=n(5986);let R=(0,s.op)({slice_:function(e,t,n){let r=(0,u._1)(e,"x","slice","string_or_numeric");if(0===r.rank)throw Error("Slicing scalar is not possible");return o.BV.runKernel(a.p2w,{x:r},{begin:t,size:n})}}),V=(0,s.op)({tanh_:function(e){let t=(0,u._1)(e,"x","tanh","float32");return o.BV.runKernel(a.MIZ,{x:t})}}),O=(0,s.op)({basicLSTMCell_:function(e,t,n,r,i,o){let a=(0,u._1)(e,"forgetBias","basicLSTMCell"),s=(0,u._1)(t,"lstmKernel","basicLSTMCell"),l=(0,u._1)(n,"lstmBias","basicLSTMCell"),c=(0,u._1)(r,"data","basicLSTMCell"),f=(0,u._1)(i,"c","basicLSTMCell"),d=T([c,(0,u._1)(o,"h","basicLSTMCell")],1),p=(0,N.O)(d,s),g=(0,h.I)(p,l),m=g.shape[0],b=g.shape[1]/4,y=[m,b],w=R(g,[0,0],y),v=R(g,[0,b],y),k=R(g,[0,2*b],y),_=R(g,[0,3*b],y),x=(0,h.I)((0,M.d)((0,D.X)(w),V(v)),(0,M.d)(f,(0,D.X)((0,h.I)(a,k)))),E=(0,M.d)(V(x),(0,D.X)(_));return[x,E]}}),C=(0,s.op)({batchToSpaceND_:function(e,t,n){let r=(0,u._1)(e,"x","batchToSpaceND"),i=t.reduce((e,t)=>e*t);return f.hu(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),f.hu(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),f.hu(r.shape[0]%i==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${i}`),o.BV.runKernel(a.zws,{x:r},{blockShape:t,crops:n})}}),F=(0,s.op)({batchNorm_:function(e,t,n,r,i,s){let l,c;null==s&&(s=.001);let h=(0,u._1)(e,"x","batchNorm"),d=(0,u._1)(t,"mean","batchNorm"),p=(0,u._1)(n,"variance","batchNorm");null!=i&&(l=(0,u._1)(i,"scale","batchNorm")),null!=r&&(c=(0,u._1)(r,"offset","batchNorm")),f.hu(d.rank===p.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),f.hu(null==c||d.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),f.hu(null==l||d.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let g={x:0===h.rank||1===h.rank?(0,$.X)(h,[1,1,1,h.size]):2===h.rank?(0,$.X)(h,[1,1,h.shape[0],h.shape[1]]):3===h.rank?(0,$.X)(h,[1,h.shape[0],h.shape[1],h.shape[2]]):h,scale:l,offset:c,mean:d,variance:p},m={varianceEpsilon:s},b=o.BV.runKernel(a.sHE,g,m);return(0,$.X)(b,h.shape)}}),P=(0,s.op)({batchNorm2d_:function(e,t,n,r,i,o){let a,s;let l=(0,u._1)(e,"x","batchNorm"),c=(0,u._1)(t,"mean","batchNorm"),h=(0,u._1)(n,"variance","batchNorm");return null!=i&&(a=(0,u._1)(i,"scale","batchNorm")),null!=r&&(s=(0,u._1)(r,"offset","batchNorm")),f.hu(2===l.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),f.hu(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${c.rank}.`),f.hu(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),null!=a&&f.hu(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${a.rank}.`),null!=s&&f.hu(2===s.rank||1===s.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${s.rank}.`),F(l,c,h,s,a,o)}}),L=(0,s.op)({batchNorm3d_:function(e,t,n,r,i,o){let a,s;let l=(0,u._1)(e,"x","batchNorm"),c=(0,u._1)(t,"mean","batchNorm"),h=(0,u._1)(n,"variance","batchNorm");return null!=i&&(a=(0,u._1)(i,"scale","batchNorm")),null!=r&&(s=(0,u._1)(r,"offset","batchNorm")),f.hu(3===l.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),f.hu(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${c.rank}.`),f.hu(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),null!=a&&f.hu(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${a.rank}.`),null!=s&&f.hu(3===s.rank||1===s.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${s.rank}.`),F(l,c,h,s,a,o)}}),G=(0,s.op)({batchNorm4d_:function(e,t,n,r,i,o){let a,s;let l=(0,u._1)(e,"x","batchNorm"),c=(0,u._1)(t,"mean","batchNorm"),h=(0,u._1)(n,"variance","batchNorm");return null!=i&&(a=(0,u._1)(i,"scale","batchNorm")),null!=r&&(s=(0,u._1)(r,"offset","batchNorm")),f.hu(4===l.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),f.hu(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${c.rank}.`),f.hu(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),null!=a&&f.hu(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${a.rank}.`),null!=s&&f.hu(4===s.rank||1===s.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${s.rank}.`),F(l,c,h,s,a,o)}}),U=(0,s.op)({bincount_:function(e,t,n){let r=(0,u._1)(e,"x","bincount"),i=(0,u._1)(t,"weights","bincount");return f.hu("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),f.hu(n>=0,()=>`size must be non-negative, but got ${n}.`),f.hu(i.size===r.size||0===i.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`),o.BV.runKernel(a.zvY,{x:r,weights:i},{size:n})}}),z=(0,s.op)({bitwiseAnd_:function(e,t){let n=(0,u._1)(e,"x","bitwiseAnd"),r=(0,u._1)(t,"y","bitwiseAnd");if(!(0,f.cO)(n.shape,r.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);return o.BV.runKernel(a.hCO,{a:n,b:r})}}),W=(0,s.op)({broadcastArgs_:function(e,t){let n=(0,u._1)(e,"s0","broadcastArgs","int32"),r=(0,u._1)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return o.BV.runKernel(a.eEB,{s0:n,s1:r})}}),q=(0,s.op)({broadcastTo_:function(e,t){let n=(0,u._1)(e,"broadcastTo","x"),r=n.shape;if((0,f.Mu)(t),t.length<n.rank)throw Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,$.X)(n,e)}let i=n.shape,s=Array.from(t);for(let e=t.length-1;e>=0;e--)if(i[e]===t[e])s[e]=1;else if(1!==n.shape[e])throw Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return(0,I.d)(n);let l={x:n};return o.BV.runKernel(a.n9L,l,{reps:s})}});var K=n(5515);let H=(0,s.op)({ceil_:function(e){let t=(0,u._1)(e,"x","ceil","float32");return o.BV.runKernel(a.gJX,{x:t})}});var j=n(180);let X=(0,s.op)({clipByValue_:function(e,t,n){let r=(0,u._1)(e,"x","clipByValue");return(f.hu(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)?(0,j.h)(r.shape,t,r.dtype):o.BV.runKernel(a.xnO,{x:r},{clipValueMin:t,clipValueMax:n})}});var Z=n(7977);let J=(0,s.op)({concat1d_:function(e){return T(e,0)}}),Y=(0,s.op)({concat2d_:function(e,t){return T(e,t)}}),Q=(0,s.op)({concat3d_:function(e,t){return T(e,t)}}),ee=(0,s.op)({concat4d_:function(e,t){return T(e,t)}}),et=(0,s.op)({conv2d_:function(e,t,n,r,i="NHWC",s=[1,1],l){let c=(0,u._1)(e,"x","conv2d","float32"),h=(0,u._1)(t,"filter","conv2d","float32"),d=c,p=!1;3===c.rank&&(p=!0,d=(0,$.X)(c,[1,c.shape[0],c.shape[1],c.shape[2]])),f.hu(4===d.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),f.hu(4===h.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${h.rank}.`),S.m("conv2d",r,l);let g="NHWC"===i?d.shape[3]:d.shape[1];f.hu(g===h.shape[2],()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),f.hu(S.jT(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),f.hu(S.U3(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),f.hu(S.U3(n),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:d,filter:h},b=o.BV.runKernel(a.mhS,m,{strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:l});return p?(0,$.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),en=(0,s.op)({conv1d_:function(e,t,n,r,i="NWC",o=1,a){let s=(0,u._1)(e,"x","conv1d"),l=(0,u._1)(t,"filter","conv1d"),c=s,h=!1;2===s.rank&&(h=!0,c=(0,$.X)(s,[1,s.shape[0],s.shape[1]])),f.hu(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),f.hu(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),S.m("conv1d",r,a),f.hu(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),f.hu(S.jT(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),f.hu(S.U3(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),f.hu(S.U3(n),()=>"Error in conv1D: Stride should be larger than 0."),f.hu("NWC"===i,()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);let d=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=et((0,$.X)(c,[c.shape[0],1,c.shape[1],c.shape[2]]),d,[1,n],r,"NHWC",[1,o],a);return h?(0,$.X)(p,[p.shape[2],p.shape[3]]):(0,$.X)(p,[p.shape[0],p.shape[2],p.shape[3]])}}),er=(0,s.op)({conv2DBackpropInput_:function(e,t,n,r,i,u="NHWC",s){f.hu(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let l=e,c=t,h=!1;3===t.rank&&(h=!0,c=(0,$.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),l=[1,e[0],e[1],e[2]]),f.hu(4===l.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),f.hu(4===c.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),f.hu(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let d="NHWC"===u?l[3]:l[1],p="NHWC"===u?c.shape[3]:c.shape[1];f.hu(d===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`),f.hu(p===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`),S.m("conv2dDerInput",i,s);let g={dy:c,filter:n},m={strides:r,pad:i,dataFormat:u,dimRoundingMode:s,inputShape:l},b=o.BV.runKernel(a.wm,g,m);return h?(0,$.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),ei=(0,s.op)({conv2dTranspose_:function(e,t,n,r,i,o){return er(n,(0,u._1)(e,"x","conv2dTranspose"),(0,u._1)(t,"filter","conv2dTranspose"),r,i,"NHWC",o)}}),eo=(0,s.op)({conv3d_:function(e,t,n,r,i="NDHWC",s=[1,1,1]){let l=(0,u._1)(e,"x","conv3d"),c=(0,u._1)(t,"filter","conv3d"),h=l,d=!1;4===l.rank&&(d=!0,h=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),f.hu(5===h.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`),f.hu(5===c.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${c.rank}.`),f.hu(h.shape[4]===c.shape[3],()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${c.shape[3]}.`),f.hu((0,S.jT)(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),f.hu("NDHWC"===i,()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),f.hu((0,S.U3)(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),f.hu((0,S.U3)(n),()=>"Error in conv3D: Strides should be larger than 0.");let p={x:h,filter:c},g=o.BV.runKernel(a.x12,p,{strides:n,pad:r,dataFormat:i,dilations:s});return d?(0,$.X)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),ea=(0,s.op)({conv3DBackpropInput_:function(e,t,n,r,i){f.hu(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let u=e,s=t,l=!1;4===t.rank&&(l=!0,s=(0,$.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),u=[1,e[0],e[1],e[2],e[3]]);let c=u[4],h=s.shape[4];f.hu(5===u.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`),f.hu(5===s.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${s.rank}`),f.hu(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),f.hu(c===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`),f.hu(h===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[4]}.`);let d={dy:s,filter:n},p={pad:i,strides:r,inputShape:u},g=o.BV.runKernel(a.ik2,d,p);return l?(0,$.X)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),eu=(0,s.op)({conv3dTranspose_:function(e,t,n,r,i){return ea(n,(0,u._1)(e,"x","conv3dTranspose"),(0,u._1)(t,"filter","conv3dTranspose"),r,i)}}),es=(0,s.op)({cos_:function(e){let t=(0,u._1)(e,"x","cos","float32");return o.BV.runKernel(a.mc4,{x:t})}}),el=(0,s.op)({cosh_:function(e){let t=(0,u._1)(e,"x","cosh","float32");return o.BV.runKernel(a.TR1,{x:t})}}),ec=(0,s.op)({cumprod_:function(e,t=0,n=!1,r=!1){let i=(0,u._1)(e,"x","cumprod");return o.BV.runKernel(a.Byc,{x:i},{axis:t,exclusive:n,reverse:r})}}),eh=(0,s.op)({cumsum_:function(e,t=0,n=!1,r=!1){let i=(0,u._1)(e,"x","cumsum");return o.BV.runKernel(a.iHb,{x:i},{axis:t,exclusive:n,reverse:r})}}),ef=(0,s.op)({denseBincount_:function(e,t,n,r=!1){let i=(0,u._1)(e,"x","denseBincount"),s=(0,u._1)(t,"weights","denseBincount");return f.hu("int32"===i.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),f.hu(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),f.hu(n>=0,()=>`size must be non-negative, but got ${n}.`),f.hu(s.size===i.size||0===s.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`),o.BV.runKernel(a.QRR,{x:i,weights:s},{size:n,binaryOutput:r})}}),ed=(0,s.op)({depthToSpace_:function(e,t,n="NHWC"){let r=(0,u._1)(e,"x","depthToSpace","float32"),i="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],l="NHWC"===n?r.shape[3]:r.shape[1];return f.hu(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),f.hu(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${r.shape}`),f.hu(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),f.hu(l%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${l} for depthToSpace with input shape ${r.shape}`),o.BV.runKernel(a.T0n,{x:r},{blockSize:t,dataFormat:n})}}),ep=(0,s.op)({depthwiseConv2d_:function(e,t,n,r,i="NHWC",s=[1,1],l){let c=(0,u._1)(e,"x","depthwiseConv2d","float32"),h=(0,u._1)(t,"filter","depthwiseConv2d","float32"),d=c,p=!1;3===c.rank&&(p=!0,d=(0,$.X)(c,[1,c.shape[0],c.shape[1],c.shape[2]])),f.hu(4===d.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),f.hu(4===h.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`);let g="NHWC"===i?d.shape[3]:d.shape[1];f.hu(g===h.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${g}) must match the inChannels dimension in filter ${h.shape[2]}.`),S.m("depthwiseConv2d",r,l);let m={x:d,filter:h},b=o.BV.runKernel(a.cie,m,{strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:l});return p?(0,$.X)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),eg=(0,s.op)({diag_:function(e){let t=(0,u._1)(e,"x","diag");return o.BV.runKernel(a.$w,{x:t})}}),em=(0,s.op)({dilation2d_:function(e,t,n,r,i=[1,1],s="NHWC"){let l=(0,u._1)(e,"x","dilation2d"),c=(0,u._1)(t,"filter","dilation2d");f.hu(3===l.rank||4===l.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${l.rank}.`),f.hu(3===c.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${c.rank}.`),f.hu("NHWC"===s,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let h=l,d=!1;3===l.rank&&(h=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=!0),f.hu(h.shape[3]===c.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${h.shape[3]} vs ${c.shape[2]}`);let p={x:h,filter:c},g=o.BV.runKernel(a.p4S,p,{strides:n,pad:r,dilations:i});return d?(0,$.X)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});var eb=n(3511),ey=n(5221);let ew=(0,s.op)({equal_:function(e,t){let n=(0,u._1)(e,"a","equal","string_or_numeric"),r=(0,u._1)(t,"b","equal","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.hdR,i)}}),ev=(0,s.op)({where_:function(e,t,n){let r=(0,u._1)(t,"a","where"),i=(0,u._1)(n,"b","where"),s=(0,u._1)(e,"condition","where","bool"),l=(0,ey.assertAndGetBroadcastShape)((0,ey.assertAndGetBroadcastShape)(s.shape,r.shape),i.shape),c=q(s,l),h=q(r,l),f=q(i,l);return o.BV.runKernel(a.PhF,{condition:c,t:h,e:f})}});var ek=n(2898);let e_=(0,s.op)({divNoNan_:function(e,t){let n=(0,u._1)(e,"a","div"),r=(0,u._1)(t,"b","div");[n,r]=(0,k.makeTypesMatch)(n,r);let i=(0,eb.h)(n,r),o=(0,ek.P)(i);return ev(ew(r,o),o,i)}}),ex=(0,s.op)({dot_:function(e,t){let n=(0,u._1)(e,"t1","dot"),r=(0,u._1)(t,"t2","dot");f.hu((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let i=1===n.rank?n.size:n.shape[1],o=1===r.rank?r.size:r.shape[0];if(f.hu(i===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${o}.`),1===n.rank&&1===r.rank){let e=(0,$.X)(n,[1,-1]),t=(0,$.X)(r,[-1,1]),i=(0,N.O)(e,t);return(0,$.X)(i,[])}if(1===n.rank&&2===r.rank){let e=(0,$.X)(n,[1,-1]),t=(0,$.X)(r,[r.shape[0],r.shape[1]]),i=(0,N.O)(e,t);return(0,$.X)(i,[i.size])}if(2===n.rank&&1===r.rank){let e=(0,$.X)(r,[-1,1]),t=(0,N.O)(n,e);return(0,$.X)(t,[t.size])}{let e=(0,$.X)(r,[r.shape[0],r.shape[1]]);return(0,N.O)(n,e)}}}),eE=(0,s.op)({einsum_:function(e,...t){let n=t.map((e,t)=>(0,u._1)(e,`tensors${t}`,"einsum"));return o.BV.runKernel(a.$g6,n,{equation:e})}});var eS=n(4077);let e$=(0,s.op)({ensureShape_:function(e,t){let n=(0,u._1)(e,"x","ensureShape","string_or_numeric");if(!(0,f.DK)(n.shape,t))throw Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}}),eB=(0,s.op)({erf_:function(e){let t=(0,u._1)(e,"x","erf");f.hu("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=(0,E.p)(t,"float32"));let n={x:t};return o.BV.runKernel(a.Omj,n)}});var eA=n(7050);let eI=(0,s.op)({max_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","max");return o.BV.runKernel(a.YoZ,{x:r},{reductionIndices:t,keepDims:n})}}),eT=(0,s.op)({min_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","min");return o.BV.runKernel(a.c17,{x:r},{axis:t,keepDims:n})}});var eN=n(2611),eM=n(6070),eD=n(9467),eR=n(7941),eV=n(1101);let eO=(0,s.op)({norm_:function(e,t="euclidean",n=null,r=!1){let o=function e(t,n,r=null){if(0===t.rank)return(0,i.W)(t);if(1!==t.rank&&null===r)return e((0,$.X)(t,[-1]),n,r);if(1===t.rank||"number"==typeof r||Array.isArray(r)&&1===r.length){if(1===n)return(0,eV.S)((0,i.W)(t),r);if(n===1/0)return eI((0,i.W)(t),r);if(n===-1/0)return eT((0,i.W)(t),r);if("euclidean"===n||2===n)return(0,eD._)((0,eV.S)((0,eN.s)((0,i.W)(t),(0,eM.i)(2,"int32")),r));throw Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(r)&&2===r.length){if(1===n)return eI((0,eV.S)((0,i.W)(t),r[0]),r[1]-1);if(n===1/0)return eI((0,eV.S)((0,i.W)(t),r[1]),r[0]);if(n===-1/0)return eT((0,eV.S)((0,i.W)(t),r[1]),r[0]);if("fro"===n||"euclidean"===n)return(0,eD._)((0,eV.S)((0,eR.h)(t),r));throw Error(`Error in norm: invalid ord value: ${n}`)}throw Error(`Error in norm: invalid axis: ${r}`)}(e=(0,u._1)(e,"x","norm"),t,n),a=o.shape;if(r){let t=(0,f.EC)(n,e.shape);a=eA.rv(o.shape,t)}return(0,$.X)(o,a)}}),eC=(0,s.op)({euclideanNorm_:function(e,t=null,n=!1){return eO(e,"euclidean",t,n)}}),eF=(0,s.op)({exp_:function(e){let t=(0,u._1)(e,"x","exp");return o.BV.runKernel(a.NEP,{x:t})}}),eP=(0,s.op)({expandDims_:function(e,t=0){let n=(0,u._1)(e,"x","expandDims","string_or_numeric");return f.hu(t<=n.rank,()=>"Axis must be <= rank of the tensor"),o.BV.runKernel(a.YFo,{input:n},{dim:t})}}),eL=(0,s.op)({expm1_:function(e){let t=(0,u._1)(e,"x","expm1");return o.BV.runKernel(a.Y0y,{x:t})}}),eG=(0,s.op)({tile_:function(e,t){let n=(0,u._1)(e,"x","tile","string_or_numeric");return f.hu(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),o.BV.runKernel(a.n9L,{x:n},{reps:t})}}),eU=(0,s.op)({eye_:function(e,t,n,r="float32"){null==t&&(t=e);let i=(0,K.f)([e,t],r),o=e<=t?e:t;for(let e=0;e<o;++e)i.set(1,e,e);let a=(0,$.X)(i.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return eG(eP(a,0),[n[0],1,1]);if(2===n.length)return eG(eP(eP(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return eG(eP(eP(eP(a,0),0),0),[n[0],n[1],n[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),ez=(0,s.op)({floor_:function(e){let t=(0,u._1)(e,"x","floor","float32");return o.BV.runKernel(a.OR,{x:t})}});var eW=n(7576);let eq=(0,s.op)({gather_:function(e,t,n=0,r=0){let i=(0,u._1)(e,"x","gather"),s=(0,u._1)(t,"indices","gather","int32");return o.BV.runKernel(a.qi_,{x:i,indices:s},{axis:n,batchDims:r})}}),eK=(0,s.op)({greater_:function(e,t){let n=(0,u._1)(e,"a","greater","string_or_numeric"),r=(0,u._1)(t,"b","greater","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.iZT,i)}}),eH=(0,s.op)({greaterEqual_:function(e,t){let n=(0,u._1)(e,"a","greaterEqual","string_or_numeric"),r=(0,u._1)(t,"b","greaterEqual","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.Acj,i)}});var ej=n(8587);let eX=(0,s.op)({isFinite_:function(e){let t=(0,u._1)(e,"x","isFinite");return o.BV.runKernel(a.avt,{x:t})}}),eZ=(0,s.op)({isInf_:function(e){let t=(0,u._1)(e,"x","isInf");return o.BV.runKernel(a.iWB,{x:t})}}),eJ=(0,s.op)({isNaN_:function(e){let t=(0,u._1)(e,"x","isNaN");return o.BV.runKernel(a.r7n,{x:t})}});var eY=n(6437);let eQ=(0,s.op)({less_:function(e,t){let n=(0,u._1)(e,"a","less","string_or_numeric"),r=(0,u._1)(t,"b","less","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.vtC,i)}}),e0=(0,s.op)({lessEqual_:function(e,t){let n=(0,u._1)(e,"a","lessEqual","string_or_numeric"),r=(0,u._1)(t,"b","lessEqual","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.CAk,i)}});function e1(e,t,n){if(n<=0)throw Error("The number of values should be positive.");return o.BV.runKernel(a.e7N,{},{start:e,stop:t,num:n})}let e2=(0,s.op)({localResponseNormalization_:function(e,t=5,n=1,r=1,i=.5){let s=(0,u._1)(e,"x","localResponseNormalization");f.hu(4===s.rank||3===s.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),f.hu(f.GN(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let l=s,c=!1;3===s.rank&&(c=!0,l=(0,$.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let h={x:l},d=o.BV.runKernel(a.eZ0,h,{depthRadius:t,bias:n,alpha:r,beta:i});return c?(0,$.X)(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),e3=(0,s.op)({log_:function(e){let t=(0,u._1)(e,"x","log","float32");return o.BV.runKernel(a.ZbH,{x:t})}}),e4=(0,s.op)({log1p_:function(e){let t=(0,u._1)(e,"x","log1p");return o.BV.runKernel(a.kU,{x:t})}});var e6=n(4310),e5=n(2666);let e7=(0,s.op)({softplus_:function(e){let t=(0,u._1)(e,"x","softplus");return o.BV.runKernel(a.MRv,{x:t})}}),e8=(0,s.op)({logSigmoid_:function(e){let t=(0,u._1)(e,"x","logSigmoid");return(0,e6.cb)(e=>({value:(0,e5.W)(e7((0,e5.W)(e))),gradFunc:t=>(0,M.d)(t,(0,D.X)((0,e5.W)(e)))}))(t)}});var e9=n(5799);let te=(0,s.op)({logSoftmax_:function(e,t=-1){let n=(0,u._1)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return(0,e6.cb)((e,n)=>{let r=eI(e,t,!0),i=(0,e9.l)(e,r),o=(0,e9.l)((0,E.p)(i,"float32"),e3((0,eV.S)(eF(i),t,!0)));return n([o]),{value:o,gradFunc:(e,n)=>{let[r]=n,i=eF(r);return(0,e9.l)(e,(0,M.d)((0,eV.S)(e,t,!0),i))}}})(n)}}),tt=(0,s.op)({logSumExp_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","logSumExp"),i=(0,f.EC)(t,r.shape),o=eI(r,i,!0),a=eF((0,e9.l)(r,o)),s=e3((0,eV.S)(a,i)),l=(0,h.I)((0,$.X)(o,s.shape),s);if(n){let e=(0,eA.rv)(l.shape,i);return(0,$.X)(l,e)}return l}}),tn=(0,s.op)({logicalAnd_:function(e,t){let n=(0,u._1)(e,"a","logicalAnd","bool"),r=(0,u._1)(t,"b","logicalAnd","bool");return(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape),o.BV.runKernel(a.PYm,{a:n,b:r})}}),tr=(0,s.op)({logicalNot_:function(e){let t=(0,u._1)(e,"x","logicalNot","bool");return o.BV.runKernel(a.VfG,{x:t})}}),ti=(0,s.op)({logicalOr_:function(e,t){let n=(0,u._1)(e,"a","logicalOr","bool"),r=(0,u._1)(t,"b","logicalOr","bool");return(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape),o.BV.runKernel(a.MZg,{a:n,b:r})}}),to=(0,s.op)({logicalXor_:function(e,t){let n=(0,u._1)(e,"a","logicalXor","bool"),r=(0,u._1)(t,"b","logicalXor","bool");return(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape),tn(ti(e,t),tr(tn(e,t)))}}),ta=(0,s.op)({searchSorted_:function(e,t,n="left"){let r=(0,u._1)(e,"sortedSequence","searchSorted"),i=(0,u._1)(t,"values","searchSorted"),s=r.shape[r.shape.length-1],l=i.shape[i.shape.length-1],c=(0,$.X)(r,[-1,s]),h=(0,$.X)(i,[-1,l]);if(c.rank<2)throw Error("Sorted input argument must be at least 2-dimensional");if(c.shape[0]!==h.shape[0])throw Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,f.NA)(h.shape)>=2147483648)throw Error("values tensor size must less than 2147483648");if(c.shape[1]>=2147483648)throw Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${c.shape[1]}`);return o.BV.runKernel(a.nr8,{sortedSequence:c,values:h},{side:n})}});function tu(e,t){return ta(e,t,"left")}let ts=(0,s.op)({maxPool_:function(e,t,n,r,i){let s=(0,u._1)(e,"x","maxPool"),l=s,c=!1;3===s.rank&&(c=!0,l=(0,$.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),f.hu(4===l.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),f.hu(S.jT(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),S.m("maxPool",r,i);let h={x:l},d=o.BV.runKernel(a.mTV,h,{filterSize:t,strides:n,pad:r,dimRoundingMode:i});return c?(0,$.X)(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),tl=(0,s.op)({maxPool3d_:function(e,t=[1,1,1],n,r,i,s="NDHWC"){let l=(0,u._1)(e,"x","maxPool3d"),c=l,h=!1;4===l.rank&&(h=!0,c=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),f.hu(5===c.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${c.rank}.`),f.hu("NDHWC"===s,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),(0,S.m)("maxPool3d",r,i);let d={x:c},p=o.BV.runKernel(a.OAf,d,{filterSize:t,strides:n,pad:r,dimRoundingMode:i,dataFormat:s});return h?(0,$.X)(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),tc=(0,s.op)({maxPoolWithArgmax_:function(e,t,n,r,i=!1){let s=(0,u._1)(e,"x","maxPoolWithArgmax"),l=o.BV.runKernel(a.vFR,{x:s},{filterSize:t,strides:n,pad:r,includeBatchInIndex:i});return{result:l[0],indexes:l[1]}}});var th=n(2673);let tf=(0,s.op)({mean_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","mean");return o.BV.runKernel(a.q2K,{x:r},{axis:t,keepDims:n})}});function td(e,t="float32"){if((0,f.Mu)(e),"complex64"===t){let t=td(e,"float32"),n=td(e,"float32");return(0,Z.P)(t,n)}let n=(0,f.wT)((0,f.NA)(e),t);return o.BV.makeTensor(n,e,t)}function tp(e,t="float32"){if((0,f.Mu)(e),"complex64"===t){let t=tp(e,"float32"),n=td(e,"float32");return(0,Z.P)(t,n)}let n=(0,f.p8)((0,f.NA)(e),t);return o.BV.makeTensor(n,e,t)}var tg=n(6150);function tm(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=(0,u._1)(e,"x","meshgrid",e instanceof tg.es?e.dtype:"float32");if(void 0===t)return[r];let i=(0,u._1)(t,"y","meshgrid",t instanceof tg.es?t.dtype:"float32"),o=(0,f.NA)(r.shape),a=(0,f.NA)(i.shape);return"xy"===n?(r=(0,$.X)(r,[1,-1]),i=(0,$.X)(i,[-1,1]),[(0,N.O)(tp([a,1],r.dtype),r),(0,N.O)(i,tp([1,o],i.dtype))]):(r=(0,$.X)(r,[-1,1]),i=(0,$.X)(i,[1,-1]),[(0,N.O)(r,tp([1,a],r.dtype)),(0,N.O)(tp([o,1],i.dtype),i)])}let tb=(0,s.op)({minimum_:function(e,t){let n=(0,u._1)(e,"a","minimum"),r=(0,u._1)(t,"b","minimum");[n,r]=(0,k.makeTypesMatch)(n,r),"bool"===n.dtype&&(n=(0,E.p)(n,"int32"),r=(0,E.p)(r,"int32")),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.q8u,i)}}),ty=(0,s.op)({mirrorPad_:function(e,t,n){f.hu("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=(0,u._1)(e,"x","mirrorPad");if(0===r.rank)throw Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");f.hu(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let i="reflect"===n?1:0;for(let e=0;e<r.rank;e++)f.hu(2===t[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),f.hu(t[e][0]>=0&&t[e][0]<=r.shape[e]-i&&t[e][1]>=0&&t[e][1]<=r.shape[e]-i,()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-i} or less than 0 for input of shape ${r.shape}`);return o.BV.runKernel(a.jQs,{x:r},{paddings:t,mode:n})}}),tw=(0,s.op)({mod_:function(e,t){let n=(0,u._1)(e,"a","mod"),r=(0,u._1)(t,"b","mod");[n,r]=(0,k.makeTypesMatch)(n,r);let i={a:n,b:r};return o.BV.runKernel(a.Vbg,i)}}),tv=(0,s.op)({moments_:function(e,t=null,n=!1){e=(0,u._1)(e,"x","moments");let r=(0,f.EC)(t,e.shape),i=tf(e,r,n),o=i.shape;n||(o=(0,eA.rv)(i.shape,r));let a=tf((0,eR.h)((0,e9.l)((0,E.p)(e,"float32"),(0,$.X)(i,o))),r,n);return{mean:i,variance:a}}}),tk=(0,s.op)({multiRNNCell_:function(e,t,n,r){let i=(0,u._1)(t,"data","multiRNNCell"),o=(0,u.sI)(n,"c","multiRNNCell"),a=(0,u.sI)(r,"h","multiRNNCell"),s=i,l=[];for(let t=0;t<e.length;t++){let n=e[t](s,o[t],a[t]);l.push(n[0]),l.push(n[1]),s=n[1]}let c=[],h=[];for(let e=0;e<l.length;e+=2)c.push(l[e]),h.push(l[e+1]);return[c,h]}}),t_=(0,s.op)({multinomial_:function(e,t,n,r=!1){let i=(0,u._1)(e,"logits","multinomial"),s=i.size,l=i.rank;if(s<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(l>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${l}`);n=n||Math.random();let c=1===l?(0,$.X)(i,[1,-1]):i,h={numSamples:t,seed:n,normalized:r},f=o.BV.runKernel(a.NZg,{logits:c},h);return 1===l?(0,$.X)(f,[f.size]):f}}),tx=(0,s.op)({notEqual_:function(e,t){let n=(0,u._1)(e,"a","notEqual","string_or_numeric"),r=(0,u._1)(t,"b","notEqual","string_or_numeric");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a.yQU,i)}});var tE=n(8713);let tS=(0,s.op)({onesLike_:function(e){let t=(0,u._1)(e,"x","onesLike");return o.BV.runKernel(a.qWM,{x:t})}}),t$=(0,s.op)({outerProduct_:function(e,t){let n=(0,u._1)(e,"v1","outerProduct"),r=(0,u._1)(t,"v2","outerProduct");f.hu(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let i=(0,$.X)(n,[-1,1]),o=(0,$.X)(r,[1,-1]);return(0,N.O)(i,o)}}),tB=(0,s.op)({pad_:function(e,t,n=0){let r=(0,u._1)(e,"x","pad");if(0===r.rank)throw Error("pad(scalar) is not defined. Pass non-scalar to pad");return o.BV.runKernel(a.lyA,{x:r},{paddings:t,constantValue:n})}}),tA=(0,s.op)({pad1d_:function(e,t,n=0){return(0,f.hu)(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),tB(e,[t],n)}}),tI=(0,s.op)({pad2d_:function(e,t,n=0){return(0,f.hu)(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),tB(e,t,n)}}),tT=(0,s.op)({pad3d_:function(e,t,n=0){return(0,f.hu)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),tB(e,t,n)}}),tN=(0,s.op)({pad4d_:function(e,t,n=0){return(0,f.hu)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),tB(e,t,n)}}),tM=(0,s.op)({spaceToBatchND_:function(e,t,n){let r=(0,u._1)(e,"x","spaceToBatchND");return f.hu(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),f.hu(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),f.hu(r.shape.reduce((e,r,i)=>i>0&&i<=t.length?e&&(r+n[i-1][0]+n[i-1][1])%t[i-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),o.BV.runKernel(a.TQc,{x:r},{blockShape:t,paddings:n})}}),tD=(0,s.op)({pool_:function(e,t,n,r,i,o,a){let s;null==i&&(i=[1,1]),null==o&&(o=1),0===r&&(r="valid");let l=(0,u._1)(e,"x","maxPool"),c=l,h=!1;3===l.rank&&(h=!0,c=(0,$.X)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),f.hu(S.jT(o,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${i}'`);let d=S.Xw(c.shape,t,o,i,r),p=[d.dilationHeight,d.dilationWidth];s="same"===r?function(e,t){let n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),i=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],i[t]])}([d.filterHeight,d.filterWidth],p):[[0,0],[0,0]];let g=1===p[0]&&1===p[1],[m,b]=function(e,t,n){let r=n.map(e=>e[0]),i=n.map(e=>e[1]),o=e.concat(r,i),a=t.map((e,t)=>(e-o[t]%e)%e),u=i.map((e,t)=>e+a[t]);return[t.map((e,t)=>[r[t],u[t]]),t.map((e,t)=>[0,a[t]])]}([d.inHeight,d.inWidth],p,s),y=g?r:"valid",w=g?c:tM(c,p,m),v=("avg"===n?()=>B(w,t,o,y,a):()=>ts(w,t,o,y,a))(),k=g?v:C(v,p,b);return h?(0,$.X)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}});var tR=n(9427),tV=n(7290);let tO=(0,s.op)({prod_:function(e,t=null,n=!1){let r=(0,u._1)(e,"x","prod");"bool"===r.dtype&&(r=(0,E.p)(r,"int32"));let i={x:r};return o.BV.runKernel(a.DlI,i,{axis:t,keepDims:n})}}),tC=(0,s.op)({raggedGather_:function(e,t,n,r){let i=e.map((e,t)=>(0,u._1)(e,`tensors${t}`,"raggedGather","int32")),s=(0,u._1)(t,"paramsDenseValues","raggedGather"),l=(0,u._1)(n,"indices","raggedGather","int32"),c=o.BV.runKernel(a.dDz,{paramsNestedSplits:i,paramsDenseValues:s,indices:l},{outputRaggedRank:r});return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}}),tF=(0,s.op)({raggedRange_:function(e,t,n){let r=(0,u._1)(e,"starts","raggedRange"),i=(0,u._1)(t,"limits","raggedRange",r.dtype),s=(0,u._1)(n,"deltas","raggedRange",r.dtype),l=o.BV.runKernel(a.CQl,{starts:r,limits:i,deltas:s});return{rtNestedSplits:l[0],rtDenseValues:l[1]}}}),tP=(0,s.op)({raggedTensorToTensor_:function(e,t,n,r,i){let s=(0,u._1)(e,"shape","raggedTensorToTensor","int32"),l=(0,u._1)(t,"values","raggedTensorToTensor"),c=(0,u._1)(n,"defaultValue","raggedTensorToTensor",l.dtype),h=r.map((e,t)=>(0,u._1)(e,`tensors${t}`,"raggedTensorToTensor","int32"));return o.BV.runKernel(a.BiW,{shape:s,values:l,defaultValue:c,rowPartitionTensors:h},{rowPartitionTypes:i})}}),tL=(0,s.op)({rand_:function(e,t,n){(0,f.Mu)(e);let r=(0,f.NA)(e),i=null;if(null==n||"float32"===n)i=new Float32Array(r);else if("int32"===n)i=new Int32Array(r);else if("bool"===n)i=new Uint8Array(r);else throw Error(`Unknown data type ${n}`);for(let e=0;e<r;e++)i[e]=t();return o.BV.makeTensor(i,e,n)}});var tG=n(9900);class tU{constructor(e,t,n,r,i){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let o=i||Math.random();this.random=tG.alea(o.toString())}nextValue(){let e,t;if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let n=!1;for(;!n;){let r,i,o;do o=(r=2*this.random()-1)*r+(i=2*this.random()-1)*i;while(o>=1||0===o);let a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class tz{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let i=r||Math.random();this.randu=tG.alea(i.toString()),this.randn=new tU(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,i,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,t=1-.331*(e=r*r)*e,n=.5*e+this.d*(1-o+Math.log(o)),(i=this.randu())<t||Math.log(i)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class tW{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=tG.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}let tq=(0,s.op)({randomGamma_:function(e,t,n=1,r="float32",i){if((0,f.Mu)(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw Error(`Unsupported data type ${r}`);let o=new tz(t,n,r,i),a=(0,K.f)(e,r);for(let e=0;e<a.values.length;e++)a.values[e]=o.nextValue();return a.toTensor()}}),tK=(0,s.op)({randomNormal_:function(e,t=0,n=1,r,i){if((0,f.Mu)(e),null!=r&&"bool"===r)throw Error(`Unsupported data type ${r}`);let o=new tU(t,n,r,!1,i),a=(0,K.f)(e,r);for(let e=0;e<a.values.length;e++)a.values[e]=o.nextValue();return a.toTensor()}}),tH=(0,s.op)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw Error(`Unsupported data type ${t}`);return tK(e,0,1,t,n)}}),tj=(0,s.op)({randomUniform_:function(e,t=0,n=1,r="float32",i){(0,f.Mu)(e);let o=(0,K.f)(e,r),a=new tW(t,n,null,i);for(let e=0;e<o.values.length;e++)o.values[e]=a.nextValue();return o.toTensor()}}),tX=(0,s.op)({randomUniformInt_:function(e,t,n,r){return tj(e,t,n,"int32",r)}});function tZ(e,t,n=1,r="float32"){if(0===n)throw Error("Cannot have a step of zero");return o.BV.runKernel(a.e6w,{},{start:e,stop:t,step:n,dtype:r})}var tJ=n(1773);let tY=(0,s.op)({reciprocal_:function(e){let t=(0,u._1)(e,"x","reciprocal");return o.BV.runKernel(a.$HU,{x:t})}});var tQ=n(114),t0=n(6762);let t1=(0,s.op)({reverse_:function(e,t){let n=(0,u._1)(e,"x","reverse");return o.BV.runKernel(a.mKl,{x:n},{dims:t})}}),t2=(0,s.op)({reverse1d_:function(e){let t=(0,u._1)(e,"x","reverse");return f.hu(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),t1(t,0)}}),t3=(0,s.op)({reverse2d_:function(e,t){let n=(0,u._1)(e,"x","reverse");return f.hu(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),t1(n,t)}}),t4=(0,s.op)({reverse3d_:function(e,t){let n=(0,u._1)(e,"x","reverse");return f.hu(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),t1(n,t)}}),t6=(0,s.op)({reverse4d_:function(e,t){let n=(0,u._1)(e,"x","reverse");return f.hu(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),t1(n,t)}}),t5=(0,s.op)({round_:function(e){let t=(0,u._1)(e,"x","round");return o.BV.runKernel(a.e07,{x:t})}}),t7=(0,s.op)({rsqrt_:function(e){let t=(0,u._1)(e,"x","rsqrt","float32");return o.BV.runKernel(a.bV0,{x:t})}}),t8=(0,s.op)({selu_:function(e){let t=(0,u._1)(e,"x","selu");return o.BV.runKernel(a.oFR,{x:t})}}),t9=(0,s.op)({separableConv2d_:function(e,t,n,r,i,o=[1,1],a="NHWC"){let s=(0,u._1)(e,"x","separableConv2d"),l=(0,u._1)(t,"depthwiseFilter","separableConv2d"),c=(0,u._1)(n,"pointwiseFilter","separableConv2d"),h=s,d=!1;if(3===s.rank&&(d=!0,h=(0,$.X)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),"NCHW"===a)throw Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");f.hu(4===h.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),f.hu(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),f.hu(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),f.hu(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),f.hu(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let p=l.shape[2],g=l.shape[3];f.hu(c.shape[2]===p*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*g}, but got ${c.shape[2]}.`);let m=et(ep(h,l,r,i,a,o),c,1,"valid",a);return d?(0,$.X)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),ne=async function(e,t){let n=(0,u._1)(e,"x","setdiff1d"),r=(0,u._1)(t,"y","setdiff1d");f.hu(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),f.hu(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),f.hu(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);let i=await n.data(),o=new Set(await r.data()),a=0;for(let e=0;e<i.length;e++)!o.has(i[e])&&a++;let s=new tg.YD([a],n.dtype),l=new tg.YD([a],"int32");for(let e=0,t=0;e<i.length;e++)!o.has(i[e])&&(s.values[t]=i[e],l.values[t]=e,t++);return[s.toTensor(),l.toTensor()]},nt=(0,s.op)({sign_:function(e){let t=(0,u._1)(e,"x","sign");return o.BV.runKernel(a.i5y,{x:t})}}),nn=(0,s.op)({sin_:function(e){let t=(0,u._1)(e,"x","sin","float32");return o.BV.runKernel(a.RQH,{x:t})}}),nr=(0,s.op)({sinh_:function(e){let t=(0,u._1)(e,"x","sinh");return o.BV.runKernel(a.wYB,{x:t})}}),ni=(0,s.op)({slice1d_:function(e,t,n){let r=(0,u._1)(e,"x","slice1d");return f.hu(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),R(r,[t],[n])}}),no=(0,s.op)({slice2d_:function(e,t,n){let r=(0,u._1)(e,"x","slice2d");return f.hu(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),R(r,t,n)}}),na=(0,s.op)({slice3d_:function(e,t,n){let r=(0,u._1)(e,"x","slice3d");return f.hu(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),R(r,t,n)}}),nu=(0,s.op)({slice4d_:function(e,t,n){let r=(0,u._1)(e,"x","slice4d");return f.hu(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),R(r,t,n)}}),ns=(0,s.op)({softmax_:function(e,t=-1){let n=(0,u._1)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={dim:t};return o.BV.runKernel(a.Gcp,{logits:n},r)}}),nl=(0,s.op)({fft_:function(e){return(0,f.hu)("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),o.BV.runKernel(a.vwp,{input:e})}}),nc=(0,s.op)({ifft_:function(e){return(0,f.hu)("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),o.BV.runKernel(a.Qg5,{input:e})}}),nh=(0,s.op)({irfft_:function(e){let t;let n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2)t=nc((0,$.X)(e,[r,n]));else{let i=[r,2*(n-1)],o=(0,$.X)((0,tJ.k)(e),[r,n]),a=(0,$.X)((0,ej.a)(e),[r,n]),u=t1(R(o,[0,1],[r,n-2]),1),s=(0,M.d)(t1(R(a,[0,1],[r,n-2]),1),(0,eM.i)(-1)),l=T([o,u],1),c=T([a,s],1);t=nc((0,$.X)((0,Z.P)(l,c),[i[0],i[1]]))}if(t=(0,tJ.k)(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=(0,$.X)(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}}),nf=(0,s.op)({split_:function(e,t,n=0){let r=(0,u._1)(e,"x","split");return o.BV.runKernel(a.L8s,{x:r},{numOrSizeSplits:t,axis:n})}}),nd=(0,s.op)({rfft_:function(e,t){let n;(0,f.hu)("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let r=e.shape[e.shape.length-1],i=e.size/r;if(null!=t&&t<r){let i=e.shape.map(e=>0),o=e.shape.map(e=>e);o[e.shape.length-1]=t,n=R(e,i,o),r=t}else if(null!=t&&t>r){let i=e.shape.map(e=>e);i[e.shape.length-1]=t-r,n=T([e,td(i)],e.shape.length-1),r=t}else n=e;let o=(0,ek.P)(n),a=nl((0,$.X)((0,Z.P)(n,o),[i,r])),u=Math.floor(r/2)+1,s=(0,tJ.k)(a),l=(0,ej.a)(a),c=nf(s,[u,r-u],s.shape.length-1),h=nf(l,[u,r-u],l.shape.length-1),d=n.shape.slice();return d[n.shape.length-1]=u,(0,$.X)((0,Z.P)(c[0],h[0]),d)}}),np=(0,s.op)({squaredDifference_:function(e,t){let n=(0,u._1)(e,"a","squaredDifference"),r=(0,u._1)(t,"b","squaredDifference");[n,r]=(0,k.makeTypesMatch)(n,r),(0,ey.assertAndGetBroadcastShape)(n.shape,r.shape);let i={a:n,b:r};return o.BV.runKernel(a._tC,i,{})}}),ng=(0,s.op)({squeeze_:function(e,t){let n=(0,u._1)(e,"x","squeeze","string_or_numeric");return(0,$.X)(n,(0,f.bp)(n.shape,t).newShape)}}),nm=(0,s.op)({stack_:function(e,t=0){let n=(0,u.sI)(e,"tensors","stack","string_or_numeric");return f.hu(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&f.hu(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),o.BV.runKernel(a.QiL,n,{axis:t})}});var nb=n(9794);let ny=(0,s.op)({stridedSlice_:function(e,t,n,r,i=0,s=0,l=0,c=0,h=0){let f=(0,u._1)(e,"x","stridedSlice","string_or_numeric");return o.BV.runKernel(a.jQk,{x:f},{begin:t,end:n,strides:r,beginMask:i,endMask:s,ellipsisMask:l,newAxisMask:c,shrinkAxisMask:h})}}),nw=(0,s.op)({tan_:function(e){let t=(0,u._1)(e,"x","tan","float32");return o.BV.runKernel(a.sEM,{x:t})}});var nv=n(1802),nk=n(1185);function n_(e,t){(0,f.Cq)(e);let n=(0,u.C)(e,t);if(1!==n.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return(0,nk.H)(e,null,n,t)}function nx(e,t,n){if((0,f.Cq)(e),null!=t&&2!==t.length)throw Error("tensor2d() requires shape to have two numbers");let r=(0,u.C)(e,n);if(2!==r.length&&1!==r.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,nk.H)(e,t,r,n)}var nE=n(1051);function nS(e,t,n){if((0,f.Cq)(e),null!=t&&4!==t.length)throw Error("tensor4d() requires shape to have four numbers");let r=(0,u.C)(e,n);if(4!==r.length&&1!==r.length)throw Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,nk.H)(e,t,r,n)}function n$(e,t,n){if((0,f.Cq)(e),null!=t&&5!==t.length)throw Error("tensor5d() requires shape to have five numbers");let r=(0,u.C)(e,n);if(5!==r.length&&1!==r.length)throw Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,nk.H)(e,t,r,n)}function nB(e,t,n){if((0,f.Cq)(e),null!=t&&6!==t.length)throw Error("tensor6d() requires shape to have six numbers");let r=(0,u.C)(e,n);if(6!==r.length&&1!==r.length)throw Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,nk.H)(e,t,r,n)}var nA=n(8604);let nI=(0,s.op)({tensorScatterUpdate_:function(e,t,n){let r=(0,u._1)(e,"tensor","tensorScatterupdate"),i=(0,u._1)(t,"indices","tensorScatterupdate","int32"),s=(0,u._1)(n,"updates","tensorScatterupdate");if(nA.validateInput(s,i,r.shape),r.dtype!==s.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);return o.BV.runKernel(a.SIB,{tensor:r,indices:i,updates:s},{})}}),nT=(0,s.op)({topk_:function(e,t=1,n=!0){let r=(0,u._1)(e,"x","topk");if(0===r.rank)throw Error("topk() expects the input to be of rank 1 or higher");let i=r.shape[r.shape.length-1];if(t<0)throw Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);let[s,l]=o.BV.runKernel(a.cWu,{x:r},{k:t,sorted:n});return{values:s,indices:l}}}),nN=(0,s.op)({truncatedNormal_:function(e,t=0,n=1,r,i){if((0,f.Mu)(e),null!=r&&"bool"===r)throw Error("Unsupported data type $ { dtype }");let o=new tU(t,n,r,!0,i),a=(0,K.f)(e,r);for(let e=0;e<a.values.length;e++)a.values[e]=o.nextValue();return a.toTensor()}}),nM=(0,s.op)({unique_:function(e,t=0){let n=(0,u._1)(e,"x","unique","string_or_numeric");(0,f.hu)(n.rank>0,()=>"The input tensor must be at least 1D");let[r,i]=o.BV.runKernel(a.kpP,{x:n},{axis:t});return{values:r,indices:i}}}),nD=(0,s.op)({unsortedSegmentSum_:function(e,t,n){let r=(0,u._1)(e,"x","unsortedSegmentSum"),i=(0,u._1)(t,"segmentIds","unsortedSegmentSum","int32");return(0,f.hu)((0,f.GN)(n),()=>"numSegments must be of dtype int"),o.BV.runKernel(a.Qvg,{x:r,segmentIds:i},{numSegments:n})}}),nR=(0,s.op)({unstack_:function(e,t=0){let n=(0,u._1)(e,"x","unstack","string_or_numeric");return f.hu(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),o.BV.runKernel(a.ToN,{value:n},{axis:t})}});function nV(e,t){return ta(e,t,"right")}function nO(e,t=!0,n,r){return o.BV.makeVariable(e,t,n,r)}var nC=n(9846);let nF=async function(e){let t=(0,u._1)(e,"condition","whereAsync","bool"),n=await t.data(),r=(0,nC.Z)(t.shape,n);return e!==t&&t.dispose(),r},nP=async function(e,t,n){let r=(0,u._1)(e,"tensor","boolMask"),i=(0,u._1)(t,"mask","boolMask","bool"),o=null==n?0:n,a=i.rank,s=r.shape;f.hu(a>0,()=>"mask cannot be scalar"),f.k5(s.slice(o,o+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=o;e<o+a;e++)l*=s[e];let c=s.slice(0,o).concat([l],s.slice(o+a)),h=(0,$.X)(r,c),d=(0,$.X)(i,[-1]),p=await nF(d),g=ng(p,[1]),m=eq(h,g,o);return e!==r&&r.dispose(),t!==i&&i.dispose(),g.dispose(),h.dispose(),d.dispose(),p.dispose(),m};var nL=n(5250);let nG=(0,s.op)({movingAverage_:function(e,t,n,r,i=!0){let o=(0,u._1)(e,"v","movingAverage"),a=(0,u._1)(t,"x","movingAverage"),s=(0,u._1)(n,"decay","movingAverage");(0,k.assertTypesMatch)(o,a),f.hu(f.cO(o.shape,a.shape),()=>"Shape mismatch in v and x");let l=(0,eM.i)(1),c=(0,e9.l)(l,s),d=(0,M.d)((0,e9.l)(a,o),c);if(i){f.hu(null!=r,()=>"When using zeroDebias: true, step is required.");let e=(0,u._1)(r,"step","movingAverage");d=(0,eb.h)(d,(0,e9.l)(l,(0,eN.s)(s,e)))}return(0,h.I)(o,d)}}),nU=(0,s.op)({scatterND_:function(e,t,n){(0,f.Mu)(n);let r=(0,u._1)(e,"indices","scatterND","int32"),i=(0,u._1)(t,"updates","scatterND");return nA.validateInput(i,r,n),o.BV.runKernel(a.xQA,{indices:r,updates:i},{shape:n})}}),nz=(0,s.op)({sparseToDense_:function(e,t,n,r=0){(0,f.Mu)(n);let i=(0,u._1)(e,"sparseIndices","sparseToDense","int32"),s=(0,u._1)(t,"sparseValues","sparseToDense","string_or_numeric"),l=(0,u._1)(r,"defaultValue","sparseToDense",s.dtype);return!function(e,t,n,r){if("int32"!==e.dtype)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let i=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);let a=t.size;if(!(0===t.rank||1===t.rank&&a===i))throw Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==r.dtype)throw Error("sparseValues.dtype must match defaultValues.dtype")}(i,s,n,l),o.BV.runKernel(a.D2d,{sparseIndices:i,sparseValues:s,defaultValue:l},{outputShape:n})}}),nW=(0,s.op)({gatherND_:function(e,t){let n=(0,u._1)(t,"indices","gatherND","int32"),r=(0,u._1)(e,"x","gatherND","string_or_numeric");return o.BV.runKernel(a.q1x,{params:r,indices:n})}}),nq=(0,s.op)({dropout_:function(e,t,n,r){let i=(0,u._1)(e,"x","dropout");if(f.hu("float32"===i.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),f.hu(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof tg.es?i.clone():i;let o=function(e,t){if(null==t)return e.shape.slice();if(f.cO(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(i,n),a=1-t,s=(0,eb.h)(ez((0,h.I)(tj(o,0,1,"float32",r),a)),a);return(0,M.d)(i,s)}});function nK(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function nH(e,t,n){let r=1-e%2,i=new Float32Array(e);for(let o=0;o<e;++o){let a=2*Math.PI*o/(e+r-1);i[o]=t-n*Math.cos(a)}return n_(i,"float32")}let nj=async function(e,t,n=1){let r=(0,u._1)(e,"predictions","inTopK"),i=(0,u._1)(t,"targets","inTopK");(0,f.hu)(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),(0,f.hu)(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),(0,f.k5)(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let o=r.shape[r.shape.length-1];(0,f.hu)(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);let a=await r.data(),s=await i.data(),[l,c]=[a.length/o,o],h=(0,f.WP)("bool",l);for(let e=0;e<l;e++){let t=e*c,r=a.subarray(t,t+c),i=[];for(let e=0;e<r.length;e++)i.push({value:r[e],index:e});i.sort((e,t)=>t.value-e.value),h[e]=0;for(let t=0;t<n;t++)if(i[t].index===s[e]){h[e]=1;break}}return e!==r&&r.dispose(),t!==i&&i.dispose(),(0,nv.X)(h,i.shape,"bool")},nX=(0,s.op)({conv2DBackpropFilter_:function(e,t,n,r,i,u="NHWC",s){let l=e;3===e.rank&&(l=(0,$.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=(0,$.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),f.hu(4===l.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),f.hu(4===c.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),f.hu(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let h="NHWC"===u?l.shape[3]:l.shape[1],d="NHWC"===u?c.shape[3]:c.shape[1];f.hu(h===n[2],()=>`Error in conv2dDerFilter: depth of input ${h}) must match input depth in filter (${n[2]}.`),f.hu(d===n[3],()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`),S.m("conv2dDerFilter",i,s);let p={x:l,dy:c};return o.BV.runKernel(a.wUP,p,{strides:r,pad:i,dataFormat:u,dimRoundingMode:s,filterShape:n})}});var nZ=n(1575);let nJ=(0,s.op)({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:l,bias:c,activation:d="linear",preluActivationWeights:p,leakyreluAlpha:g}){let m,b;if(d=d||"linear",!1===(0,nZ.uy)(o.BV.state.gradientDepth,d)){f.hu("NHWC"===i,()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let o=et(e,t,n,r,i,s,l);return null!=c&&(o=(0,h.I)(o,c)),(0,nZ.QH)(o,d,p,g)}let y=(0,u._1)(e,"x","conv2d","float32"),w=(0,u._1)(t,"filter","conv2d","float32"),v=y,_=!1;3===y.rank&&(_=!0,v=(0,$.X)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),f.hu(4===v.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${v.rank}.`),f.hu(4===w.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${w.rank}.`),S.m("fused conv2d",r,l);let x="NHWC"===i?v.shape[3]:v.shape[1];f.hu(w.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${w.shape[2]}.`),f.hu(S.jT(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let E=S.Ix(v.shape,w.shape,n,s,r,l);if(null!=c&&(m=(0,u._1)(c,"bias","fused conv2d"),[m]=(0,k.makeTypesMatch)(m,y),"NHWC"===i?ey.assertAndGetBroadcastShape(E.outShape,m.shape):(f.hu(m.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${m.shape.length}.`),f.hu(0===m.shape.length||m.shape[0]===E.outChannels||1===m.shape[0],()=>`Error in fused conv2d: bias shape (${m.shape}) is not compatible with the number of output channels (${E.outChannels})`))),null!=p){let e=p.shape;if(f.hu(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)f.hu(1===e[0]||e[0]===E.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${E.outChannels}).`);else if(3===e.length)try{ey.assertAndGetBroadcastShape(e,E.outShape)}catch(t){throw Error(`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${E.outShape}).`)}b=(0,u._1)(p,"prelu weights","fused conv2d")}let B=(e,t)=>{f.hu("NHWC"===i,()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);let[o,a,u,l]=t,c=(0,nZ.Fr)(e,u,d);f.hu(S.I0(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let h=[er(a.shape,c,o,n,r),nX(a,c,o.shape,n,r)];if(null!=l){let e=(0,nZ.pf)(l,c);h.push(e)}return h},A={x:v,filter:w,bias:m,preluActivationWeights:b},I={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:l,activation:d,leakyreluAlpha:g};return null==c?(0,e6.cb)((e,t,n)=>{let r=o.BV.runKernel(a._V0,A,I);return n([t,e,r]),_&&(r=(0,$.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:B}})(v,w):(0,e6.cb)((e,t,n,r)=>{let i=o.BV.runKernel(a._V0,A,I);return r([t,e,i,n]),_&&(i=(0,$.X)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:B}})(v,w,m)}}),nY=(0,s.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,i,u=[1,1],s){let l=e;3===e.rank&&(l=(0,$.X)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=(0,$.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h={x:l,dy:c};return o.BV.runKernel(a.sL$,h,{strides:r,pad:i,dimRoundingMode:s,dilations:u,filterShape:n})}}),nQ=(0,s.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,i,u=[1,1],s){let l=t,c=!1;3===t.rank&&(c=!0,l=(0,$.X)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h={dy:l,filter:n},f=o.BV.runKernel(a.y7R,h,{strides:r,pad:i,dimRoundingMode:s,dilations:u,inputShape:e});return c?(0,$.X)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),n0=(0,s.op)({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:l,bias:c,activation:d="linear",preluActivationWeights:p,leakyreluAlpha:g}){let m,b;if(!1===(0,nZ.uy)(o.BV.state.gradientDepth,d)){let o=ep(e,t,n,r,i,s,l);return null!=c&&(o=(0,h.I)(o,c)),(0,nZ.QH)(o,d,p,g)}let y=(0,u._1)(e,"x","depthwiseConv2d","float32"),w=(0,u._1)(t,"filter","depthwiseConv2d","float32"),v=y,_=!1;3===y.rank&&(_=!0,v=(0,$.X)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),f.hu(4===v.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`),f.hu(4===w.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${w.rank}.`),f.hu(v.shape[3]===w.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${v.shape[3]}) must match the inChannels dimension in filter ${w.shape[2]}.`),null==s&&(s=[1,1]),f.hu(S.jT(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),S.m("fused depthwiseConv2d",r,l);let x=S.Ix(v.shape,w.shape,n,s,r,l,!0);null!=c&&(m=(0,u._1)(c,"bias","fused conv2d"),[m]=(0,k.makeTypesMatch)(m,y),ey.assertAndGetBroadcastShape(x.outShape,m.shape)),null!=p&&(b=(0,u._1)(p,"prelu weights","fused depthwiseConv2d"));let E=(e,t)=>{f.hu(S.I0(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[i,o,a,u]=t,c=(0,nZ.Fr)(e,a,d),h=nQ(o.shape,c,i,n,r,s,l),p=nY(o,c,i.shape,n,r,s,l);return null!=u?[h,p,(0,nZ.pf)(m,c)]:[h,p]},B={x:v,filter:w,bias:m,preluActivationWeights:b},A={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:l,activation:d,leakyreluAlpha:g};return null==c?(0,e6.cb)((e,t,n)=>{let r=o.BV.runKernel(a.luS,B,A);return n([t,e,r]),_&&(r=(0,$.X)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:E}})(v,w):(0,e6.cb)((e,t,n,r)=>{let i=o.BV.runKernel(a.luS,B,A);return r([t,e,i,n]),_&&(i=(0,$.X)(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:E}})(v,w,m)}}),n1=(0,s.op)({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:l,leakyreluAlpha:c=.2}){let d,p;if(!1===(0,nZ.uy)(o.BV.state.gradientDepth,s)){let o=(0,N.O)(e,t,n,r);return null!=i&&(o=(0,h.I)(o,i)),(0,nZ.QH)(o,s,l,c)}let g=(0,u._1)(e,"a","fused matMul"),m=(0,u._1)(t,"b","fused matMul");[g,m]=(0,k.makeTypesMatch)(g,m);let b=n?g.shape[g.rank-2]:g.shape[g.rank-1],y=r?m.shape[m.rank-1]:m.shape[m.rank-2],w=n?g.shape[g.rank-1]:g.shape[g.rank-2],v=r?m.shape[m.rank-2]:m.shape[m.rank-1],_=g.shape.slice(0,-2),x=m.shape.slice(0,-2),E=f.NA(_),S=f.NA(x);f.hu(b===y,()=>`Error in fused matMul: inner shapes (${b}) and (${y}) of Tensors with shapes ${g.shape} and ${m.shape} and transposeA=${n} and transposeB=${r} must match.`);let B=ey.assertAndGetBroadcastShape(g.shape.slice(0,-2),m.shape.slice(0,-2)).concat([w,v]),A=n?(0,$.X)(g,[E,b,w]):(0,$.X)(g,[E,w,b]),I=r?(0,$.X)(m,[S,v,y]):(0,$.X)(m,[S,y,v]);null!=i&&(d=(0,u._1)(i,"bias","fused matMul"),[d]=(0,k.makeTypesMatch)(d,g),ey.assertAndGetBroadcastShape(B,d.shape)),null!=l&&(p=(0,u._1)(l,"prelu weights","fused matMul"));let T=(e,t)=>{let o,a;let[u,l,c,h]=t,f=(0,nZ.Fr)((0,$.X)(e,c.shape),c,s);return(n||r?!n&&r?(o=(0,N.O)(f,l,!1,!1),a=(0,N.O)(f,u,!0,!1)):n&&!r?(o=(0,N.O)(l,f,!1,!0),a=(0,N.O)(u,f,!1,!1)):(o=(0,N.O)(l,f,!0,!0),a=(0,N.O)(f,u,!0,!0)):(o=(0,N.O)(f,l,!1,!0),a=(0,N.O)(u,f,!0,!1)),null!=i)?[o,a,(0,nZ.pf)(h,f)]:[o,a]},M={a:A,b:I,bias:d,preluActivationWeights:p},D={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:c};return null==i?(0,e6.cb)((e,t,n)=>{let r=o.BV.runKernel(a.usg,M,D);return n([e,t,r]),{value:(0,$.X)(r,B),gradFunc:T}})(A,I):(0,e6.cb)((e,t,n,r)=>{let i=o.BV.runKernel(a.usg,M,D);return r([e,t,i,n]),{value:(0,$.X)(i,B),gradFunc:T}})(A,I,d)}}),n2=(0,s.op)({hammingWindow_:function(e){return nH(e,.54,.46)}}),n3=(0,s.op)({hannWindow_:function(e){return nH(e,.5,.5)}}),n4=(0,s.op)({frame_:function(e,t,n,r=!1,i=0){let o=0,a=[];for(;o+t<=e.size;)a.push(R(e,o,t)),o+=n;if(r)for(;o<e.size;){let r=o+t-e.size,u=T([R(e,o,t-r),(0,j.h)([r],i)]);a.push(u),o+=n}return 0===a.length?nx([],[0,t]):(0,$.X)(T(a),[a.length,t])}}),n6=(0,s.op)({stft_:function(e,t,n,r,i=n3){null==r&&(r=nK(t));let o=n4(e,t,n);return nd((0,M.d)(o,i(t)),r)}}),n5=(0,s.op)({cropAndResize_:function(e,t,n,r,i="bilinear",s=0){let l=(0,u._1)(e,"image","cropAndResize"),c=(0,u._1)(t,"boxes","cropAndResize","float32"),h=(0,u._1)(n,"boxInd","cropAndResize","int32"),d=c.shape[0];return f.hu(4===l.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${l.rank}.`),f.hu(2===c.rank&&4===c.shape[1],()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${c.shape}.`),f.hu(1===h.rank&&h.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${c.shape}.`),f.hu(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),f.hu(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),f.hu("bilinear"===i||"nearest"===i,()=>`method must be bilinear or nearest, but was ${i}`),o.BV.runKernel(a.VcC,{image:l,boxes:c,boxInd:h},{method:i,extrapolationValue:s,cropSize:r})}}),n7=(0,s.op)({flipLeftRight_:function(e){let t=(0,u._1)(e,"image","flipLeftRight","float32");return f.hu(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),o.BV.runKernel(a.Uyb,{image:t},{})}}),n8=(0,s.op)({grayscaleToRGB_:function(e){let t=(0,u._1)(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];f.hu(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),f.hu(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let i=Array(t.rank);return i.fill(1,0,n),i[n]=3,eG(t,i)}}),n9=(0,s.op)({rgbToGrayscale_:function(e){let t;let n=(0,u._1)(e,"image","RGBToGrayscale"),r=n.rank-1,i=n.shape[r];f.hu(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),f.hu(3===i,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${i}.`);let o=n.dtype,a=(0,E.p)(n,"float32"),s=n_([.2989,.587,.114]);switch(n.rank){case 2:t=eE("ij,j->i",a,s);break;case 3:t=eE("ijk,k->ij",a,s);break;case 4:t=eE("ijkl,l->ijk",a,s);break;case 5:t=eE("ijklm,m->ijkl",a,s);break;case 6:t=eE("ijklmn,n->ijklm",a,s);break;default:throw Error("Not a valid tensor rank.")}return t=eP(t,-1),(0,E.p)(t,o)}}),re=(0,s.op)({rotateWithOffset_:function(e,t,n=0,r=.5){let i=(0,u._1)(e,"image","rotateWithOffset","float32");return f.hu(4===i.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`),o.BV.runKernel(a.b9H,{image:i},{radians:t,fillValue:n,center:r})}});function rt(e,t,n,r,i,o){null==r&&(r=.5),null==i&&(i=Number.NEGATIVE_INFINITY),null==o&&(o=0);let a=e.shape[0];return n=Math.min(n,a),f.hu(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),f.hu(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),f.hu(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),f.hu(1===t.rank,()=>"scores must be a 1D tensor"),f.hu(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),f.hu(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:o}}let rn=(0,s.op)({nonMaxSuppression_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){let s=(0,u._1)(e,"boxes","nonMaxSuppression","float32"),l=(0,u._1)(t,"scores","nonMaxSuppression","float32"),c=rt(s,l,n,r,i),h={maxOutputSize:n=c.maxOutputSize,iouThreshold:r=c.iouThreshold,scoreThreshold:i=c.scoreThreshold};return o.BV.runKernel(a.uv1,{boxes:s,scores:l},h)}});var rr=n(3021);async function ri(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY){let o=(0,u._1)(e,"boxes","nonMaxSuppressionAsync"),a=(0,u._1)(t,"scores","nonMaxSuppressionAsync"),s=rt(o,a,n,r,i);n=s.maxOutputSize,r=s.iouThreshold,i=s.scoreThreshold;let l=await Promise.all([o.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:f}=(0,rr.GP)(c,h,n,r,i);return o!==e&&o.dispose(),a!==t&&a.dispose(),n_(f,"int32")}let ro=(0,s.op)({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){let l=(0,u._1)(e,"boxes","nonMaxSuppression"),c=(0,u._1)(t,"scores","nonMaxSuppression"),h=rt(l,c,n,r,i,s);n=h.maxOutputSize,r=h.iouThreshold;let f={maxOutputSize:n,iouThreshold:r,scoreThreshold:i=h.scoreThreshold,softNmsSigma:s=h.softNmsSigma},d=o.BV.runKernel(a.W0H,{boxes:l,scores:c},f);return{selectedIndices:d[0],selectedScores:d[1]}}});async function ra(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,o=0){let a=(0,u._1)(e,"boxes","nonMaxSuppressionAsync"),s=(0,u._1)(t,"scores","nonMaxSuppressionAsync"),l=rt(a,s,n,r,i,o);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,o=l.softNmsSigma;let c=await Promise.all([a.data(),s.data()]),h=c[0],f=c[1],{selectedIndices:d,selectedScores:p}=(0,rr.pA)(h,f,n,r,i,o);return a!==e&&a.dispose(),s!==t&&s.dispose(),{selectedIndices:n_(d,"int32"),selectedScores:n_(p)}}let ru=(0,s.op)({nonMaxSuppressionPadded_:function(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){let l=(0,u._1)(e,"boxes","nonMaxSuppression"),c=(0,u._1)(t,"scores","nonMaxSuppression"),h=rt(l,c,n,r,i,null),f=h.maxOutputSize,d=h.iouThreshold,p=h.scoreThreshold,g=o.BV.runKernel(a.cye,{boxes:l,scores:c},{maxOutputSize:f,iouThreshold:d,scoreThreshold:p,padToMaxOutputSize:s});return{selectedIndices:g[0],validOutputs:g[1]}}});async function rs(e,t,n,r=.5,i=Number.NEGATIVE_INFINITY,o=!1){let a=(0,u._1)(e,"boxes","nonMaxSuppressionAsync"),s=(0,u._1)(t,"scores","nonMaxSuppressionAsync"),l=rt(a,s,n,r,i,null),c=l.maxOutputSize,h=l.iouThreshold,f=l.scoreThreshold,[d,p]=await Promise.all([a.data(),s.data()]),{selectedIndices:g,validOutputs:m}=(0,rr.qP)(d,p,c,h,f,o);return a!==e&&a.dispose(),s!==t&&s.dispose(),{selectedIndices:n_(g,"int32"),validOutputs:(0,eM.i)(m,"int32")}}let rl=(0,s.op)({resizeBilinear_:function(e,t,n=!1,r=!1){let i=(0,u._1)(e,"images","resizeBilinear");f.hu(3===i.rank||4===i.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),f.hu(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),f.hu(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,l=!1;3===i.rank&&(l=!0,s=(0,$.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let[]=t,c={images:s},h=o.BV.runKernel(a._Yw,c,{alignCorners:n,halfPixelCenters:r,size:t});return l?(0,$.X)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),rc=(0,s.op)({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){let i=(0,u._1)(e,"images","resizeNearestNeighbor");f.hu(3===i.rank||4===i.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),f.hu(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),f.hu("float32"===i.dtype||"int32"===i.dtype,()=>"`images` must have `int32` or `float32` as dtype"),f.hu(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,l=!1;3===i.rank&&(l=!0,s=(0,$.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let[]=t,c={images:s},h=o.BV.runKernel(a.dpD,c,{alignCorners:n,halfPixelCenters:r,size:t});return l?(0,$.X)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),rh=(0,s.op)({threshold_:function(e,t="binary",n=!1,r=.5){let i,o,a,s;let l=(0,u._1)(e,"image","threshold"),c=l.shape[0]*l.shape[1],d=(0,M.d)(n_([r]),255);if(f.hu(3===l.rank,()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`),f.hu(3===l.shape[2]||1===l.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`),f.hu("int32"===l.dtype||"float32"===l.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`),f.hu("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===l.shape[2]){[i,o,a]=nf(l,[1,1,1],-1);let e=(0,M.d)(i,.2989),t=(0,M.d)(o,.587),n=(0,M.d)(a,.114);s=(0,h.I)((0,h.I)(e,t),n)}else s=e;"otsu"===t&&(d=function(e,t){let n,r,i,o,a,u,s=n_([-1]),l=n_([0]),c=n_([0]);for(let f=0;f<e.size-1;f++){n=R(e,0,f+1),r=R(e,f+1),a=(0,eb.h)((0,eV.S)(n),t),u=(0,eb.h)((0,eV.S)(r),t);let d=(0,eV.S)((0,M.d)(n,tZ(0,n.size)));i=(0,eb.h)(d,(0,eV.S)(n));let p=(0,j.h)(r.shape,n.size),g=(0,h.I)(tZ(0,r.size),p),m=(0,M.d)(r,g);o=(0,eb.h)((0,eV.S)(m),(0,eV.S)(r));let b=(0,e9.l)(i,o),y=(0,e9.l)(i,o),w=(0,M.d)(a,u),v=eK(c=(0,M.d)((0,M.d)(w,b),y),l);l=ev(v,c,l),s=ev(v,n_([f]),s)}return s}(U((0,E.p)(t5(s),"int32"),(0,nv.X)([]),256),c));let p=n?e0(s,d):eK(s,d);return(0,E.p)((0,M.d)(p,255),"int32")}}),rf=(0,s.op)({transform_:function(e,t,n="nearest",r="constant",i=0,s){let l=(0,u._1)(e,"image","transform","float32"),c=(0,u._1)(t,"transforms","transform","float32");return f.hu(4===l.rank,()=>`Error in transform: image must be rank 4,but got rank ${l.rank}.`),f.hu(2===c.rank&&(c.shape[0]===l.shape[0]||1===c.shape[0])&&8===c.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),f.hu(null==s||2===s.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`),o.BV.runKernel(a.wx7,{image:l,transforms:c},{interpolation:n,fillMode:r,fillValue:i,outputShape:s})}}),rd=(0,s.op)({bandPart_:function(e,t,n){let r,i;let o=(0,u._1)(e,"a","bandPart");(0,f.hu)(o.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${o.rank}.`);let a=o.shape,[s,l]=o.shape.slice(-2);"number"==typeof t?((0,f.hu)(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),(0,f.hu)(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),r=(0,u._1)(t<0?s:t,"numLower","bandPart")):((0,f.hu)("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),r=ev(eQ(t,0),s,tb(t,s))),"number"==typeof n?((0,f.hu)(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),(0,f.hu)(n<=l,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`),i=(0,u._1)(n<0?l:n,"numUpper","bandPart")):((0,f.hu)("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),i=ev(eQ(n,0),l,tb(n,l)));let c=(0,$.X)(tZ(0,s,1,"int32"),[-1,1]),h=tZ(0,l,1,"int32"),d=(0,e9.l)(c,h),p=tn(e0(d,r),eH(d,(0,e5.W)(i))),g=td([s,l],o.dtype);return(0,$.X)(nm(nR((0,$.X)(o,[-1,s,l])).map(e=>ev(p,e,g))),a)}}),rp=(0,s.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,f.hu)(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,f.hu)(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=nf(e,e.shape[0],0).map(e=>ng(e,[0]));(0,f.hu)(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let t=0;t<e.length;++t)n.push(o.BV.tidy(()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){let t=(0,M.d)((0,eV.S)((0,M.d)(n[r],e)),n[r]);e=(0,e9.l)(e,t)}return(0,eb.h)(e,eO(e,"euclidean"))}));return t?nm(n,0):n}});var rg=n(5823);function rm(e,t=!1){return o.BV.tidy(()=>{(0,f.hu)(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],i=eU(n),a=(0,I.d)(e),u=nx([[1]],[1,1]),s=(0,I.d)(u),l=n>=r?r:n;for(let e=0;e<l;++e){let t=a,l=s,c=i;[s,a,i]=o.BV.tidy(()=>{let t=R(a,[e,e],[n-e,1]),o=eO(t),l=R(a,[e,e],[1,1]),c=ev(eK(l,0),nx([[-1]]),nx([[1]])),h=(0,e9.l)(l,(0,M.d)(c,o)),f=(0,eb.h)(t,h);s=1===f.shape[0]?(0,I.d)(u):T([u,R(f,[1,0],[f.shape[0]-1,f.shape[1]])],0);let d=(0,e5.W)((0,eb.h)((0,N.O)(c,h),o)),p=R(a,[e,0],[n-e,r]),g=(0,M.d)(d,s),m=(0,nL.p)(s);if(0===e)a=(0,e9.l)(p,(0,N.O)(g,(0,N.O)(m,p)));else{let t=(0,e9.l)(p,(0,N.O)(g,(0,N.O)(m,p)));a=T([R(a,[0,0],[e,r]),t],0)}let b=(0,nL.p)(g),y=R(i,[0,e],[n,i.shape[1]-e]);if(0===e)i=(0,e9.l)(y,(0,N.O)((0,N.O)(y,s),b));else{let t=(0,e9.l)(y,(0,N.O)((0,N.O)(y,s),b));i=T([R(i,[0,0],[n,e]),t],1)}return[s,a,i]}),(0,rg.B9)([t,l,c])}return!t&&n>r&&(i=R(i,[0,0],[n,r]),a=R(a,[0,0],[r,r])),[i,a]})}let rb=(0,s.op)({qr_:function(e,t=!1){if((0,f.hu)(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return rm(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=nR((0,$.X)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),i=[],o=[];return r.forEach(e=>{let[n,r]=rm(e,t);i.push(n),o.push(r)}),[(0,$.X)(nm(i,0),e.shape),(0,$.X)(nm(o,0),e.shape)]}}});var ry=n(6405);let rw=(0,s.op)({computeWeightedLoss_:function(e,t,n=ry.I.SUM_BY_NONZERO_WEIGHTS){let r=(0,u._1)(e,"losses","computeWeightedLoss"),i=null;null!=t&&(i=(0,u._1)(t,"weights","computeWeightedLoss"));let o=null==i?r:(0,M.d)(r,i);if(n===ry.I.NONE)return o;if(n===ry.I.SUM)return(0,eV.S)(o);if(n===ry.I.MEAN){if(null==i)return tf(o);{let e=r.size/i.size,t=(0,eb.h)((0,eV.S)(o),(0,eV.S)(i));return e>1?(0,eb.h)(t,(0,eM.i)(e)):t}}if(n===ry.I.SUM_BY_NONZERO_WEIGHTS){if(null==i)return(0,eb.h)((0,eV.S)(o),(0,eM.i)(r.size));{let e=(0,M.d)(i,tp(r.shape)),t=(0,E.p)((0,eV.S)(tx(e,(0,eM.i)(0))),"float32");return(0,eb.h)((0,eV.S)(o),t)}}throw Error(`Unknown reduction: ${n}`)}}),rv=(0,s.op)({absoluteDifference_:function(e,t,n,r=ry.I.SUM_BY_NONZERO_WEIGHTS){let o=(0,u._1)(e,"labels","absoluteDifference"),a=(0,u._1)(t,"predictions","absoluteDifference"),s=null;return null!=n&&(s=(0,u._1)(n,"weights","absoluteDifference")),(0,f.k5)(o.shape,a.shape,"Error in absoluteDifference: "),rw((0,i.W)((0,e9.l)(o,a)),s,r)}}),rk=(0,s.op)({cosineDistance_:function(e,t,n,r,i=ry.I.SUM_BY_NONZERO_WEIGHTS){let o=(0,u._1)(e,"labels","cosineDistance"),a=(0,u._1)(t,"predictions","cosineDistance"),s=null;null!=r&&(s=(0,u._1)(r,"weights","cosineDistance")),(0,f.k5)(o.shape,a.shape,"Error in cosineDistance: ");let l=(0,eM.i)(1);return rw((0,e9.l)(l,(0,eV.S)((0,M.d)(o,a),n,!0)),s,i)}}),r_=(0,s.op)({hingeLoss_:function(e,t,n,r=ry.I.SUM_BY_NONZERO_WEIGHTS){let i=(0,u._1)(e,"labels","hingeLoss"),o=(0,u._1)(t,"predictions","hingeLoss"),a=null;null!=n&&(a=(0,u._1)(n,"weights","hingeLoss")),(0,f.k5)(i.shape,o.shape,"Error in hingeLoss: ");let s=(0,eM.i)(1);return i=(0,e9.l)((0,M.d)((0,eM.i)(2),i),s),rw((0,tQ.U)((0,e9.l)(s,(0,M.d)(i,o))),a,r)}}),rx=(0,s.op)({huberLoss_:function(e,t,n,r=1,o=ry.I.SUM_BY_NONZERO_WEIGHTS){let a=(0,u._1)(e,"labels","huberLoss"),s=(0,u._1)(t,"predictions","huberLoss"),l=null;null!=n&&(l=(0,u._1)(n,"weights","huberLoss")),(0,f.k5)(a.shape,s.shape,"Error in huberLoss: ");let c=(0,eM.i)(r),d=(0,i.W)((0,e9.l)(s,a)),p=tb(d,c),g=(0,e9.l)(d,p);return rw((0,h.I)((0,M.d)((0,eM.i)(.5),(0,eR.h)(p)),(0,M.d)(c,g)),l,o)}}),rE=(0,s.op)({logLoss_:function(e,t,n,r=1e-7,i=ry.I.SUM_BY_NONZERO_WEIGHTS){let o=(0,u._1)(e,"labels","logLoss"),a=(0,u._1)(t,"predictions","logLoss"),s=null;null!=n&&(s=(0,u._1)(n,"weights","logLoss")),(0,f.k5)(o.shape,a.shape,"Error in logLoss: ");let l=(0,eM.i)(1),c=(0,eM.i)(r),d=(0,e5.W)((0,M.d)(o,e3((0,h.I)(a,c)))),p=(0,M.d)((0,e9.l)(l,o),e3((0,h.I)((0,e9.l)(l,a),c)));return rw((0,e9.l)(d,p),s,i)}}),rS=(0,s.op)({meanSquaredError_:function(e,t,n,r=ry.I.SUM_BY_NONZERO_WEIGHTS){let i=(0,u._1)(e,"labels","meanSquaredError"),o=(0,u._1)(t,"predictions","meanSquaredError"),a=null;return null!=n&&(a=(0,u._1)(n,"weights","meanSquaredError")),(0,f.k5)(i.shape,o.shape,"Error in meanSquaredError: "),rw(np(i,o),a,r)}}),r$=(0,s.op)({sigmoidCrossEntropy_:function(e,t,n,r=0,o=ry.I.SUM_BY_NONZERO_WEIGHTS){let a=(0,u._1)(e,"multiClassLabels","sigmoidCrossEntropy"),s=(0,u._1)(t,"logits","sigmoidCrossEntropy"),l=null;if(null!=n&&(l=(0,u._1)(n,"weights","sigmoidCrossEntropy")),(0,f.k5)(a.shape,s.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=(0,eM.i)(r),t=(0,eM.i)(1),n=(0,eM.i)(.5);a=(0,h.I)((0,M.d)(a,(0,e9.l)(t,e)),(0,M.d)(n,e))}return rw(function(e,t){let n=(0,u._1)(e,"labels","sigmoidCrossEntropyWithLogits"),r=(0,u._1)(t,"logits","sigmoidCrossEntropyWithLogits");(0,f.k5)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=(0,tQ.U)(r),a=(0,M.d)(r,n),s=e4(eF((0,e5.W)((0,i.W)(r))));return(0,h.I)((0,e9.l)(o,a),s)}(a,s),l,o)}}),rB=(0,s.op)({softmaxCrossEntropy_:function(e,t,n,r=0,i=ry.I.SUM_BY_NONZERO_WEIGHTS){let o=(0,u._1)(e,"onehotLabels","softmaxCrossEntropy"),a=(0,u._1)(t,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=(0,u._1)(n,"weights","softmaxCrossEntropy")),(0,f.k5)(o.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){let e=(0,eM.i)(r),t=(0,eM.i)(1),n=(0,eM.i)(o.shape[1]);o=(0,h.I)((0,M.d)(o,(0,e9.l)(t,e)),(0,eb.h)(e,n))}return rw(function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return(0,e6.cb)((e,t,r)=>{let i=tt(t,[n],!0),o=(0,e9.l)((0,E.p)(t,"float32"),i);r([e,o]);let a=(0,e5.W)((0,M.d)(o,e));return{value:(0,eV.S)(a,[n]),gradFunc:(e,t)=>{let[r,i]=t,o=(0,eA.rv)(e.shape,[n]);return[(0,M.d)((0,$.X)(e,o),(0,e9.l)((0,E.p)(r,"float32"),eF(i))),(0,M.d)((0,$.X)(e,o),(0,e9.l)(eF(i),(0,E.p)(r,"float32")))]}}})(e,t)}(o,a),s,i)}}),rA=(0,s.op)({sparseFillEmptyRows_:function(e,t,n,r){let i=(0,u._1)(e,"indices","sparseFillEmptyRows","int32"),s=(0,u._1)(t,"values","sparseFillEmptyRows"),l=(0,u._1)(n,"denseShape","sparseFillEmptyRows","int32"),c=(0,u._1)(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==i.rank)throw Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(1!==s.rank)throw Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==l.rank)throw Error(`Dense shape should be Tensor1D but received shape ${l.shape}`);if(0!==c.rank)throw Error(`Default value should be a scalar but received shape ${c.shape}`);let h=o.BV.runKernel(a.O3z,{indices:i,values:s,denseShape:l,defaultValue:c});return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}}),rI=(0,s.op)({sparseReshape_:function(e,t,n){let r=(0,u._1)(e,"inputIndices","sparseReshape","int32"),i=(0,u._1)(t,"inputShape","sparseReshape","int32"),s=(0,u._1)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(1!==i.rank)throw Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(1!==s.rank)throw Error(`New shape should be Tensor1D but received shape ${s.shape}`);let l=o.BV.runKernel(a.nhH,{inputIndices:r,inputShape:i,newShape:s});return{outputIndices:l[0],outputShape:l[1]}}}),rT=(0,s.op)({sparseSegmentMean_:function(e,t,n){let r=(0,u._1)(e,"data","sparseSegmentMean"),i=(0,u._1)(t,"indices","sparseSegmentMean","int32"),s=(0,u._1)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);return o.BV.runKernel(a.w3H,{data:r,indices:i,segmentIds:s})}}),rN=(0,s.op)({sparseSegmentSum_:function(e,t,n){let r=(0,u._1)(e,"data","sparseSegmentSum"),i=(0,u._1)(t,"indices","sparseSegmentSum","int32"),s=(0,u._1)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(1!==s.rank)throw Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);return o.BV.runKernel(a.ZjV,{data:r,indices:i,segmentIds:s})}}),rM=(0,s.op)({stringNGrams_:function(e,t,n,r,i,s,l,c){let h=(0,u._1)(e,"data","stringNGrams","string");if("string"!==h.dtype)throw Error("Data must be of datatype string");if(1!==h.shape.length)throw Error(`Data must be a vector, saw: ${h.shape}`);let f=(0,u._1)(t,"dataSplits","stringNGrams");if("int32"!==f.dtype)throw Error("Data splits must be of datatype int32");let d=o.BV.runKernel(a._JP,{data:h,dataSplits:f},{separator:n,nGramWidths:r,leftPad:i,rightPad:s,padWidth:l,preserveShortSequences:c});return{nGrams:d[0],nGramsSplits:d[1]}}}),rD=(0,s.op)({stringSplit_:function(e,t,n=!0){let r=(0,u._1)(e,"input","stringSplit","string"),i=(0,u._1)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==i.rank)throw Error(`Delimiter should be a scalar but received shape ${i.shape}`);let s=o.BV.runKernel(a.s1s,{input:r,delimiter:i},{skipEmpty:n});return{indices:s[0],values:s[1],shape:s[2]}}}),rR=(0,s.op)({stringToHashBucketFast_:function(e,t){let n=(0,u._1)(e,"input","stringToHashBucketFast","string");if(t<=0)throw Error("Number of buckets must be at least 1");return o.BV.runKernel(a.XkS,{input:n},{numBuckets:t})}}),rV=(0,s.op)({staticRegexReplace_:function(e,t,n,r=!0){let i=(0,u._1)(e,"input","staticRegexReplace","string");return o.BV.runKernel(a.e0R,{x:i},{pattern:t,rewrite:n,replaceGlobal:r})}}),rO={fft:nl,ifft:nc,rfft:nd,irfft:nh},rC={hammingWindow:n2,hannWindow:n3,frame:n4,stft:n6},rF={flipLeftRight:n7,grayscaleToRGB:n8,resizeNearestNeighbor:rc,resizeBilinear:rl,rgbToGrayscale:n9,rotateWithOffset:re,cropAndResize:n5,nonMaxSuppression:rn,nonMaxSuppressionAsync:ri,nonMaxSuppressionWithScore:ro,nonMaxSuppressionWithScoreAsync:ra,nonMaxSuppressionPadded:ru,nonMaxSuppressionPaddedAsync:rs,threshold:rh,transform:rf},rP={bandPart:rd,gramSchmidt:rp,qr:rb},rL={absoluteDifference:rv,computeWeightedLoss:rw,cosineDistance:rk,hingeLoss:r_,huberLoss:rx,logLoss:rE,meanSquaredError:rS,sigmoidCrossEntropy:r$,softmaxCrossEntropy:rB},rG={sparseFillEmptyRows:rA,sparseReshape:rI,sparseSegmentMean:rT,sparseSegmentSum:rN},rU={stringNGrams:rM,stringSplit:rD,stringToHashBucketFast:rR,staticRegexReplace:rV}},2611:function(e,t,n){"use strict";n.d(t,{s:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({pow_:function(e,t){let n=(0,a._1)(e,"base","pow"),u=(0,a._1)(t,"exp","pow");[n,u]=(0,o.makeTypesMatch)(n,u);let s={a:n,b:u};return r.BV.runKernel(i.pe_,s)}})},9427:function(e,t,n){"use strict";n.d(t,{A:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({prelu_:function(e,t){let n=(0,o._1)(e,"x","prelu"),a=(0,o._1)(t,"alpha","prelu");return r.BV.runKernel(i.o0g,{x:n,alpha:a})}})},7290:function(e,t,n){"use strict";function r(e,t=!1){console.log(e.toString(t))}n.d(t,{S:function(){return r}})},1773:function(e,t,n){"use strict";n.d(t,{k:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({real_:function(e){let t=(0,o._1)(e,"input","real");return r.BV.runKernel(i.xJR,{input:t})}})},114:function(e,t,n){"use strict";n.d(t,{U:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({relu_:function(e){let t=(0,o._1)(e,"x","relu");return r.BV.runKernel(i.qkr,{x:t})}})},6762:function(e,t,n){"use strict";n.d(t,{b:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({relu6_:function(e){let t=(0,o._1)(e,"x","relu6");return r.BV.runKernel(i.SbG,{x:t})}})},6439:function(e,t,n){"use strict";n.d(t,{X:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({reshape_:function(e,t){let n=(0,o._1)(e,"x","reshape","string_or_numeric");return r.BV.runKernel(i.HZH,{x:n},{shape:t})}})},6070:function(e,t,n){"use strict";n.d(t,{i:function(){return o}});var r=n(2904),i=n(1185);function o(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,i.H)(e,[],[],t)}},8604:function(e,t,n){"use strict";n.r(t),n.d(t,{calculateShapes:function(){return a},validateInput:function(){return o},validateUpdateShape:function(){return i}});var r=n(2771);function i(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw Error(o+` update.rank < ${i}. `);if(e.length<r+(n.rank-i))throw Error(o+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+e.length-r)throw Error(o+` update.rank != ${i+e.length-r}`);for(let e=0;e<i;++e)if(n.shape[e]!==t.shape[e])throw Error(o+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-i;++t)if(n.shape[t+i]!==e[t+r])throw Error(o+` updates.shape[${t+i}] (${n.shape[t+i]}) != shape[${t+i}] (${e[t+i]})`)}function o(e,t,n){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}i(n,t,e)}function a(e,t,n){let i=t.shape.length,o=i>1?t.shape[i-1]:1,a=n.length,u=1;for(let e=o;e<a;++e)u*=n[e];let s=o<1?1:o,l=(0,r.NA)(t.shape)/s,c=[...(0,r.e3)(n.slice(0,o)),1];return{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:(0,r.NA)(n)}}},5986:function(e,t,n){"use strict";n.d(t,{X:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({sigmoid_:function(e){let t=(0,o._1)(e,"x","sigmoid","float32");return r.BV.runKernel(i.a5O,{x:t})}})},9467:function(e,t,n){"use strict";n.d(t,{_:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({sqrt_:function(e){let t=(0,o._1)(e,"x","sqrt","float32");return r.BV.runKernel(i.FKq,{x:t})}})},7941:function(e,t,n){"use strict";n.d(t,{h:function(){return o}});var r=n(9681),i=n(971);let o=(0,n(2888).op)({square_:function(e){let t=(0,i._1)(e,"x","square");return r.BV.runKernel("Square",{x:t},{})}})},9794:function(e,t,n){"use strict";n.d(t,{N:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({step_:function(e,t=0){let n=(0,o._1)(e,"x","step");return r.BV.runKernel(i.h8e,{x:n},{alpha:t})}})},5799:function(e,t,n){"use strict";n.d(t,{l:function(){return u}});var r=n(9681),i=n(5047),o=n(5420),a=n(971);let u=(0,n(2888).op)({sub_:function(e,t){let n=(0,a._1)(e,"a","sub"),u=(0,a._1)(t,"b","sub");[n,u]=(0,o.makeTypesMatch)(n,u);let s={a:n,b:u};return r.BV.runKernel(i.Tr8,s)}})},1101:function(e,t,n){"use strict";n.d(t,{S:function(){return u}});var r=n(9681),i=n(5047),o=n(971),a=n(8893);let u=(0,n(2888).op)({sum_:function(e,t=null,n=!1){let u=(0,o._1)(e,"x","sum");"bool"===u.dtype&&(u=(0,a.p)(u,"int32"));let s={x:u};return r.BV.runKernel(i.GBy,s,{axis:t,keepDims:n})}})},1802:function(e,t,n){"use strict";n.d(t,{X:function(){return o}});var r=n(971),i=n(1185);function o(e,t,n){let o=(0,r.C)(e,n);return(0,i.H)(e,t,o,n)}},1051:function(e,t,n){"use strict";n.d(t,{w:function(){return a}});var r=n(971),i=n(2771),o=n(1185);function a(e,t,n){if((0,i.Cq)(e),null!=t&&3!==t.length)throw Error("tensor3d() requires shape to have three numbers");let a=(0,r.C)(e,n);if(3!==a.length&&1!==a.length)throw Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,o.H)(e,t,a,n)}},1185:function(e,t,n){"use strict";n.d(t,{H:function(){return u}});var r=n(9681),i=n(8638),o=n(2771),a=n(2904);function u(e,t,n,u){if(null==u)u=(0,o.D2)(e);else if("complex64"===u)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,i.$F)(e)||(0,i.Oq)(e)){if("float32"!==u&&"int32"!==u)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${u}.`);return r.BV.backend.createTensorFromGPUData(e,t||n,u)}if(!(0,a.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,o.Mu)(t);let e=(0,o.NA)(t),r=(0,o.NA)(n);(0,o.hu)(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){let r=n[e],i=e!==n.length-1||r!==(0,o.NA)(t.slice(e));(0,o.hu)(n[e]===t[e]||!i,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return(0,a.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==u?(0,a.toTypedArray)(e,u):(0,a.flatten)(e,[],!0),r.BV.makeTensor(e,t,u)}},5250:function(e,t,n){"use strict";n.d(t,{p:function(){return d}});var r=n(9681),i=n(5823),o=n(5047),a=n(971),u=n(2771),s=n(7977),l=n(8587),c=n(2666),h=n(2888),f=n(1773);let d=(0,h.op)({transpose_:function(e,t,n){let h=(0,a._1)(e,"x","transpose");if(null==t&&(t=h.shape.map((e,t)=>t).reverse()),u.hu(h.rank===t.length,()=>`Error in transpose: rank of input ${h.rank} must match length of perm ${t}.`),t.forEach(e=>{u.hu(e>=0&&e<h.rank,()=>`All entries in 'perm' must be between 0 and ${h.rank-1} but got ${t}`)}),h.rank<=1)return h.clone();let d={perm:t};return"complex64"===h.dtype?(0,i.lu)(()=>{let e=(0,f.k)(h),t=(0,l.a)(h);return e=r.BV.runKernel(o.G3Y,{x:e},d),t=r.BV.runKernel(o.G3Y,{x:t},d),n&&(t=(0,c.W)(t)),(0,s.P)(e,t)}):r.BV.runKernel(o.G3Y,{x:h},d)}})},2898:function(e,t,n){"use strict";n.d(t,{P:function(){return a}});var r=n(9681),i=n(5047),o=n(971);let a=(0,n(2888).op)({zerosLike_:function(e){let t=(0,o._1)(e,"x","zerosLike");return r.BV.runKernel(i.RuY,{x:t})}})},8719:function(e,t,n){"use strict";function r(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}n.d(t,{j:function(){return r}})},6150:function(e,t,n){"use strict";n.d(t,{es:function(){return g},YD:function(){return l},_w:function(){return b},t3:function(){return m},FZ:function(){return p},Vp:function(){return d},Vi:function(){return f}});var r=n(5490),i=n(2771);function o(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:(0,i.HD)(e)?`'${e}'`:"bool"===n?a(e):parseFloat(e.toFixed(7)).toString(),(0,i.oj)(r,t)}function a(e){return 0===e?"false":"true"}function u(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var s=n(2904);class l{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=i.NA(e),null!=n){let e=n.length;i.hu(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||i.rQ(t,this.size),this.strides=(0,i.e3)(e)}set(e,...t){0===t.length&&(t=[0]),i.hu(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t])throw Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return c().makeTensor(this.values,this.shape,this.dtype)}}let c=null,h=null;function f(e){c=e}function d(e){h=e}function p(e){}class g{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=i.NA(e),this.strides=(0,i.e3)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return h.buffer(this.shape,this.dtype,e)}bufferSync(){return h.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return(0,i.GX)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,i.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=c().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>s.decodeString(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),c().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=c().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>s.decodeString(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await c().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),c().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(e=!1){return h.print(this,e)}clone(){return this.throwIfDisposed(),h.clone(this)}toString(e=!1){return function(e,t,n,r){let s=(0,i.e3)(t),l=function(e,t,n,r){let a=(0,i.NA)(t),s=r[r.length-1],l=Array(s).fill(0),c=t.length,h="complex64"===n?u(e):e;if(c>1)for(let e=0;e<a/s;e++){let t=e*s;for(let e=0;e<s;e++)l[e]=Math.max(l[e],o(h[t+e],0,n).length)}return l}(e,t,n,s),c=t.length,h=function e(t,n,r,i,s,l=!0){let c="complex64"===r?2:1,h=n[0],f=n.length;if(0===f)return"complex64"===r?[o(u(t)[0],0,r)]:"bool"===r?[a(t[0])]:[t[0].toString()];if(1===f){if(h>20){let e=Array.from(t.slice(0,3*c)),n=Array.from(t.slice((h-3)*c,h*c));return"complex64"===r&&(e=u(e),n=u(n)),["["+e.map((e,t)=>o(e,s[t],r)).join(", ")+", ..., "+n.map((e,t)=>o(e,s[h-3+t],r)).join(", ")+"]"]}return["["+("complex64"===r?u(t):Array.from(t)).map((e,t)=>o(e,s[t],r)).join(", ")+"]"]}let d=n.slice(1),p=i.slice(1),g=i[0]*c,m=[];if(h>20){for(let n=0;n<3;n++){let i=n*g,o=i+g;m.push(...e(t.slice(i,o),d,r,p,s,!1))}m.push("...");for(let n=h-3;n<h;n++){let i=n*g,o=i+g;m.push(...e(t.slice(i,o),d,r,p,s,n===h-1))}}else for(let n=0;n<h;n++){let i=n*g,o=i+g;m.push(...e(t.slice(i,o),d,r,p,s,n===h-1))}let b=2===f?",":"";m[0]="["+(h>0?m[0]+b:"");for(let e=1;e<m.length-1;e++)m[e]=" "+m[e]+b;let y=",\n";for(let e=2;e<f;e++)y+="\n";return m[m.length-1]=" "+m[m.length-1]+"]"+(l?"":y),m}(e,t,n,s,l),f=["Tensor"];return r&&(f.push(`  dtype: ${n}`),f.push(`  rank: ${c}`),f.push(`  shape: [${t}]`),f.push("  values:")),f.push(h.map(e=>"    "+e).join("\n")),f.join("\n")}(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),h.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),c().makeVariable(this,e,t,n)}}function m(){return(0,r.R)("Tensor",()=>g)}Object.defineProperty(g,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),m();class b extends g{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!i.cO(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);c().disposeTensor(this),this.dataId=e.dataId,c().incRef(this,null)}dispose(){c().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(b,Symbol.hasInstance,{value:e=>e instanceof g&&null!=e.assign&&e.assign instanceof Function})},5420:function(e,t,n){"use strict";n.r(t),n.d(t,{assertTypesMatch:function(){return u},getTensorsInContainer:function(){return l},isTensorInList:function(){return s},makeTypesMatch:function(){return a}});var r=n(6150),i=n(8638),o=n(2771);function a(e,t){if(e.dtype===t.dtype)return[e,t];let n=(0,i.x8)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function u(e,t){(0,o.hu)(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function s(e,t){return t.some(t=>t.id===e.id)}function l(e){let t=[];return function e(t,n,i){if(null!=t){if(t instanceof r.es){n.push(t);return}if(Array.isArray(t)||"object"==typeof t)for(let r in t){let o=t[r];i.has(o)||(i.add(o),e(o,n,i))}}}(e,t,new Set),t}},971:function(e,t,n){"use strict";n.d(t,{C:function(){return l},_1:function(){return h},sI:function(){return f}});var r=n(9681),i=n(6472),o=n(6150),a=n(8638),u=n(2904),s=n(2771);function l(e,t){let n=e;if((0,u.isTypedArray)(e))return"string"===t?[]:[e.length];if((0,a.Oq)(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if((0,a.$F)(e))return[e.buffer.size/(null==t?4:(0,s.bT)(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||(0,u.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,i.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function e(t,n,r){if(r=r||[],!Array.isArray(t)&&!(0,u.isTypedArray)(t)){(0,s.hu)(0===n.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);return}(0,s.hu)(n.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${t.length} elements`),(0,s.hu)(t.length===n[0],()=>`Element arr[${r.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);let i=n.slice(1);for(let n=0;n<t.length;++n)e(t[n],i,r.concat(n))}(e,r,[]),r}function c(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function h(e,t,n,i="numeric"){if(e instanceof(0,o.t3)())return c(i,e.dtype,t,n),e;let a=(0,s.D2)(e);if("string"!==a&&["bool","int32","float32"].indexOf(i)>=0&&(a=i),c(i,a,t,n),null==e||!(0,u.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let h=l(e,a);(0,u.isTypedArray)(e)||Array.isArray(e)||(e=[e]);let f="string"!==a?(0,u.toTypedArray)(e,a):(0,u.flatten)(e,[],!0);return r.BV.makeTensor(f,h,a)}function f(e,t,n,r="numeric"){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,i)=>h(e,`${t}[${i}]`,n,r))}},8638:function(e,t,n){"use strict";var r,i,o,a,u,s,l,c,h,f;n.d(t,{$F:function(){return b},Oq:function(){return m},x8:function(){return p},yw:function(){return r},z4:function(){return g}}),(s=r||(r={})).R0="R0",s.R1="R1",s.R2="R2",s.R3="R3",s.R4="R4",s.R5="R5",s.R6="R6",(l=i||(i={})).float32="float32",l.int32="int32",l.bool="int32",l.complex64="complex64",(c=o||(o={})).float32="float32",c.int32="int32",c.bool="bool",c.complex64="complex64",(h=a||(a={})).float32="float32",h.int32="float32",h.bool="float32",h.complex64="complex64",(f=u||(u={})).float32="complex64",f.int32="complex64",f.bool="complex64",f.complex64="complex64";let d={float32:a,int32:i,bool:o,complex64:u};function p(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw Error(`Can not upcast ${e} with ${t}`)}return d[e][t]}function g(e){return p(e,"int32")}function m(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function b(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}},2904:function(e,t,n){"use strict";n.r(t),n.d(t,{arraysEqual:function(){return o.cO},arraysEqualWithNull:function(){return o.DK},assert:function(){return o.hu},assertNonNegativeIntegerDimensions:function(){return o.Mu},assertNonNull:function(){return o.Cq},assertShapesMatch:function(){return o.k5},bytesFromStringArray:function(){return o.Ub},bytesPerElement:function(){return o.bT},checkConversionForErrors:function(){return o.D5},clamp:function(){return o.uZ},computeStrides:function(){return o.e3},convertBackendValuesAndArrayBuffer:function(){return o.KS},createScalarValue:function(){return w},createShuffledIndices:function(){return o.U$},decodeString:function(){return E},distSquared:function(){return o.E7},encodeString:function(){return x},fetch:function(){return _},fingerPrint64:function(){return y},flatten:function(){return $},getArrayFromDType:function(){return o.rQ},getTypedArrayFromDType:function(){return o.WP},hasEncodingLoss:function(){return o.QB},hexToLong:function(){return s},indexToLoc:function(){return o.NE},inferDtype:function(){return o.D2},inferFromImplicitShape:function(){return o.JZ},isBoolean:function(){return o.jn},isFunction:function(){return o.mf},isInt:function(){return o.GN},isNumber:function(){return o.hj},isPromise:function(){return o.tI},isScalarShape:function(){return o.xH},isString:function(){return o.HD},isTypedArray:function(){return S},isValidDtype:function(){return o.LP},locToIndex:function(){return o.qy},makeOnesTypedArray:function(){return o.p8},makeZerosNestedTypedArray:function(){return o.l6},makeZerosTypedArray:function(){return o.wT},nearestDivisor:function(){return o.jP},nearestLargerEven:function(){return o.nY},now:function(){return k},parseAxisParam:function(){return o.EC},randUniform:function(){return o.bj},repeatedTry:function(){return o.WD},rightPad:function(){return o.oj},shuffle:function(){return o.TV},shuffleCombo:function(){return o.d7},sizeFromShape:function(){return o.NA},sizeToSquarishShape:function(){return o.YP},squeezeShape:function(){return o.bp},sum:function(){return o.Sm},swap:function(){return o.LF},tanh:function(){return o.AE},toNestedArray:function(){return o.GX},toTypedArray:function(){return v}});var r=n(6472),i=n(8719),o=n(2771),a=n(398);let u=n.n(a)()||a;function s(e){return u.fromString(e,!0,16)}let l=s("c3a5c85c97cb3127"),c=s("b492b66fbe98f273"),h=s("9ae16a3b2f90404f");function f(e){return e.xor(e.shru(47))}function d(e,t,n){let r=e.slice(t,t+n);return u.fromBytes(Array.from(r),!0,!0)}function p(e,t){return d(e,t,8)}function g(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function m(e,t,n=s("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let i=t.xor(r).mul(n);return(i=i.xor(i.shru(47))).mul(n)}function b(e,t,n,r){return function(e,t,n,r,i,o){i=i.add(e),o=g(o.add(i).add(r),21);let a=i;return i=(i=i.add(t)).add(n),o=o.add(g(i,44)),[i.add(r),o.add(a)]}(p(e,t),p(e,t+8),p(e,t+16),p(e,t+24),n,r)}function y(e,t=e.length){let n=u.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){let n=h.add(2*t),r=p(e,0).add(h),i=p(e,t-8);return m(g(i,37).mul(n).add(r),g(r,25).add(i).mul(n),n)}if(t>=4){let n=h.add(2*t);return m(d(e,0,4).shl(3).add(t),d(e,t-4,4),n)}if(t>0){let n=e[0],r=e[t>>1],i=e[t-1];return f(h.mul(n+(r<<8)).xor(l.mul(t+(i<<2)))).mul(h)}return h}(e,t):function(e,t=e.length){let n=h.add(2*t),r=p(e,0).mul(c),i=p(e,8),o=p(e,t-8).mul(n),a=p(e,t-16).mul(h);return m(g(r.add(i),43).add(g(o,30)).add(a),r.add(g(i.add(h),18)).add(o),n)}(e,t);if(t<=64)return function(e,t=e.length){let n=h.add(2*t),r=p(e,0).mul(h),i=p(e,8),o=p(e,t-8).mul(n),a=p(e,t-16).mul(h),u=g(r.add(i),43).add(g(o,30)).add(a),s=m(u,r.add(g(i.add(h),18)).add(o),n),l=p(e,16).mul(n),c=p(e,24),f=u.add(p(e,t-32)).mul(n),d=s.add(p(e,t-24)).mul(n);return m(g(l.add(c),43).add(g(f,30)).add(d),l.add(g(c.add(r),18)).add(f),n)}(e,t);let r=n,i=n.mul(c).add(113),o=f(i.mul(h).add(113)).mul(h),a=[u.UZERO,u.UZERO],s=[u.UZERO,u.UZERO];r=r.mul(h).add(p(e,0));let y=0,w=(t-1>>6)*64;do r=g(r.add(i).add(a[0]).add(p(e,y+8)),37).mul(c),i=g(i.add(a[1]).add(p(e,y+48)),42).mul(c),r=r.xor(s[1]),i=i.add(a[0]).add(p(e,y+40)),o=g(o.add(s[0]),33).mul(c),a=b(e,y,a[1].mul(c),r.add(s[0])),s=b(e,y+32,o.add(s[1]),i.add(p(e,y+16))),[o,r]=[r,o],y+=64;while(y!==w);let v=c.add(o.and(255).shl(1));return y=w+(t-1&63)-63,s[0]=s[0].add(t-1&63),a[0]=a[0].add(s[0]),s[0]=s[0].add(a[0]),r=g(r.add(i).add(a[0]).add(p(e,y+8)),37).mul(v),i=g(i.add(a[1]).add(p(e,y+48)),42).mul(v),r=r.xor(s[1].mul(9)),i=i.add(a[0].mul(9).add(p(e,y+40))),o=g(o.add(s[0]),33).mul(v),a=b(e,y,a[1].mul(v),r.add(s[0])),s=b(e,y+32,o.add(s[1]),i.add(p(e,y+16))),[o,r]=[r,o],m(m(a[0],s[0],v).add(f(i).mul(l)).add(o),m(a[1],s[1],v).add(r),v)}function w(e,t){return"string"===t?x(e):v([e],t)}function v(e,t){var n;if("string"===t)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=$(e)),(0,r.OB)().getBool("DEBUG")&&o.D5(e,t),(n=e)instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t)return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw Error(`Unknown data type ${t}`)}function k(){return(0,r.OB)().platform.now()}function _(e,t){return(0,r.OB)().platform.fetch(e,t)}function x(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.encode(e,t)}function E(e,t="utf-8"){return t=t||"utf-8",(0,r.OB)().platform.decode(e,t)}function S(e){return null!=(0,r.OB)().platform.isTypedArray?(0,r.OB)().platform.isTypedArray(e):(0,i.j)(e)}function $(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||o.tI(e)||null==e||S(e)&&n)t.push(e);else if(Array.isArray(e)||S(e))for(let r=0;r<e.length;++r)$(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let i=0;i<=r;i++)$(e[i],t,n)}return t}},2771:function(e,t,n){"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,u(e,--t,n)}function i(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,u(e,--n,r),u(t,n,r)}function o(e,t,n){return Math.max(e,Math.min(t,n))}function a(e){return e%2==0?e:e+1}function u(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function s(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function l(e,t){let n=Math.random();return t*n+(1-n)*e}function c(e,t){let n=0;for(let r=0;r<e.length;r++){let i=Number(e[r])-Number(t[r]);n+=i*i}return n}function h(e,t){if(!e)throw Error("string"==typeof t?t:t())}function f(e,t,n=""){h(b(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function d(e){h(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function p(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function g(e){return 0===e.length}function m(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function b(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function y(e){return e%1==0}function w(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return -1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function v(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function k(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function _(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function x(e,t=e=>0,n,r){return new Promise((i,o)=>{let a=0,u=()=>{if(e()){i();return}let s=t(++a);if(null!=n&&a>=n){o();return}null!=r?r(u,s):setTimeout(u,s)};u()})}function E(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let i=e.slice();return i[r]=t/n,i}function S(e,t){let n=t.length;return h((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),h(e.every(e=>y(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function $(e,t){let n=[],r=[],i=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||i?null:S(t,e).sort(),a=0;for(let t=0;t<e.length;++t){if(null!=o){if(o[a]===t&&1!==e[t])throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==o[a]||o[a]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),o[a]<=t&&a++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function B(e,t){return A(e,t)}function A(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else if("string"===e)n=Array(t);else throw Error(`Unknown data type ${e}`);return n}function I(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function T(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function N(e,t){return"complex64"!==t&&("float32"!==t||"complex64"===e)&&("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)}function M(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw Error(`Unknown dtype ${e}`)}function D(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function R(e){return"string"==typeof e||e instanceof String}function V(e){return"boolean"==typeof e}function O(e){return"number"==typeof e}function C(e){return!!(e&&e.constructor&&e.call&&e.apply)}function F(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function P(e){let t=e.length;if(t<2)return[];let n=Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function L(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return function e(t,n,r,i=!1){let o=[];if(1===n.length){let e=n[0]*(i?2:1);for(let n=0;n<e;n++)o[n]=r[t+n]}else{let a=n[0],u=n.slice(1),s=u.reduce((e,t)=>e*t)*(i?2:1);for(let n=0;n<a;n++)o[n]=e(t+n*s,u,r,i)}return o}(0,e,t,n)}function G(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function U(e,t){let n=z(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function z(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function W(e,t){let n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return L(e,new Float32Array(n));if("int32"===t)return L(e,new Int32Array(n));if("bool"===t)return L(e,new Uint8Array(n));throw Error(`Unknown data type ${t}`)}function q(e){e.forEach(t=>{h(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function K(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function H(e,t,n){if(0===t)return[];if(1===t)return[e];let r=Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function j(e){return e&&e.then&&"function"==typeof e.then}n.d(t,{AE:function(){return w},Cq:function(){return d},D2:function(){return function e(t){if(Array.isArray(t))return e(t[0]);if(t instanceof Float32Array);else if(t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray)return"int32";else if(O(t));else if(R(t))return"string";else if(V(t))return"bool";return"float32"}},D5:function(){return I},DK:function(){return m},E7:function(){return c},EC:function(){return S},GN:function(){return y},GX:function(){return L},HD:function(){return R},JZ:function(){return E},KS:function(){return G},LF:function(){return u},LP:function(){return T},Mu:function(){return q},NA:function(){return p},NE:function(){return H},QB:function(){return N},Sm:function(){return s},TV:function(){return r},U$:function(){return k},Ub:function(){return D},WD:function(){return x},WP:function(){return B},YP:function(){return v},bT:function(){return M},bj:function(){return l},bp:function(){return $},cO:function(){return b},d7:function(){return i},e3:function(){return P},hj:function(){return O},hu:function(){return h},jP:function(){return F},jn:function(){return V},k5:function(){return f},l6:function(){return W},mf:function(){return C},nY:function(){return a},oj:function(){return _},p8:function(){return U},qy:function(){return K},rQ:function(){return A},tI:function(){return j},uZ:function(){return o},wT:function(){return z},xH:function(){return g}})},398:function(e){e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var i={},o={};function a(e,t){var n,r,a;return t?(e>>>=0,(a=0<=e&&e<256)&&(r=o[e]))?r:(n=s(e,(0|e)<0?-1:0,!0),a&&(o[e]=n),n):(e|=0,(a=-128<=e&&e<128)&&(r=i[e]))?r:(n=s(e,e<0?-1:0,!1),a&&(i[e]=n),n)}function u(e,t){if(isNaN(e))return t?b:m;if(t){if(e<0)return b;if(e>=d)return _}else{if(e<=-p)return x;if(e+1>=p)return k}return e<0?u(-e,t).neg():s(e%f|0,e/f|0,t)}function s(e,t,r){return new n(e,t,r)}n.fromInt=a,n.fromNumber=u,n.fromBits=s;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var r,i=u(l(n,8)),o=m,a=0;a<e.length;a+=8){var s=Math.min(8,e.length-a),h=parseInt(e.substring(a,a+s),n);if(s<8){var f=u(l(n,s));o=o.mul(f).add(u(h))}else o=(o=o.mul(i)).add(u(h))}return o.unsigned=t,o}function h(e,t){return"number"==typeof e?u(e,t):"string"==typeof e?c(e,t):s(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var f=4294967296,d=18446744073709552e3,p=0x7fffffffffffffff,g=a(16777216),m=a(0);n.ZERO=m;var b=a(0,!0);n.UZERO=b;var y=a(1);n.ONE=y;var w=a(1,!0);n.UONE=w;var v=a(-1);n.NEG_ONE=v;var k=s(-1,2147483647,!1);n.MAX_VALUE=k;var _=s(-1,-1,!0);n.MAX_UNSIGNED_VALUE=_;var x=s(0,-2147483648,!1);n.MIN_VALUE=x;var E=n.prototype;E.toInt=function(){return this.unsigned?this.low>>>0:this.low},E.toNumber=function(){return this.unsigned?(this.high>>>0)*f+(this.low>>>0):this.high*f+(this.low>>>0)},E.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(!this.eq(x))return"-"+this.neg().toString(e);var t=u(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}for(var i=u(l(e,6),this.unsigned),o=this,a="";;){var s=o.div(i),c=(o.sub(s.mul(i)).toInt()>>>0).toString(e);if((o=s).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},E.getHighBits=function(){return this.high},E.getHighBitsUnsigned=function(){return this.high>>>0},E.getLowBits=function(){return this.low},E.getLowBitsUnsigned=function(){return this.low>>>0},E.getNumBitsAbs=function(){if(this.isNegative())return this.eq(x)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return 0!=this.high?t+33:t+1},E.isZero=function(){return 0===this.high&&0===this.low},E.eqz=E.isZero,E.isNegative=function(){return!this.unsigned&&this.high<0},E.isPositive=function(){return this.unsigned||this.high>=0},E.isOdd=function(){return(1&this.low)==1},E.isEven=function(){return(1&this.low)==0},E.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},E.eq=E.equals,E.notEquals=function(e){return!this.eq(e)},E.neq=E.notEquals,E.ne=E.notEquals,E.lessThan=function(e){return 0>this.comp(e)},E.lt=E.lessThan,E.lessThanOrEqual=function(e){return 0>=this.comp(e)},E.lte=E.lessThanOrEqual,E.le=E.lessThanOrEqual,E.greaterThan=function(e){return this.comp(e)>0},E.gt=E.greaterThan,E.greaterThanOrEqual=function(e){return this.comp(e)>=0},E.gte=E.greaterThanOrEqual,E.ge=E.greaterThanOrEqual,E.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},E.comp=E.compare,E.negate=function(){return!this.unsigned&&this.eq(x)?x:this.not().add(y)},E.neg=E.negate,E.add=function(e){r(e)||(e=h(e));var t,n,i=this.high>>>16,o=65535&this.high,a=this.low>>>16,u=65535&this.low,l=e.high>>>16,c=65535&e.high,f=e.low>>>16,d=65535&e.low,p=0,g=0;return t=0+((n=0+(u+d))>>>16),n&=65535,t+=a+f,g+=t>>>16,t&=65535,g+=o+c,p+=g>>>16,g&=65535,p+=i+l,s(t<<16|n,(p&=65535)<<16|g,this.unsigned)},E.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},E.sub=E.subtract,E.multiply=function(e){if(this.isZero())return m;if(r(e)||(e=h(e)),t)return s(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(x))return e.isOdd()?x:m;if(e.eq(x))return this.isOdd()?x:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return u(this.toNumber()*e.toNumber(),this.unsigned);var n,i,o=this.high>>>16,a=65535&this.high,l=this.low>>>16,c=65535&this.low,f=e.high>>>16,d=65535&e.high,p=e.low>>>16,b=65535&e.low,y=0,w=0;return n=0+((i=0+c*b)>>>16),i&=65535,n+=l*b,w+=n>>>16,n&=65535,n+=c*p,w+=n>>>16,n&=65535,w+=a*b,y+=w>>>16,w&=65535,w+=l*p,y+=w>>>16,w&=65535,w+=c*d,y+=w>>>16,w&=65535,y+=o*b+a*p+l*d+c*f,s(n<<16|i,(y&=65535)<<16|w,this.unsigned)},E.mul=E.multiply,E.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");if(t){var n,i,o;return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?s((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return w;o=b}else{if(this.eq(x))return e.eq(y)||e.eq(v)?x:e.eq(x)?y:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?y:v:(i=this.sub(e.mul(n)),o=n.add(i.div(e)));if(e.eq(x))return this.unsigned?b:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=m}for(i=this;i.gte(e);){for(var a=Math.ceil(Math.log(n=Math.max(1,Math.floor(i.toNumber()/e.toNumber())))/Math.LN2),c=a<=48?1:l(2,a-48),f=u(n),d=f.mul(e);d.isNegative()||d.gt(i);)n-=c,d=(f=u(n,this.unsigned)).mul(e);f.isZero()&&(f=y),o=o.add(f),i=i.sub(d)}return o},E.div=E.divide,E.modulo=function(e){return(r(e)||(e=h(e)),t)?s((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},E.mod=E.modulo,E.rem=E.modulo,E.not=function(){return s(~this.low,~this.high,this.unsigned)},E.and=function(e){return r(e)||(e=h(e)),s(this.low&e.low,this.high&e.high,this.unsigned)},E.or=function(e){return r(e)||(e=h(e)),s(this.low|e.low,this.high|e.high,this.unsigned)},E.xor=function(e){return r(e)||(e=h(e)),s(this.low^e.low,this.high^e.high,this.unsigned)},E.shiftLeft=function(e){return(r(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?s(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):s(0,this.low<<e-32,this.unsigned)},E.shl=E.shiftLeft,E.shiftRight=function(e){return(r(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?s(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):s(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},E.shr=E.shiftRight,E.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?s(this.low>>>e|t<<32-e,t>>>e,this.unsigned):32===e?s(t,0,this.unsigned):s(t>>>e-32,0,this.unsigned)},E.shru=E.shiftRightUnsigned,E.shr_u=E.shiftRightUnsigned,E.toSigned=function(){return this.unsigned?s(this.low,this.high,!1):this},E.toUnsigned=function(){return this.unsigned?this:s(this.low,this.high,!0)},E.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},E.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},E.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},9900:function(e,t,n){var r=n(4170),i=n(6085),o=n(6543),a=n(1871),u=n(5794),s=n(1849),l=n(3957);l.alea=r,l.xor128=i,l.xorwow=o,l.xorshift7=a,l.xor4096=u,l.tychei=s,e.exports=l},4170:function(e,t,n){var r;!function(e,i,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));t=r>>>0,r-=t,r*=t,t=r>>>0,r-=t,t+=4294967296*r}return(t>>>0)*23283064365386963e-26});n.next=function(){var e=2091639*n.s0+23283064365386963e-26*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1)}function u(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+(2097152*i()|0)*11102230246251565e-32},i.quick=i,r&&("object"==typeof r&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},1849:function(e,t,n){var r;!function(e,i,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function u(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/2097152;while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},6085:function(e,t,n){var r;!function(e,i,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function u(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/2097152;while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},5794:function(e,t,n){var r;!function(e,i,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,i=t.X,o=t.i;return t.w=r=r+1640531527|0,n=i[o+34&127],e=i[o=o+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=i[o]=n^e,t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,i,o,a,u=[],s=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,s=Math.max(s,t.length)),i=0,o=-32;o<s;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(a=a+1640531527|0,i=0==(n=u[127&o]^=r+a)?i+1:0);for(i>=128&&(u[127&(t&&t.length||0)]=-1),i=127,o=512;o>0;--o)r=u[i+34&127],n=u[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,u[i]=r^n;e.w=a,e.X=u,e.i=i}(t,e)}function u(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/2097152;while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.X&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},1871:function(e,t,n){var r;!function(e,i,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,i=t.i;return e=r[i],e^=e>>>7,n=e^e<<24^((e=r[i+1&7])^e>>>10)^((e=r[i+3&7])^e>>>3)^((e=r[i+4&7])^e<<7),e=r[i+7&7],e^=e<<13,n^=e^e<<9,r[i]=n,t.i=i+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(n=0,t=""+t;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function u(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/2097152;while(0===e);return e},i.int32=n.next,i.quick=i,r&&(r.x&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},6543:function(e,t,n){var r;!function(e,i,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function u(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/2097152;while(0===e);return e},i.int32=n.next,i.quick=i,r&&("object"==typeof r&&u(r,n),i.state=function(){return u(n,{})}),i}i&&i.exports?i.exports=s:n.amdD&&n.amdO?void 0!==(r=(function(){return s}).call(t,n,t,i))&&(i.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},3957:function(e,t,n){var r;!function(i,o,a){var u,s=a.pow(256,6),l=a.pow(2,52),c=2*l;function h(e,t,n){var r=[],h=p(function e(t,n){var r,i=[],o=typeof t;if(n&&"object"==o)for(r in t)try{i.push(e(t[r],n-1))}catch(e){}return i.length?i:"string"==o?t:t+"\0"}((t=!0==t?{entropy:!0}:t||{}).entropy?[e,g(o)]:null==e?function(){try{var e;return u&&(e=u.randomBytes)?e=e(256):(e=new Uint8Array(256),(i.crypto||i.msCrypto).getRandomValues(e)),g(e)}catch(e){var t=i.navigator,n=t&&t.plugins;return[+new Date,i,n,i.screen,g(o)]}}():e,3),r),m=new f(r),b=function(){for(var e=m.g(6),t=s,n=0;e<l;)e=(e+n)*256,t*=256,n=m.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|m.g(4)},b.quick=function(){return m.g(4)/4294967296},b.double=b,p(g(m.S),o),(t.pass||n||function(e,t,n,r){return(r&&(r.S&&d(r,m),e.state=function(){return d(m,{})}),n)?(a.random=e,t):e})(b,h,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,r=this,i=0,o=r.i=r.j=0,a=r.S=[];for(n||(e=[n++]);i<256;)a[i]=i++;for(i=0;i<256;i++)a[i]=a[o=255&o+e[i%n]+(t=a[i])],a[o]=t;(r.g=function(e){for(var t,n=0,i=r.i,o=r.j,a=r.S;e--;)t=a[i=255&i+1],n=256*n+a[255&(a[i]=a[o=255&o+t])+(a[o]=t)];return r.i=i,r.j=o,n})(256)}function d(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function p(e,t){for(var n,r=e+"",i=0;i<r.length;)t[255&i]=255&(n^=19*t[255&i])+r.charCodeAt(i++);return g(t)}function g(e){return String.fromCharCode.apply(0,e)}if(p(a.random(),o),e.exports){e.exports=h;try{u=n(5042)}catch(e){}}else void 0!==(r=(function(){return h}).call(t,n,t,e))&&(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)}}]);